<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Crazy</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-30T12:43:16.934Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mr.bin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>模块化三（CommonJS）</title>
    <link href="http://yoursite.com/2019/09/30/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%89/"/>
    <id>http://yoursite.com/2019/09/30/模块化三/</id>
    <published>2019-09-30T12:28:55.000Z</published>
    <updated>2019-09-30T12:43:16.934Z</updated>
    
    <content type="html"><![CDATA[<p>传统的网页没有模块化也问题不大，但在服务器端，没有模块，就无法简单的与操作系统以及其他应用程序交流，所以 <code>NodeJS</code> 的诞生之初，就是参照 <code>CommonJS</code> 规范来实现其模块系统的</p><h3 id="CommonJS规范的定义"><a href="#CommonJS规范的定义" class="headerlink" title="CommonJS规范的定义"></a>CommonJS规范的定义</h3><p><code>CommonJS</code> 对模块的定义分为三个部分</p><ol><li>模块引用 <code>require</code> ，用于引入外部的模块</li><li>模块定义 <code>exports</code> ,  用于导出当前模块的方法或者变量，<code>exports</code> 对象是 <code>module</code> 的一个属性</li><li>模块标识 <code>module</code> ,  是一个对象，用来表示模块本身</li></ol><h3 id="NodeJS的模块实现"><a href="#NodeJS的模块实现" class="headerlink" title="NodeJS的模块实现"></a>NodeJS的模块实现</h3><p>在 <code>Node</code> 中引入模块，需要经历如下三个步骤</p><p>1.路径分析</p><p>2.文件定位</p><p>3.编译执行</p><p>在 <code>Node</code> 中，模块分为两类</p><ol><li><p>由 <code>Node</code> 提供的模块，称为核心模块，该部分在 <code>Node</code> 源代码的编译过程中，就被编译进入了二进制执行文件，在 <code>Node</code>进程启动时，部分核心模块就被直接加载进入内存中，所以这部分核心模块引入时，文件定位和编译执行可以省略，并且在路径分析中优先判断，所以其加载速度也是最快的</p></li><li><p>由用户编写的模块，称为文件模块，该部分在运行时动态加载，需要完整的经历上述的三个步骤，因此，其速度比核心模块慢</p></li></ol><h4 id="模块缓存"><a href="#模块缓存" class="headerlink" title="模块缓存"></a>模块缓存</h4><p><code>Node</code> 对引入模块，缓存的是模块编译和执行之后的对象，而浏览器仅仅缓存文件，<strong><code>require()</code> 方法对相同模块的二次加载都会采取缓存优先的方式</strong>，而核心模块的缓存检查会优先于文件模块的缓存检查</p><h4 id="路径分析"><a href="#路径分析" class="headerlink" title="路径分析"></a>路径分析</h4><p><code>require()</code> 方法接受一个<strong>标识符</strong>作为参数，路径分析的优先级是这样的</p><ol><li><p>缓存加载</p></li><li><p>核心模块加载</p></li><li><p>相对或绝对路径的形式加载（<strong>这种方式引入的模块都会被当做文件模块处理</strong>）</p></li><li><p>非路径形式的文件模块（自定义模块，一般引入别人的模块时会用到，可能是一个文件或者一个包，这种引入方式也是最慢的）</p></li></ol><p><strong>遍历模块路径数组</strong>是 <code>Node</code> 在定位文件模块的具体文件时制定的查找方式</p><p>在 <code>.js</code> 文件中打印出 <code>module.paths</code> ，可得类似这样的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">'D:\\前端\\demo\\模块化demo\\CommonJS\\node_modules'</span>,</span><br><span class="line">  <span class="string">'D:\\前端\\demo\\模块化demo\\node_modules'</span>,</span><br><span class="line">  <span class="string">'D:\\前端\\demo\\node_modules'</span>,</span><br><span class="line">  <span class="string">'D:\\前端\\node_modules'</span>,</span><br><span class="line">  <span class="string">'D:\\node_modules'</span> ]</span><br></pre></td></tr></table></figure><p>模块路径的生成规则是如下所示</p><ol><li>当前文件目录下的 <code>node_module</code> 目录</li><li>父目录下的 <code>node_module</code> 目录</li><li>父目录的父目录下的 <code>node_module</code> 目录</li><li>沿路径向上逐级递归，直到跟目录下的 <code>node_module</code> 目录</li></ol><p>在加载过程中， <code>Node</code> 会逐个尝试模块路径数组中的路径，直到找到目标文件为止，所以当文件的路径越深，其模块路径查找耗时会越多，这也是自定义模块的加载速度是最慢的原因</p><h4 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h4><p>文件定位的过程中，主要是以下两个事情的处理</p><ol><li>文件扩展名分析</li></ol><p><code>CommonJS</code> 规范允许标识符中不含文件扩展名，这种情况下，<code>Node</code> 会按<code>.js</code>,  <code>.json</code> , <code>.node</code> 的次序补全扩展名，依次尝试，在尝试过程中，需要调用 <code>fs</code> 模块同步阻塞式的判断文件是否存在</p><ol start="2"><li>目录分析和包</li></ol><p>在分析标识符过程中，<code>require()</code> 没有通过分析文件扩展名找到对应的文件，但却得到一个目录，这时候 <code>Node</code>会将这个目录当做一个包来处理</p><p>而在这个过程中，<code>Node</code> 对 <code>CommonJS</code> 包规范进行了一定程度的支持，处理包的过程如下</p><ol><li><p>Node在当前目录下查找 <code>package.json</code> （ <code>CommonJS</code> 包规范定义的包描述文件），然后通过 <code>JSON.parse()</code> 解析出包描述对象，取其 <code>main</code> 属性指定的文件名进行定位，如果缺少扩展名再进入扩展名分析的步骤</p></li><li><p>如果没有 <code>package.json</code> ，或者 <code>main</code> 属性指定的文件名出错，<code>Node</code> 会将 <code>index</code> 默认为文件名，并以此查找 <code>index.js</code>,  <code>index.json</code>,  <code>index.node</code></p></li><li><p>如果在目录分析的过程中没有成功定位到任何文件，则自定义模块会进入下一个模块路径进行查找，倘若模块路径数组被遍历完仍未查找到目标文件，则会抛出查找失败的异常</p></li></ol><h4 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h4><p>在Node中，每个文件模块都是一个对象，定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译，对于不同的文件扩展名，其载入方式也不一样</p><ol><li><p><code>.js</code> 文件，先 <code>fs</code> 模块同步读取后编译执行，后面会详细介绍</p></li><li><p><code>.json</code> 文件，先 <code>fs</code> 模块同步读取，然后再用 <code>JSON.parse()</code> 解析返回结果</p></li><li><p><code>.node</code> 文件，这是 <code>C/C++</code> 编写的扩展文件，通过 <code>dlopen()</code> 方法加载，最后编译生成文件</p></li><li><p>其余扩展名文件，当做 <code>.js</code> 文件载入</p></li></ol><p><strong>JavaScript模块的编译</strong></p><p>每个模块文件存在着 <code>require</code> ，<code>exports</code> ， <code>module</code> 这三个变量，以及<code>__dirname</code> ,<code>__filename</code>魔术变量</p><p>在我们没有定义这几个变量的情况下，为什么会出现这几个变量呢</p><p>原来，一个正常的 <code>.js</code> 文件会被 <code>Node</code> 包装成下面的样子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>)) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> fs = <span class="built_in">require</span>(fs);</span><br><span class="line"> exports.name = <span class="string">"1bin"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在头部添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>)) </span>&#123;\n</span><br></pre></td></tr></table></figure><p>在尾部添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\n&#125;);</span><br></pre></td></tr></table></figure><p>就这样，每个模块文件之间都进行了作用域的隔离，<strong>包装之后的代码会通过 <code>vm</code> 原生模块的<code>runInThisContext()</code> 方法执行</strong>，在模块代码内部只能访问到 <code>global</code> 对象，模块外部的代码也只能访问到<code>exports</code> 属性导出的值和模块内部定义的 <code>global</code> 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//modA.js</span></span><br><span class="line"><span class="keyword">const</span> vm = <span class="built_in">require</span>(<span class="string">'vm'</span>)</span><br><span class="line"><span class="keyword">const</span> filename = <span class="built_in">require</span>(<span class="string">'./resolveFileName.js'</span>) <span class="comment">//文件定位中得到的完整文件路径</span></span><br><span class="line"><span class="keyword">const</span> dirname = <span class="built_in">require</span>(<span class="string">'./resolveDirName.js'</span>)<span class="comment">//文件定位中得到的文件目录</span></span><br><span class="line"><span class="keyword">let</span> cb = vm.runInThisContext(<span class="string">`(function (require,exports,module,__filename, __dirname)&#123;</span></span><br><span class="line"><span class="string">exports.name = "1bin"</span></span><br><span class="line"><span class="string">let age = require('./a.js').age</span></span><br><span class="line"><span class="string">module.exports.age = age</span></span><br><span class="line"><span class="string">&#125;);`</span>)</span><br><span class="line">cb.call(<span class="built_in">module</span>, <span class="built_in">require</span>, <span class="built_in">module</span>.exports, <span class="built_in">module</span>, filename, dirname)<span class="comment">//参数顺序要对应好</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">let</span> modA = <span class="built_in">require</span>(<span class="string">'./modA.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(modA) <span class="comment">// &#123; name: '1bin', age: 18 &#125;</span></span><br></pre></td></tr></table></figure><h4 id="一点点小疑问"><a href="#一点点小疑问" class="headerlink" title="一点点小疑问"></a>一点点小疑问</h4><p>也许有人会有疑问，为什么在有 <code>exports</code> 的情况下，还存在 <code>module.exports</code> </p><p>简单来说，<code>exports</code> 是 <code>Node</code> 提供给我们的语法糖，实际上在模块的开始阶段都会加上这句话</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exports = <span class="built_in">module</span>.exports = &#123;&#125;</span><br></pre></td></tr></table></figure><p>也就是说，<code>exports</code> 只是 <code>module.exports</code> 的一个引用，下面两种写法是等效的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exports.name = <span class="string">"1bin"</span></span><br><span class="line"><span class="built_in">module</span>.exports.name = <span class="string">"1bin"</span></span><br></pre></td></tr></table></figure><p>只不过我们推荐这种写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.name = <span class="string">"1bin"</span></span><br><span class="line"><span class="comment">//如果想一次性全部导出的话</span></span><br><span class="line"><span class="built_in">module</span>.expotrs = &#123; age, id&#125; <span class="comment">//这种写法会覆盖掉 exports 的导出，使得 exports 的导出 name 无效</span></span><br></pre></td></tr></table></figure><p>此外，<code>exports</code> 不能导出一个函数或类，即</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//error</span></span><br><span class="line">exports = [<span class="function"><span class="keyword">function</span>]</span></span><br><span class="line"><span class="function">//<span class="title">error</span></span></span><br><span class="line">exports = [class]</span><br></pre></td></tr></table></figure><p>因为函数或类也是个对象，如果将 <code>exports</code> 赋值给一个新的对象，会导致引用修改，即此时 <code>exports</code> 和原引用 <code>module.exports</code> 再无关系，由于 <code>Node</code> 的默认是将 <code>module.exports</code> 给导出，这将导致 <code>exports</code> 导出失败，这种情况下，只能使用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = [<span class="function"><span class="keyword">function</span>]</span></span><br><span class="line"><span class="function">//<span class="title">or</span></span></span><br><span class="line">module.exports = [class]</span><br></pre></td></tr></table></figure><h4 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h4><p><code>ES6</code> 模块和 <code>CommonJS</code> 模块完全不同</p><blockquote><p>它们有两个重大差异</p><ol><li><p><code>CommonJS</code> 模块输出的是一个值的拷贝(其 <code>this</code> 为 <code>全局对象</code>)，而 <code>ES6</code> 模块输出的是值的引用(所以其 <code>this</code> 为 <code>undefined</code> )</p></li><li><p><code>CommonJS</code> 模块是运行时加载，而 <code>ES6</code> 模块是编译时输出接口</p></li></ol></blockquote><p><strong>第一个差异的原因</strong></p><p>​    <code>CommonJS</code> 模块的值一旦输出，模块内部的变化就影响不到这个值，不像 <code>ES6</code> 模块有动态绑定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//modB.js</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAge</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  age++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  age,</span><br><span class="line">  addAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">let</span> modB = <span class="built_in">require</span>(<span class="string">'./modB'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(modB.age); <span class="comment">//18</span></span><br><span class="line">modB.addAge()</span><br><span class="line"><span class="built_in">console</span>.log(modB.age); <span class="comment">//18</span></span><br></pre></td></tr></table></figure><p><code>modB</code> 加载后，其 <code>modB.age</code> 值是个原始类型的值，会被缓存，所以看不到其值的改变</p><p>但如果将其值写成一个函数，便能得到其内部变化后的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//modB.js</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAge</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  age++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  get age()&#123; <span class="comment">//取值器函数</span></span><br><span class="line">    <span class="keyword">return</span> age</span><br><span class="line">  &#125;,</span><br><span class="line">  addAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">let</span> modB = <span class="built_in">require</span>(<span class="string">'./modB'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(modB.age); <span class="comment">//18</span></span><br><span class="line">modB.addAge()</span><br><span class="line"><span class="built_in">console</span>.log(modB.age); <span class="comment">//19</span></span><br></pre></td></tr></table></figure><p><strong>第二个差异的原因</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; age, name &#125; = <span class="built_in">require</span>(<span class="string">'./modB.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _modB = <span class="built_in">require</span>(<span class="string">'./modB.js'</span>)</span><br><span class="line"><span class="keyword">let</span> age = _modB.age</span><br><span class="line"><span class="keyword">let</span> name = _modB.name</span><br></pre></td></tr></table></figure><p>上面代码的实质是加载 <code>modB</code> 模块的所有方法，生成一个对象<code>_modB</code>  然后再从这个对象解构读取所需值或方法，这种叫做<strong>运行时加载</strong>，因为<strong>只有运行时才能得到这个对象，导致完全没办法在编译时做静态优化</strong></p><p>而 <code>ES6</code> 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，再通过 <code>import</code>命令输入。这个特性使得<code>ES6</code> 可以在编译时就完成模块加载，效率要比 <code>CommonJS</code> 模块的加载方式高</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;传统的网页没有模块化也问题不大，但在服务器端，没有模块，就无法简单的与操作系统以及其他应用程序交流，所以 &lt;code&gt;NodeJS&lt;/code&gt; 的诞生之初，就是参照 &lt;code&gt;CommonJS&lt;/code&gt; 规范来实现其模块系统的&lt;/p&gt;
&lt;h3 id=&quot;CommonJ
      
    
    </summary>
    
    
      <category term="CommonJS" scheme="http://yoursite.com/tags/CommonJS/"/>
    
  </entry>
  
  <entry>
    <title>模块化二（ES6模块）</title>
    <link href="http://yoursite.com/2019/09/26/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%BA%8C/"/>
    <id>http://yoursite.com/2019/09/26/模块化二/</id>
    <published>2019-09-26T12:40:45.000Z</published>
    <updated>2019-09-26T13:16:07.283Z</updated>
    
    <content type="html"><![CDATA[<p><code>AMD</code>, <code>CMD</code> 两种前端模块化标准都需要引入相应的 <code>.js</code>文件，而 <code>ES6模块</code> 算是官方模块化的一种标准，可以直接使用</p><p>内联引用 <code>script</code> 标签时引入模块，只需要给内联 <code>script</code> 标签设置 <strong><code>type=“module”</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"./main.js"</span> type=<span class="string">"module"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>浏览器对于带有<code>type=&quot;module&quot;</code>的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，<strong>等同于打开了<code>&lt;script&gt;</code>标签的<code>defer</code>属性</strong></p></blockquote><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><p>ES6的模块是编译时加载的，通过 <code>export</code> 命令指定输出，再通过 <code>import</code> 命令指定输入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//modA.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">saySomething</span>(<span class="params">myName</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;myName&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">"1bin"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, saySomething &#125;  <span class="keyword">from</span> <span class="string">'./modA.js'</span></span><br><span class="line">saySomething(name)</span><br></pre></td></tr></table></figure><p>值得注意的是，<strong><code>import</code> 模块的 <code>.js</code> 后缀名不能省，只能使用绝对或者相对路径</strong>，否则浏览器无法解析到模块导致报错</p><h4 id="export-命令"><a href="#export-命令" class="headerlink" title="export 命令"></a>export 命令</h4><p> <code>export</code> 命令规定的是对外的接口，<strong>该接口必须得和模块内部的变量建立起一对一的关系</strong></p><p>下面的写法就是典型的错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="string">"1bin"</span></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"1bin"</span></span><br><span class="line"><span class="keyword">export</span> name</span><br></pre></td></tr></table></figure><p>正确写法应该为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">"1bin"</span></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"1bin"</span></span><br><span class="line"><span class="keyword">export</span> &#123;name&#125; <span class="comment">//其他脚本可以通过这个接口，取到值 1bin</span></span><br><span class="line"><span class="comment">//or 使用as关键词取别名</span></span><br><span class="line"><span class="keyword">let</span> year = <span class="number">9102</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;year <span class="keyword">as</span> number&#125;</span><br></pre></td></tr></table></figure><p>函数和类也是一样得遵循这个写法来达到对外提供接口的效果，因为这样才能保证 <code>export</code> 输出的接口，与其对应的值是动态绑定关系</p><h4 id="import-命令"><a href="#import-命令" class="headerlink" title="import 命令"></a>import 命令</h4><p><code>import</code> 命令用于加载其他模块的对外接口，得到的变量都是只读的，也就是说，不允许在加载模块的脚本里面，改写接口（<strong><code>import</code> A模块的一个对象后，给该对象添加属性，其他模块引用A模块的该对象时也会受到影响，但这是极其不推荐的写法</strong>）</p><p><code>import</code> 命令会执行所加载的模块，所以可以有如下写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./modA.js'</span></span><br></pre></td></tr></table></figure><p><strong>多次加载一个模块只会执行一次，<code>import</code> 命令是在编译阶段执行，所以它是一个模块之中最早执行的，也就是具有所谓的提升效果</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line">saySomething();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; saySomething &#125; <span class="keyword">from</span> <span class="string">'./modA.js'</span>;</span><br></pre></td></tr></table></figure><h4 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h4><p><code>export default</code> 命令实质是将后面的值，赋给 <code>default</code> 变量，并将 <code>default</code>变量输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">"1bin"</span></span><br><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">let</span> name = <span class="string">"1bin"</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认函数输出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">saySomething</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I'm 1bin"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">import</span> saySomething <span class="keyword">from</span> <span class="string">'./modA.js'</span>; </span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> saySomething&#125; <span class="keyword">from</span> <span class="string">'./modA.js'</span></span><br><span class="line"><span class="comment">//同时引用默认接口和其他接口</span></span><br><span class="line"><span class="keyword">import</span> saySomething,&#123; name, age &#125; <span class="keyword">from</span> <span class="string">'./modA.js'</span></span><br></pre></td></tr></table></figure><h4 id="ES6模块思想"><a href="#ES6模块思想" class="headerlink" title="ES6模块思想"></a>ES6模块思想</h4><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量，而 <code>AMD</code> ，<code>CMD</code> ，<code>CommonJS</code>都只能在运行时确定这些东西</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; saySomething &#125; <span class="keyword">from</span> <span class="string">'./modA.js'</span></span><br></pre></td></tr></table></figure><p>像这样的加载叫做编译时加载（或称静态加载），只会从  <code>modA</code> 模块加载一个 <code>saySomething</code> 方法，其他属性或方法不加载，这样的加载效率自然比传统的模块化快，而这样也导致了不存在ES6模块本身，它压根不是个对象，因此其<strong>模块顶层的 <code>this</code> 为undefined</strong></p><p>正是由于这个编译时加载的特性，使得静态分析成为可能，有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏和类型检验这些只能靠静态分析实现的功能</p><p>这也是为什么 <code>export</code>，<code>import</code> 命令只能放在模块顶层，如果这些命令放在条件代码块里面，就无法做静态优化，这违背了ES6模块的设计初衷</p><p>也正是如此，<code>import</code> 命令不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//error</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="string">'na'</span>+ <span class="string">'me'</span>&#125; <span class="keyword">from</span> <span class="string">'./modA.js'</span></span><br><span class="line"><span class="comment">//error</span></span><br><span class="line"><span class="keyword">let</span> myMod = <span class="string">'./modA.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> myMod</span><br><span class="line"><span class="comment">//error</span></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">'./modA.js'</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; age &#125; <span class="keyword">from</span> <span class="string">'./modB.js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ES6模块运行机制"><a href="#ES6模块运行机制" class="headerlink" title="ES6模块运行机制"></a>ES6模块运行机制</h4><blockquote><p>JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，模块的原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//modA.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">"1bin"</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> name = <span class="string">"ebin"</span> , <span class="number">1000</span>)</span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">'./modA.js'</span></span><br><span class="line"><span class="built_in">console</span>.log(name,<span class="string">'&lt;&lt;==old name is here'</span>)  <span class="comment">//1bin</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(name, <span class="string">'&lt;&lt;==new name is here'</span>), <span class="number">1000</span>)  <span class="comment">//ebin</span></span><br></pre></td></tr></table></figure><h4 id="Import"><a href="#Import" class="headerlink" title="Import()"></a>Import()</h4><p>JS 引擎处理ES6模块的 <code>import</code>命令是在编译阶段，这就导致了无法在运行时选择加载模块，Node 的 <code>require()</code>方法就是运行时加载模块，也就是说 <code>require()</code> 到底加载哪个模块，只有运行的时候才知道，<code>import</code>命令无法做到这一点，所以，<code>Import()</code>诞生了，用来完成动态加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./modA.js'</span>).then(<span class="function"><span class="params">module</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">module</span>.name)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>import()</code>返回一个 <code>Promise</code>对象，加载模块成功后，这个模块会作为一个对象，当作 <code>then</code>的参数</p><p>想要同时加载多个模块，可以这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">    <span class="keyword">import</span>(<span class="string">'./modA.js'</span>),</span><br><span class="line">    <span class="keyword">import</span>(<span class="string">'./modB.js'</span>)</span><br><span class="line">])</span><br><span class="line">.then(<span class="function">(<span class="params">[modA, modB]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>按条件加载模块也成了可能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./modA.js'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./modB.js'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后</p><blockquote><p><code>import()</code>函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，<strong><code>import()</code>函数与所加载的模块没有静态连接关系</strong>，这点也是与<code>import</code>语句不相同。<strong><code>import()</code>类似于 Node 的<code>require</code>方法，区别主要是前者是异步加载，后者是同步加载。</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;AMD&lt;/code&gt;, &lt;code&gt;CMD&lt;/code&gt; 两种前端模块化标准都需要引入相应的 &lt;code&gt;.js&lt;/code&gt;文件，而 &lt;code&gt;ES6模块&lt;/code&gt; 算是官方模块化的一种标准，可以直接使用&lt;/p&gt;
&lt;p&gt;内联引用 &lt;code&gt;script
      
    
    </summary>
    
    
      <category term="ES6模块" scheme="http://yoursite.com/tags/ES6%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>模块化一（AMD，CMD）</title>
    <link href="http://yoursite.com/2019/09/24/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://yoursite.com/2019/09/24/模块化/</id>
    <published>2019-09-24T10:40:45.000Z</published>
    <updated>2019-09-24T11:35:55.194Z</updated>
    
    <content type="html"><![CDATA[<p>前端模块化是在web前端界面逻辑越来越复杂后出现的需求。先有AMD，后有CMD，到现在的ES6，这些都是为了解决前端模块化的标准</p><p>实现模块化的几个尝试</p><ul><li><p>函数封装：污染全局变量</p></li><li><p>对象：外部可以随意修改内部成员</p></li><li><p>IIFE：可以达到不暴露私有成员的目的，这也是模块化的基本写法</p><p><a href="https://www.cnblogs.com/dolphinX/p/4381855.html" target="_blank" rel="noopener">具体可见这里</a></p></li></ul><h4 id="AMD：requireJS"><a href="#AMD：requireJS" class="headerlink" title="AMD：requireJS"></a>AMD：requireJS</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config = &#123;</span><br><span class="line">  paths:&#123;</span><br><span class="line"><span class="comment">//键值对，用于改写路径</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依赖的顺序和回调函数的顺序一致</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">"modA"</span>, <span class="string">"modB"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">modA, modB</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名即模块名</span></span><br><span class="line">define([<span class="string">"modA"</span>, <span class="string">"modB"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">modA, modB</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">     fnC: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">`I'm modC`</span>)</span><br><span class="line">     &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果没有使用依赖，还可以这样define</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>([],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line">    exports.fnC = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="CMD：-seaJS"><a href="#CMD：-seaJS" class="headerlink" title="CMD： seaJS"></a>CMD： seaJS</h4><p>感觉和node的CommonJS规范很像</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">seajs.config(&#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line"><span class="comment">//键值对，用于改写路径</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//modA.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    exports.fnA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//or</span></span><br><span class="line">    <span class="built_in">module</span>.exports = &#123; <span class="attr">fnA</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>1.推崇文件名即为模块名</p><p>2.不推崇依赖提前（define写依赖），推崇依赖就近（factory里写依赖）</p><p>3.factory里的用法和node用法很像</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//modB.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fnA = <span class="built_in">require</span>(<span class="string">"modA"</span>).fnA</span><br><span class="line">    fnA()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在非factory里面是没有require的，如果要加载模块，可以这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line">seajs.use(<span class="string">"modA.js"</span>)</span><br><span class="line"><span class="comment">//or 下面需要callback的写法</span></span><br><span class="line">seajs.use(“modA.js”, <span class="function"><span class="keyword">function</span>(<span class="params">modA</span>)</span>&#123;</span><br><span class="line">    modA.fnA();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="AMD-与-CMD-的异同"><a href="#AMD-与-CMD-的异同" class="headerlink" title="AMD 与 CMD 的异同"></a>AMD 与 CMD 的异同</h4><p>​    最明显的区别在于<strong>模块定义时对依赖模块的处理不同</strong></p><blockquote><ol><li>AMD推崇依赖前置，在定义时候就要声明所需要的依赖模块</li><li>CMD推崇就近依赖，在用到依赖模块地方才去require</li></ol></blockquote><p>其实requireJS 和 seaJS 都可以支持对方的写法，但这两者的最大区别不在于语法，而在于<strong>对依赖模块的执行时机处理不同</strong></p><p>两者加载模块的方式都是异步的，只是AMD推崇依赖前置，js可以很快知道需要依赖的模块是什么，并且立即加载；而CMD推崇的就近依赖，需要把模块变成字符串解析一遍才能知道依赖了哪些模块，虽然解析模块的用时很短，不过还是对性能有所牺牲了</p><p>现假设定义某个模块需要依赖modA和modB两个模块，讨论两种规范的异同：</p><ul><li><p>同：两者都是异步加载依赖模块，等到所有模块都加载完（下载完），再去执行主逻辑回调函数</p></li><li><p>异：</p><p>AMD: 哪个模块先加载完，就先执行哪个模块，这样导致的问题便是依赖的执行顺序和程序员书写的顺序不一致，但是模块整体延迟就降低了</p><p>CMD: 依赖模块只有在需要用到它的时候（require的时候），才会执行模块，保证了模块的执行顺序和书写顺序是完全一致的</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前端模块化是在web前端界面逻辑越来越复杂后出现的需求。先有AMD，后有CMD，到现在的ES6，这些都是为了解决前端模块化的标准&lt;/p&gt;
&lt;p&gt;实现模块化的几个尝试&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;函数封装：污染全局变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对象：外部可以随意
      
    
    </summary>
    
    
      <category term="AMD" scheme="http://yoursite.com/tags/AMD/"/>
    
      <category term="CMD" scheme="http://yoursite.com/tags/CMD/"/>
    
  </entry>
  
  <entry>
    <title>跨域那些事</title>
    <link href="http://yoursite.com/2019/09/20/%E8%B7%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2019/09/20/跨域/</id>
    <published>2019-09-20T14:21:00.000Z</published>
    <updated>2019-09-20T14:42:26.790Z</updated>
    
    <content type="html"><![CDATA[<h3 id="跨域是什么"><a href="#跨域是什么" class="headerlink" title="-  跨域是什么"></a>-  跨域是什么</h3><p>​    <strong>协议，域名，端口，有一个不同即为跨域，跨域是浏览器的一种保护机制</strong></p><h3 id="跨域会如何"><a href="#跨域会如何" class="headerlink" title="-  跨域会如何"></a>-  跨域会如何</h3><p>​        跨域会受到以下三点非同源限制                </p><blockquote><ol><li>无法获取网页的 Cookie, Local Storage, Indexed DB</li><li>无法获取网页的 DOM 元素</li><li>无法向非同源地址发送 AJAX 请求</li></ol></blockquote><h3 id="网页与网页间的跨域交流"><a href="#网页与网页间的跨域交流" class="headerlink" title="-  网页与网页间的跨域交流"></a>-  网页与网页间的跨域交流</h3><ol><li><p>为了让两个跨域页面可以共享Cookie（此方案仅限主域相同，子域不同的跨域应用场景）</p><p>将 document.domain 设置成相同的父域名</p><p>eg: 两个网页</p><ol><li><p>cba.testCors.com:8080  </p></li><li><p>abc.testCors.com:8080  </p></li></ol><p>两边都设置 document.domain = testCors.com</p><p>ps:  这个浏览器还是会检测的，不是你想改成什么域名就变成什么的</p></li></ol><ol start="2"><li>跨文档通信 API：window.postMessage()</li></ol><h3 id="网页和服务器间的跨域交流"><a href="#网页和服务器间的跨域交流" class="headerlink" title="-  网页和服务器间的跨域交流"></a>-  网页和服务器间的跨域交流</h3><p>​            对下文的几点说明</p><blockquote><ol><li>前端为vue-cli搭建，端口号为8080</li><li>后台为koa2搭建，端口号为9099</li><li>在 C:\Windows\System32\drivers\etc 目录下，修改hosts文件，在文件底部增加  <code>127.0.0.1 testCors.com</code> 将 127.0.0.1 别名为 testCors.com </li></ol></blockquote><h4 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1.JSONP"></a>1.JSONP</h4><p>​    JSONP 兼容 IE , 只支持 GET 不支持 POST, 原理在于 script 标签的 src 属性不受跨域限制</p><p>​    网页:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">saySomething</span><span class="params">(str)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(str)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://testCors.com:9099/testGet?cb=saySomething"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    后台:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/testGet'</span>, <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; cb &#125; = ctx.request.query;</span><br><span class="line">    ctx.body = <span class="string">`<span class="subst">$&#123;cb&#125;</span>('now you see me')`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>​    技巧在于请求参数 cb 的值 saySomething 要在网页中定义好，后台只是把 saySomething(‘now you see me’) 发送到网页并执行</p><h4 id="2-CORS"><a href="#2-CORS" class="headerlink" title="2. CORS"></a>2. CORS</h4><p>​    CORS有两种请求，一是简单请求，二是非简单请求</p><h3 id="何为简单请求"><a href="#何为简单请求" class="headerlink" title="- 何为简单请求"></a>- 何为简单请求</h3><p>​    只要同时满足以下两大条件，就属于简单请求</p><ol><li><p>请求方式属于以下几种</p><ul><li>GET</li><li>POST </li><li>HEAD</li></ul></li><li><p>HTTP 请求头信息不超出以下几种字段 </p><ul><li><p>Accept </p></li><li><p>Accept-Language</p></li><li><p>Content-Language</p></li><li><p>Last-Event-ID</p></li><li><p>Content-Type: 只限于 </p><p>application/x-www-form-urlencoded</p><p>multipart/form-data</p><p>text/plain </p></li></ul></li></ol><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="- 简单请求"></a>- 简单请求</h3><p>​    只需要后台设置 Access-Control-Allow-Origin (以下简称 ACAO )</p><p>​    需要允许某个域名的时候 ，注意 协议 域名 端口 缺一不可，而且域名要全小写，有大写的时候不匹配</p><p>​    我前端域名是 testCors.com 后台也这样设置的话还是会报跨域，域名需要</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/testGet'</span>, <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.set(<span class="string">'Acess-Control-Allow-Origin'</span>, <span class="string">'http://testcors.com:8080'</span>);</span><br><span class="line">    ctx.body=<span class="string">"now you see me"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="前后端-cookie-通信"><a href="#前后端-cookie-通信" class="headerlink" title="- 前后端 cookie 通信"></a>- 前后端 cookie 通信</h3><p>​    若想前后端用 cookie 通信, 并将 cookie 保存在前端,值得注意的是,后台若将ACAO改为* ，这时f etch 需要将 credentials 选项去掉，并且此时对 cookie 的设置无效</p><p>​    所以为了能正常 cookie 通信，需要后台设置准确的地址，并且前后端都要开启 cookie 认证</p><p>​    前端:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">fetch(`http:<span class="comment">//testCors.com:9099/testGet`, &#123;</span></span></span><br><span class="line"><span class="actionscript">    credentials: <span class="string">'include'</span></span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="javascript">.then( <span class="keyword">async</span> res =&gt; &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="keyword">await</span> res.test())</span></span><br><span class="line"><span class="undefined">&#125;)    </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    后台:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/testGet'</span>, <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.set(<span class="string">'Access-Control-Allow-Origin'</span>,<span class="string">'http://testcors.com:8080'</span>)</span><br><span class="line">    ctx.set(<span class="string">'Access-Control-Allow-Credentials'</span>, <span class="literal">true</span>)</span><br><span class="line">    ctx.cookies.set(<span class="string">'tokenId'</span>,<span class="string">'111'</span>,&#123;<span class="attr">httpOnly</span>:<span class="literal">false</span>&#125;)</span><br><span class="line">    ctx.body = <span class="string">"now you see me"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>​    前端可以通过 <code>document.cookie</code> 来获取到 httpOnly 不为true的cookie，所以上述代码设置 cookie 时添加了 <code>httpOnly:false</code> 选项</p><p>​    当然 cookie 存在前端十分不安全, 只要在浏览器将 cookie 修改, 后台用<code>ctx.cookie.get(&#39;token&#39;)</code>的时候也会修改</p><h3 id="非简单类型请求"><a href="#非简单类型请求" class="headerlink" title="- 非简单类型请求"></a>- 非简单类型请求</h3><p>若添加headers来触发非简单请求的条件二（多加了HTTP头信息）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">fetch(<span class="string">`http://testCors.com:9099/testGet`</span>, &#123;</span><br><span class="line">    credentials: <span class="string">'include'</span>,</span><br><span class="line">    headers: <span class="keyword">new</span> Headers(&#123;<span class="string">'Content-Type'</span>: <span class="string">'application/jsons'</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then( <span class="keyword">async</span> res =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> res.test())</span><br><span class="line">&#125;)    </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>控制台会毫不留情的报错<br><img src="/../img\Snipaste_2019-09-20_22-17-56.png" alt=""></p><p><img src="/../img\Snipaste_2019-09-20_21-04-38.png" alt=""></p><p>并且请求方式貌似变成了 OPTIONS 这是因为</p><blockquote><p>在跨域并且尝试添加一些特殊头及自定义头的情况下，由于浏览器的安全机制，会加多一次OPTIONS预请求（询问请求），与跨域服务器协商可以设置的头部信息，可以允许的HTTP协议等等信息</p></blockquote><p>这时按照控制台的提示，在前端加上 <code>mode : &quot;no-cors&quot;</code> (不跨域)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">fetch(<span class="string">`http://testcors.com:9099/testGet?msg=Helllooo`</span>,&#123;</span><br><span class="line">    credentials: <span class="string">'include'</span>,</span><br><span class="line">    headers:<span class="keyword">new</span> Headers(&#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    mode: <span class="string">'no-cors'</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="keyword">async</span> res =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> res.text())</span><br><span class="line">&#125;)</span><br><span class="line"> &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>后台变成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/testGet'</span>, <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.set(<span class="string">'Access-Control-Allow-Origin'</span>,<span class="string">'*'</span>)</span><br><span class="line">  ctx.set(<span class="string">'Access-Control-Allow-Credentials'</span>, <span class="literal">true</span>)</span><br><span class="line">  ctx.cookies.set(<span class="string">'token'</span>,<span class="string">'222'</span>,&#123;</span><br><span class="line">    httpOnly:<span class="literal">false</span></span><br><span class="line">  &#125;)</span><br><span class="line">   <span class="comment">//以下为新增</span></span><br><span class="line">  ctx.set(<span class="string">'Access-Control-Request-Method'</span>, <span class="string">'PUT,POST,GET,DELETE,OPTIONS'</span>)</span><br><span class="line">  ctx.set(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Origin, X-Requested-With, Content-Type, Accept'</span>);</span><br><span class="line">  ctx.body = <span class="string">"now you see me"</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时，即使 ACAO 为 * ，也能正常进行 cookie 交流</p><p>上述方式多少有点奇怪， 比如为什么mode设置为 no-cors 还能跨域呢？</p><p>想不明白，我们来用终极方案吧</p><h3 id="koa-cors"><a href="#koa-cors" class="headerlink" title="koa-cors"></a><strong>koa-cors</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">'koa-cors'</span>);</span><br><span class="line">app.use(cors(&#123;</span><br><span class="line">    credentials:<span class="literal">true</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>前端 credentials 设置为 include （默认情况下前端不开启 cookie）</p><p>这样就什么问题都没了，对了如果前端设置了新的 headers 字段，会先发送个 OPTIONS请求核对 headers等信息，所以在控制台会先收到 OPTION 204， 再收到 GET 200</p><p><img src="/../img\Snipaste_2019-09-20_21-52-37.png" alt=""></p><p>再说说 credentials 的几个选项的含义</p><blockquote><ol><li><p>same-origin 只想请求URL与调用的脚本处于同一起源处</p></li><li><p>include 为了让浏览器发送包含凭据的请求（即使是跨域源）</p></li><li><p>omit 为了让浏览器发送包含凭据的请求（即使是跨域源）不允许会报 OPTIONS 的错误</p></li></ol></blockquote><h3 id="前端代理"><a href="#前端代理" class="headerlink" title="-  前端代理"></a>-  前端代理</h3><p>proxyTable(开发时候用)</p><p>​     在 vue-cli 搭建的config&gt;index.js 下的 dev 选项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">  <span class="string">'/'</span>: &#123;</span><br><span class="line">    target: <span class="string">'http://testCors.com:9099/'</span>,</span><br><span class="line">    changOrigin: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">fetch(<span class="string">`/testGet?msg=Helllooo`</span>)</span><br><span class="line">.then( <span class="keyword">async</span> res =&gt; &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">await</span> res.text())</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>神奇的事情发生了，后台即使不使用 koa-cors ，也完全不会有跨域的问题，proxyTable的原理，应该是开了个和网页同域的服务器，网页请求跨域服务器时，这个同域的服务器会拦截请求，并且代理发送请求到目标服务器，利用的是服务器之间不存在跨域的原理</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;跨域是什么&quot;&gt;&lt;a href=&quot;#跨域是什么&quot; class=&quot;headerlink&quot; title=&quot;-  跨域是什么&quot;&gt;&lt;/a&gt;-  跨域是什么&lt;/h3&gt;&lt;p&gt;​    &lt;strong&gt;协议，域名，端口，有一个不同即为跨域，跨域是浏览器的一种保护机制&lt;/stron
      
    
    </summary>
    
    
      <category term="跨域" scheme="http://yoursite.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="cookie" scheme="http://yoursite.com/tags/cookie/"/>
    
  </entry>
  
  <entry>
    <title>linux下的mysql</title>
    <link href="http://yoursite.com/2019/09/05/linux%E4%B8%8B%E7%9A%84mysql/"/>
    <id>http://yoursite.com/2019/09/05/linux下的mysql/</id>
    <published>2019-09-05T09:31:00.000Z</published>
    <updated>2019-09-07T12:52:01.087Z</updated>
    
    <content type="html"><![CDATA[<p>云服务器上的mysql一开始是用lnmp一键安装的，当时忘记了mysql的密码，于是在网上找到一些方法跳过密码直接进入mysql，再接着修改密码</p><ol><li>首先进到根目录，然后进入 <strong>etc</strong> 文件夹</li><li>找到mysql配置文件 <strong>my.cnf</strong>，拖到本地</li><li>打开my.cnf，找到[mysqld]，在该行下面添加一行 <strong>skip-grant-tables</strong> （跳过登录时的权限表）</li><li>覆盖服务器上的原配置文件，使用 <strong>service mysql restart</strong>  重启mysql</li><li>然后输入 <strong>mysql -uroot -p</strong> ，遇到输入密码直接回车即可进入mysql </li><li>在命令行 输入 <strong>use mysql</strong> 收到 Database changed 的反馈</li><li>输入 <strong>update user set password = password(‘新的密码’) where user = ‘root’;</strong> (注意分号不能漏)</li></ol><p><img src="/../img/20190905.png" alt=""></p><ol start="8"><li><p>然后输入 <strong>exit</strong> 退出mysql</p></li><li><p>修改本地的 <strong>my.cnf</strong> 文件，把刚刚添加的一行去掉，再覆盖服务器的原配置文件</p></li><li>再次重启服务器即可</li></ol><p>这里再记录几个linux命令</p><ul><li><p>service mysql start  开启mysql</p></li><li><p>service mysql stop   关闭mysql</p></li><li><p>service mysql restart 重启mysql</p></li><li><p>netstat -ntlp   //查看当前所有tcp端口·</p></li><li><p>netstat -an | grep 3306   //查看所有3306端口使用情况</p></li></ul><p><strong>另外在数据库初始化建表的时候遇到了字段长度过长（varchar255）的问题 Specified key was too long; max key length is 767 bytes  百度各种启用innodb_large_prefix 的方法，但没有一个试成功了，只能改字段长度</strong></p><blockquote><p>上面有提到单列索引限制767，起因是256×3-1。这个3是字符最大占用空间（utf8）。但是在5.5以后，开始支持4个字节的uutf8。255×4&gt;767, 于是增加了一个参数叫做 innodb_large_prefix这个参数默认值是OFF。当改为ON时，允许列索引最大达到3072。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;云服务器上的mysql一开始是用lnmp一键安装的，当时忘记了mysql的密码，于是在网上找到一些方法跳过密码直接进入mysql，再接着修改密码&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先进到根目录，然后进入 &lt;strong&gt;etc&lt;/strong&gt; 文件夹&lt;/li&gt;
&lt;li&gt;找到my
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>用ts搭建koa项目</title>
    <link href="http://yoursite.com/2019/07/20/ts+koa%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/07/20/ts+koa项目的搭建/</id>
    <published>2019-07-20T09:31:00.000Z</published>
    <updated>2019-09-07T12:43:39.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><pre><code>这次许愿墙后台是用koa+ts+mysql写的，由于没有自带的koa+ts的项目结构，所以是先建了个koa项目，然后在配置ts文件</code></pre><h2 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h2><p>这是完整的ts配置文件，注意json文件不支持注释</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">      <span class="string">"module"</span>: <span class="string">"commonjs"</span>, <span class="comment">//模块处理是使用commonjs的方式</span></span><br><span class="line">      <span class="string">"target"</span>: <span class="string">"es2017"</span>,   <span class="comment">//使用es7是为了能使用async await</span></span><br><span class="line">      <span class="string">"noImplicitAny"</span>: <span class="literal">false</span>,   </span><br><span class="line">      <span class="string">"moduleResolution"</span>: <span class="string">"node"</span>,</span><br><span class="line">      <span class="string">"sourceMap"</span>: <span class="literal">false</span>,   <span class="comment">//开了的话会生成xxx.map.js文件</span></span><br><span class="line">      <span class="string">"esModuleInterop"</span>: <span class="literal">true</span>,  </span><br><span class="line">      <span class="string">"rootDirs"</span>: [         <span class="comment">//这是关键，这样声明可以实现多个出口，即不同目录结构</span></span><br><span class="line">        <span class="string">"./utils"</span>,          <span class="comment">//的ts文件可以按原目录文件结构编译，而outDir是单出口</span></span><br><span class="line">        <span class="string">"./routes"</span>,         <span class="comment">//的命令，配合rootDirs可以生成一个编译后保持原目录结</span></span><br><span class="line">        <span class="string">"./app.js"</span>          <span class="comment">//构的js目录</span></span><br><span class="line">      ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"include"</span>: [              <span class="comment">//声明需要被编译的文件夹</span></span><br><span class="line">    <span class="string">"./utils"</span>,</span><br><span class="line">    <span class="string">"./routes"</span>,</span><br><span class="line">    <span class="string">"./app.ts"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"exclude"</span>: [              <span class="comment">//声明不需要被编译的文件夹      </span></span><br><span class="line">    <span class="string">"node_modules"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在package.json配置两条命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&quot;dev&quot;: &quot;nodemon --watch routes --watch utils --watch ./ -e ts --exec ts-node bin/www&quot;</span><br></pre></td></tr></table></figure><p>平时开发用，用了nodemon监控routes，utils和根目录文件后缀为ts的修改，一旦触发，就会执行重新编译的命令，重新编译使用的<code>ts-node</code>可保证在不显式生成js文件的情况下，使得ts文件能够正常运行起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;build&quot;: &quot;tsc -w --outDir ./dist --project ./tsconfig.json&quot;</span><br></pre></td></tr></table></figure><p>上线打包测试用，-w是监控，<code>--outDir ./dist</code>表示编译后重定向文件到dist文件夹，<code>--project ./tsconfig.json</code>表示ts编译的时候使用tsconfig.json配置文件的规则，默认其实是不用给也会寻找tsconfig.json的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;这次许愿墙后台是用koa+ts+mysql写的，由于没有自带的koa+ts的项目结构，所以是先建了个koa项
      
    
    </summary>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
      <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>服务器，webpack打包</title>
    <link href="http://yoursite.com/2019/07/19/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8Cwebpack%E6%89%93%E5%8C%85/"/>
    <id>http://yoursite.com/2019/07/19/服务器，webpack打包/</id>
    <published>2019-07-19T13:27:45.000Z</published>
    <updated>2019-07-19T13:29:47.013Z</updated>
    
    <content type="html"><![CDATA[<p><strong>写在前面：</strong></p><p>这算是第一次将完整的项目丢到服务器上去，包括后台服务和前端打包好的文件，下面将记录这次操作遇到的一些情况</p><h2 id="后台部分"><a href="#后台部分" class="headerlink" title="后台部分"></a>后台部分</h2><p>后台项目是用express框架，里面的静态文件在放在public文件夹内，只需把前端代码打包后生成的index.html和static文件夹丢到public文件夹内即可，后台代码放在了<code>/home/wwwroot</code>下</p><h3 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h3><p>用PuTTY命令行工具的时候，会有一个问题，一旦启动了其中一个服务，就无法进行其他操作(比如开启另一个服务)，这样还会导致退出PuTTY的时候，刚开启的服务会自己断开</p><p>为解决这个问题，需要用到Screen工具，一般Linux机都会自带</p><p><strong>这里记录几个常用命令</strong></p><ol><li><code>screen -S name</code>  —&gt; 新建一个名叫name的会话</li><li><code>screen -ls</code>      —&gt; 列出当前所有会话</li><li><code>screen -r name</code>  —&gt; 回到name这个会话，配合-ls命令，name用会话序号代替即可</li><li><code>screen -d name</code>  —&gt; 远程detach某个会话，状态为Attached的会话不能用-r命令进入</li><li><code>C-a + z</code>        —&gt; 把当前会话放到后台执行，用 shell 的 fg 命令则可回去</li><li><code>C-a + c</code>         —&gt; 创建一个新的运行shell的窗口并切换到该窗口</li><li><code>screen -S name -X quit</code> —&gt;关闭某个会话</li></ol><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>安装MongoDB在 <code>/usr/local</code>，在MongoDB文件夹内执行 <code>bin/mongod</code> 即可开启MongoDB</p><h2 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h2><p>前端项目是用vue框架，用Webpcak打包时遇到了很多问题</p><h3 id="assets"><a href="#assets" class="headerlink" title="assets"></a>assets</h3><p>assets里面的文件会根据url-loader的limit分情况处理，vue-cli的limit为10000b，略小于10k</p><ol><li><p>小于url-loader的limit限制的文件会直接变成base64</p><ul><li><code>eg: xxx.png =&gt; data:image/xxx;base64,ixxxxxxx</code></li></ul></li><li><p>大于limit限制的是重新命名一下，不变成base64</p><ul><li><code>eg: xxx.png =&gt; xxx.0974910.png</code></li></ul></li></ol><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>static里面的文件会原封不动的放在打包后的static文件夹里</p><h2 id="图片资源打包情况分析"><a href="#图片资源打包情况分析" class="headerlink" title="图片资源打包情况分析"></a>图片资源打包情况分析</h2><h3 id="npm-run-dev"><a href="#npm-run-dev" class="headerlink" title="npm run dev"></a>npm run dev</h3><p>在开发模式下，讨论两种引用图片资源的情况：</p><ol><li><p>template中通过img标签的src来引用图片资源</p><ul><li><p>通过<code>&quot;../assets/xxx.png&quot;</code>或者<code>&quot;../../static/xxx.png&quot;</code>这两种都是通过相对路径引用也会有两种情况</p><ol><li>小于limit的图片：仍然是base64</li><li>大于limit的图片：<code>/static/img/xxx.0974910.png</code></li></ol></li><li><p>通过<code>/static/xxx.png</code>绝对路径的方式引用图片，是可以被loader识别并且不被webpack打包，即可以保持原文件不变，在img的src中为<code>/static/xxx.png</code></p><p><strong>注意：可以用<code>static/xxx.png</code>(即省略开头的’/‘)来达到上述效果，不过在<code>npm run build</code>后会报错，所以还是不推荐</strong></p></li></ul></li><li><p>style中通过background-img的url来引用图片资源</p><ul><li><p>通过<code>../../static/xxx.png</code>或者<code>../assets/xxx.png</code>这两种相对路径引用也会有两种情况</p><ol><li>小于limit的图片：仍然是base64</li><li>大于limit的图片：<code>/static/img/xxx.0974910.png</code></li></ol></li><li><p>通过<code>/static/xxx.png</code>绝对路径的方式引用图片，是可以被loader识别并且不被webpack打包，即可以保持原文件不变，在img的src中为<code>/static/xxx.png</code></p></li><li><p><strong>注意：不可以用<code>static/xxx.png</code>(即省略开头的/)来达到上述效果</strong></p><p><strong>总结：在 <code>npm run dev</code> 后，如使用到相对路径引用图片资源，就会被webpack打包到<code>/static/img/</code>下，即被webpack处理；若使用绝对路径引用图片资源，webpack会保持原文件不变，放在<code>/static/</code>下</strong></p></li></ul></li></ol><h3 id="npm-run-build"><a href="#npm-run-build" class="headerlink" title="npm run build"></a>npm run build</h3><p>这个模式下，和<code>npm run dev</code>的区别是teplate的img标签的src不能<code>static/xxx.png</code>（即不能省略’/‘)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这算是第一次将完整的项目丢到服务器上去，包括后台服务和前端打包好的文件，下面将记录这次操作遇到的一些情况&lt;/p&gt;
&lt;h2 id=&quot;后台部分&quot;&gt;&lt;a href=&quot;#后台部分&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>WebPack</title>
    <link href="http://yoursite.com/2019/07/11/WebPack/"/>
    <id>http://yoursite.com/2019/07/11/WebPack/</id>
    <published>2019-07-11T05:11:47.000Z</published>
    <updated>2019-07-16T09:01:56.948Z</updated>
    
    <content type="html"><![CDATA[<p>最近学了点webpack，算是入门了，对于webpack的进阶知识没有太多涉猎，对HMR热更新有一点点了解，但没有深入其实现原理，或许未来会去专门深入学习HMR热更新原理</p><p>开始的学习是根据<a href="https://segmentfault.com/a/1190000006178770#articleHeader9" target="_blank" rel="noopener">这篇博客</a>进行搭建的,这篇博客用的webpack版本是3.x，虽然webpack思想没改变，但与现在的webpack4.x版本还是有点区别，自己搭建的时候还是遇到了一些意外的情况</p><ol><li><p>全局安装webpack的时候npm报错</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:<span class="symbol">\前</span>端<span class="symbol">\w</span>ebpack<span class="symbol">\d</span>emo&gt;npm install -g webpack</span><br><span class="line">npm ERR! Maximum call stack size exceeded</span><br></pre></td></tr></table></figure><p>原因是自己的npm版本过低(5.x)，升级npm后再装webpack，问题解决</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:<span class="symbol">\前</span>端<span class="symbol">\w</span>ebpack<span class="symbol">\d</span>emo&gt;npm i npm -g</span><br><span class="line">D:<span class="symbol">\前</span>端<span class="symbol">\w</span>ebpack<span class="symbol">\d</span>emo&gt;npm -v</span><br><span class="line">6.10.0</span><br></pre></td></tr></table></figure></li><li><p>webpack命令行现在需要使用webpack-cli，而且webpack-cli需要全局安装</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">D</span>:\前端\webpack\demo&gt;webpack</span><br><span class="line"><span class="keyword">One</span> <span class="keyword">CLI</span> <span class="keyword">for</span> webpack must be installed. These are recommended choices, delivered <span class="keyword">as</span> <span class="keyword">separate</span> packages:</span><br><span class="line">- webpack-<span class="keyword">cli</span> (https:<span class="comment">//github.com/webpack/webpack-cli)</span></span><br><span class="line">  The original webpack full-featured <span class="keyword">CLI</span>.</span><br><span class="line">We will <span class="keyword">use</span> <span class="string">"npm"</span> to install the <span class="keyword">CLI</span> via <span class="string">"npm install -D"</span>.</span><br><span class="line"><span class="keyword">Do</span> you want to install 'webpack-<span class="keyword">cli</span>' (yes/<span class="keyword">no</span>): <span class="built_in">y</span></span><br><span class="line">Installing 'webpack-<span class="keyword">cli</span>' (running 'npm install -<span class="keyword">D</span> webpack-<span class="keyword">cli</span>')...</span><br></pre></td></tr></table></figure><p>这里下载的webpack-cli不是全局安装，还是会报错，所以需要使用webpack命令行命令前全局安装webpack-cli，至此，意外的情况解决</p></li></ol><h2 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h2><p>下面是webpack配制文件的一些基础又重要的选项，在这里只说明这些选项是干什么的，不是api</p><h4 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h4><p>  <code>devtool: &#39;eval-source-map&#39;</code></p><ol><li>规定打包时候生成的文件的格式，不同值打包速度不同，完整性不同</li><li>在source-map模式，使用babel后，原文件的es6被转成es5在浏览器运行，若不使用devtool，在浏览器看到的js是es5，和自己源码的es6不一样，导致修改麻烦（suorce-map的作用就是在浏览器控制台可以看到原文件出错的地方，而不是经过转译后其他格式的文件）</li><li>在eval模式，在webpack打包生成的文件里面搜索eval，可以看到每个模块的地址</li></ol><h4 id="entry-amp-output"><a href="#entry-amp-output" class="headerlink" title="entry &amp; output"></a>entry &amp; output</h4><ul><li><p>单入口</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">entry:</span> __dirname + <span class="string">"/app/main.js"</span>,</span><br><span class="line"><span class="symbol">output:</span> &#123;</span><br><span class="line"><span class="symbol">  path:</span> __dirname + <span class="string">"/build"</span>,</span><br><span class="line"><span class="symbol">  filename:</span> <span class="string">"bundle.js"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>此时设置的entry为全文唯一入口，output设置打包后的文件名以及存放的地址</p></li><li><p>多入口</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">entry</span>: &#123;</span><br><span class="line">  <span class="attribute">index</span>: __dirname + <span class="string">"/app/index.js"</span>,</span><br><span class="line">  admin: __dirname + <span class="string">"/app/admin.js"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">output</span>: &#123;</span><br><span class="line">  <span class="attribute">path</span>: __dirname + <span class="string">"/build"</span>,</span><br><span class="line">  filename: <span class="string">"[name].min.js"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>多入口需要配置一个JSON对象，这样会编译出两个打包后的文件 index.min.js 和 admin.min.js</p></li></ul><h4 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h4>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mode: <span class="string">'none'</span>, <span class="string">'production'</span>,<span class="string">'development'</span></span><br></pre></td></tr></table></figure><pre><code>none:只打包不压缩production:压缩到极限（默认值）development:保留必要信息，方便调试mode不设置则为默认值，但是会有warn</code></pre><h4 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h4><p>  下载 webpack-dev-server之后，浏览器监听你的代码的修改，并自动刷新显示修改后的结果, This should be used for development only.</p>  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">devServer:</span> &#123;</span><br><span class="line"><span class="symbol">  contentBase:</span> <span class="string">"./public"</span>,<span class="comment">//本地服务器所加载的页面所在的目录</span></span><br><span class="line"><span class="symbol">  historyApiFallback:</span> true,<span class="comment">//如果设置为true，所有的跳转将指向index.html</span></span><br><span class="line"><span class="symbol">  port:</span> <span class="number">4000</span>,</span><br><span class="line"><span class="symbol">  hot:</span> true<span class="comment">//这个是热替换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>热替换HMR和自动刷新（live-reload）的区别</strong></p><p>  热替换可以只替换某个组件，自动刷新就是所有组件一起重置，热替换可以保存组件原来的状态信息，不去重新渲染没有修改的组件</p><h4 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h4><p>  webpack只认识js，只能打包js，所以需要各种loader来把不同的文件变成字符串等webpack可以认识的东西，从而实现把各种各样的文件打包到一起的效果，可以说，没有loader，webpack什么都不是</p><p>  下面介绍接种常见的loader</p><ul><li>css-loader<br>  把css文化变成字符串，让webpack能接受并打包</li><li>style-loader<br>  把打包后的css样式，在head标签内生成style标签</li><li><p>postcss-loader<br>  依赖于autoprefixer，给样式加前缀</p><p>三个loader配合使用写法如下，use的执行顺序为有后向前，这个三个loader的执行顺序不能乱</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">module</span>: &#123;</span><br><span class="line">  <span class="attribute">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.css$/,</span><br><span class="line">      use: [</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">"style-loader"</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          <span class="attribute">loader</span>: <span class="string">"css-loader"</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            modules: true, // 指定启用css modules</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">          <span class="attribute">loader</span>: <span class="string">"postcss-loader"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>file-loader<br>输出成文件，只是改个名（md5规范）</p></li><li><p>url-loader<br>读取并输出成base64 </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">loader</span>: 'url-loader,</span><br><span class="line">    <span class="attribute">options</span>: &#123;</span><br><span class="line">      <span class="attribute">outputPath </span>: <span class="string">'images/'</span>,</span><br><span class="line">      <span class="attribute">limit</span>: <span class="number">8</span>*<span class="number">1024</span> <span class="comment">//小于这个的打包成base64,大于这个的变成文件</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>bable-loader<br>把es6转成es5，避免某些浏览器不能识别es6，其配置信息可以另外写在 .bablerc 文件里，webpack会自动调用.babelrc里的babel配置选项</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>  以上便是这几天入门webpack学到的一些皮毛，虽然学的很浅，不过自己对于工程化的理解加深了不少，对模块化的理解更深了一点，webpack更深层次的东西，希望以后能够有时间有能力去探秘</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近学了点webpack，算是入门了，对于webpack的进阶知识没有太多涉猎，对HMR热更新有一点点了解，但没有深入其实现原理，或许未来会去专门深入学习HMR热更新原理&lt;/p&gt;
&lt;p&gt;开始的学习是根据&lt;a href=&quot;https://segmentfault.com/a/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>微信小程序爬坑笔记2</title>
    <link href="http://yoursite.com/2019/05/31/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9D%82%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/05/31/小程序杂记/</id>
    <published>2019-05-31T09:31:00.000Z</published>
    <updated>2019-07-05T13:59:54.257Z</updated>
    
    <content type="html"><![CDATA[<p>下面是个人做破碎时间微信小程序时碰到的琐碎的坑点(其实是自己太菜)</p><ol><li><p>wx:for<br>当需要两重循环的时候，需要绑定不同的 item 值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;block wx:<span class="keyword">for</span>=<span class="string">"&#123;&#123; days &#125;&#125;"</span> wx:<span class="keyword">for</span>-item=<span class="string">"cardList"</span> wx:key=<span class="string">"key1"</span>&gt;</span><br><span class="line">   &lt;view wx:<span class="keyword">for</span>=<span class="string">"&#123;&#123; cardList &#125;&#125;"</span> wx:<span class="keyword">for</span>-item=<span class="string">"card"</span> wx:key=<span class="string">"key2"</span>&gt;</span><br><span class="line">   &lt;<span class="regexp">/view&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>block&gt;</span><br></pre></td></tr></table></figure></li><li><p>picker 时间选择,不给默认初值,就强行当前时间开始选择(安卓机(小米)是如此,ios 却是从 00:00 开始)</p></li><li><p>textarear 的 placeholder 若想为空,修改其值为 ‘’ 是无效的,要改为 ‘ ‘</p></li><li><p>textarea 的 placeholder 样式穿透问题，placeholder永远在最上面一层显示,只能强行让其消失(改值为空)，貌似所有原生组件都会有在其他引用组件上方的z-index无效的问题( vue 的好像相反？当初用 vant 做日历选择的时候被遮盖)</p></li><li><p>传事件的参数是个对象，不是一个个传，和 vue 的不同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.triggerEvent(<span class="string">'myevent'</span>,&#123;<span class="attr">confirm</span>:<span class="literal">false</span>,<span class="attr">isTapX</span>:<span class="literal">false</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p>图片要放 CDN 上,不然预览不了  </p></li><li><p>真机调试发现用到全局对象时候更新渲染很慢，以后能用缓存的就要用缓存才行,少用慎用 setData ,用缓存</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set/getStrogeSync(<span class="string">''</span>)</span><br></pre></td></tr></table></figure></li><li><p>text-area 的焦点事件响应会很慢,如果不进行延迟,会导致出问题(莫名得到不对的值或者得不到值)</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下面是个人做破碎时间微信小程序时碰到的琐碎的坑点(其实是自己太菜)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;wx:for&lt;br&gt;当需要两重循环的时候，需要绑定不同的 item 值&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序爬坑笔记1</title>
    <link href="http://yoursite.com/2019/05/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://yoursite.com/2019/05/19/微信小程序初体验/</id>
    <published>2019-05-19T09:31:00.000Z</published>
    <updated>2019-07-05T14:00:19.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Page-prototype-setData-Object-data-Function-callback"><a href="#Page-prototype-setData-Object-data-Function-callback" class="headerlink" title="Page.prototype.setData(Object data, Function callback)"></a>Page.prototype.setData(Object data, Function callback)</h2><p>  setData方法是自带的，也是微信小程序开发最常用的方法之一，然而使用这个方法的时候遇到了好几个问题</p><ol><li><p>setData里面键值对左边若存在变量，键值对左边需要用[ ]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ID = e.currentTarget.dataset.id;</span><br><span class="line"><span class="keyword">let</span> val = <span class="string">`cards[<span class="subst">$&#123;ID&#125;</span>].val`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.setData(&#123;</span><br><span class="line">    [val]: ID</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//不存在变量直接用""</span></span><br><span class="line"><span class="keyword">this</span>.setData(&#123;</span><br><span class="line">    <span class="string">"a[0].id"</span>: <span class="number">2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>用this.data对象修改值，并不会影响视图渲染层，只有用setData修改this.data时候能修改视图渲染层</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setData(&#123;</span><br><span class="line">  timeStart:<span class="string">'11:00'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.data.timeStart) <span class="comment">// "11:00",视图修改</span></span><br><span class="line"><span class="keyword">this</span>.data.timeStart = <span class="string">'12:00'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.data.timeStart) <span class="comment">// "12:00"，视图未修改</span></span><br></pre></td></tr></table></figure><p>由此可知setData里面修改的data对象并不是this.data对象，猜测为setData修改了一个直接和视图层挂钩的data对象，同时将this.data对象赋值为视图层的data对象</p></li><li><p>setData里面若存在过多的数据修改，会导致视图渲染层修改失败，但this.data对象值可正常修改</p></li><li><p>setData里面设置的数据，不用在this.data对象预先说明，会直接添加，但这样很不好</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Page-prototype-setData-Object-data-Function-callback&quot;&gt;&lt;a href=&quot;#Page-prototype-setData-Object-data-Function-callback&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS-文件流操作</title>
    <link href="http://yoursite.com/2019/04/09/NodeJS-%E6%96%87%E4%BB%B6%E6%B5%81%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/04/09/NodeJS-文件流操作/</id>
    <published>2019-04-09T03:00:00.000Z</published>
    <updated>2019-04-09T10:51:07.989Z</updated>
    
    <content type="html"><![CDATA[<ol style="background: #bdc3c7;    border-radius: 5px;    color: #2980b9;    font-size: 20px;    font-weight: bold;    cursor: pointer;    padding-top: 10px;    padding-bottom: 10px;    text-decoration:none;    line-height:1;    width:80%;    margin:0 auto;    list-style:none"><br>  <li style="list-decoration:none"><a href="#6-1" style="color: #4682BE;text-decoration:none;margin-left:10px">1. 文件流基本操作</a></li><br>  <li style="list-decoration:none"><a href="#6-2" style="color: #4682BE;text-decoration:none;margin-left:10px">2. 文件压缩</a></li><br>  <li style="list-decoration:none"><a href="#6-3" style="color: #4682BE;text-decoration:none;margin-left:10px">3. 服务器上应用</a></li><br>  <li style="list-decoration:none"><a href="#6-4" style="color: #4682BE;text-decoration:none;margin-left:10px">4. 启动器</a></li><br></ol><h2 id="6-1">文件流基本操作</h2><p>之前的文件操作是用了fs.readFile()和fs.writeFile(),这两种方式需要把所有文件读取或者写入才能执行下一步，这样做是十分耗资源的，所以我们应该用流的形式，读一块写一块，进行文件读写</p><p>还是用到了fs模块，只不过换成了fs.createReadStream()和fs.createWriteStream()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rs = fs.createReadStream(<span class="string">'1.txt'</span>);</span><br><span class="line"><span class="keyword">let</span> ws = fs.createWriteStream(<span class="string">'2.txt'</span>);</span><br><span class="line"></span><br><span class="line">rs.pipe(ws); <span class="comment">// 顺序不能反 rs==&gt;ws</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取操作的error事件重要，需要处理，写入操作也有error事件</span></span><br><span class="line">rs.on(<span class="string">'error'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//写入操作的finish事件才是真正表示文件操作结束</span></span><br><span class="line">ws.on(<span class="string">'finish'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finish'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>流的形式可以处理文本，二进制文件(图片，音视频等)</p><h2 id="6-2">文件压缩</h2><p>文件流操作不止可以读一块写一块，实际上读写流也是可以的，文件的压缩和加密就是把读取到的文件数据直接修改为另外一种形式</p><p>我们需要配合zlib模块创建gzip对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs =<span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rs = fs.createReadStream(<span class="string">'2.txt'</span>);</span><br><span class="line"><span class="keyword">let</span> gzip = zlib.createGzip();</span><br><span class="line"><span class="keyword">let</span> ws = fs.createWriteStream(<span class="string">'2.txt.gz'</span>);</span><br><span class="line"></span><br><span class="line">rs.pipe(gzip).pipe(ws);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'error'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ws.on(<span class="string">'finish'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finish'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="6-3">服务器上应用</h2><p>配合服务器的情况下，req本身就是一种读入流，res本身就是一种写入流</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span><br><span class="line"><span class="keyword">const</span> fs =<span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server =  http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;pathname&#125; = url.parse(req.url,<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">//pathname 会自动带 / 要特别注意,如 /1.txt 会报错没有这个文件</span></span><br><span class="line">  <span class="keyword">let</span> rs = fs.createReadStream(<span class="string">`www<span class="subst">$&#123;pathname&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">let</span> gzip = zlib.createGzip();</span><br><span class="line">  rs.pipe(gzip).pipe(res);</span><br><span class="line"></span><br><span class="line">  rs.on(<span class="string">'error'</span>, err =&gt; &#123;</span><br><span class="line">    res.writeHeader(<span class="number">404</span>);</span><br><span class="line">    res.write(<span class="string">'not found'</span>);</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><p>以上代码，会造成浏览器直接下载文件，因为浏览器不认识gz格式的数据，打开会是一堆乱码</p><p><img src="/../img/fsStream/1.jpg" alt=""></p><p>解决这个问题也很简单，只要加一句</p><p><code>res.setHeader(&#39;content-encoding&#39;, &#39;gzip&#39;);</code></p><p>但如果只是单纯告诉浏览器我要换格式，若请求的是不存在的文件，你发送的’not found’可不是gzip格式，这个时候浏览器也一脸懵逼</p><p>解决这个问题只需要在error事件回调函数中重新修改响应头信息</p><p><code>res.setHeader(&#39;content-encoding&#39;, &#39;&#39;);</code></p><p>为了解决读取文件的错误，最好在最外层就抛出错误，而不是传到一半才发现有问题，我们可以使用fs.stat()</p><p>下面代码是比较合适的一种服务器文件流操作写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server =  http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;pathname&#125; = url.parse(req.url,<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">let</span> fileName = <span class="string">`www<span class="subst">$&#123;pathname&#125;</span>`</span>;</span><br><span class="line">  </span><br><span class="line">  fs.stat(fileName, (err, stat) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">      res.writeHeader(<span class="number">404</span>);</span><br><span class="line">      res.write(<span class="string">'not found'</span>);</span><br><span class="line">      res.end();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      res.setHeader(<span class="string">'content-encoding'</span>,<span class="string">'gzip'</span>);</span><br><span class="line">      <span class="keyword">let</span> gzip = zlib.createGzip();</span><br><span class="line">      <span class="keyword">let</span> rs = fs.createReadStream(fileName);</span><br><span class="line">      rs.on(<span class="string">'error'</span>, err =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;)</span><br><span class="line">      rs.pipe(gzip).pipe(res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><h2 id="6-4">启动器</h2><p>在以往开启服务器的过程中，一旦我们关闭了控制台，服务也就中断了，一旦某次请求出了错误，服务器直接崩溃死机，为了解决这个问题，NodeJS提供了很多启动器插件</p><p>在这里，我们就以forever来介绍</p><p><code>forever start xxx.js</code> 以启动器进行服务<br><code>forever list</code>  查看执行了启动器的服务<br><code>forever restart xxx.js</code>  更新服务器代码并重新开启<br><code>forever stop xxx.js</code>  关闭某个服务<br><code>forever stopall</code>  关闭所有服务<br><code>forever start xxx.js -l path1 -e path2 -a</code><br>-l ==&gt; -log 把控制台输出放到path1<br>-e ==&gt; -error 把错误输出到path2<br>-a ==&gt; 不清除日志</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol style=&quot;background: #bdc3c7;
    border-radius: 5px;
    color: #2980b9;
    font-size: 20px;
    font-weight: bold;
    cursor: pointer;
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS-数据库</title>
    <link href="http://yoursite.com/2019/04/07/NodeJS-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2019/04/07/NodeJS-数据库/</id>
    <published>2019-04-07T02:30:00.000Z</published>
    <updated>2019-04-09T02:18:50.464Z</updated>
    
    <content type="html"><![CDATA[<ol style="background: #bdc3c7;    border-radius: 5px;    color: #2980b9;    font-size: 20px;    font-weight: bold;    cursor: pointer;    padding-top: 10px;    padding-bottom: 10px;    text-decoration:none;    line-height:1;    width:80%;    margin:0;    list-style:none"><br>  <li style="list-decoration:none"><a href="#5-1" style="color: #4682BE;text-decoration:none;margin-left:10px">1. 数据库类型</a></li><br>  <li style="list-decoration:none"><a href="#5-2" style="color: #4682BE;text-decoration:none;margin-left:10px">2. 数据库建表</a></li><br>  <li style="list-decoration:none"><a href="#5-3" style="color: #4682BE;text-decoration:none;margin-left:10px">3. 索引值</a></li><br>  <li style="list-decoration:none"><a href="#5-4" style="color: #4682BE;text-decoration:none;margin-left:10px">4. SQL四大语句</a></li><br>  <li style="list-decoration:none"><a href="#5-5" style="color: #4682BE;text-decoration:none;margin-left:10px">5. mysql模块</a></li><br>  <li style="list-decoration:none"><a href="#5-6" style="color: #4682BE;text-decoration:none;margin-left:10px">6. co-mysql模块</a></li><br></ol><hr><h2 id="5-1">数据库类型</h2><p>数据库可以简单的分为四个类型</p><ol><li><p>文件型<br>文件型数据库的特点就是简单，典型代表为access，SQLite(常用)，多用于app数据的本地存储，为单一用户服务</p></li><li><p>关系型<br>关系型数据库可以处理复杂逻辑，典型代表为MySQL，Oracle</p></li><li><p>分布型<br>分布型数据库把数据库分配到很多个服务器上，提高性能效率，典型代表为mongoDB</p></li><li><p>NoSQL<br>NoSQL不是 NO SQL 的意思，它代表 Not Only SQL ，也就是说NoSQL不只是可以提供常规SQL的服务，可以处理高并发，具有高性能的特点，典型代表为memcache，redis(常用)</p></li></ol><h2 id="5-2">数据库建表</h2><p>数据库有一些常用管理工具，如navicat(付费)，wamp的phpmyadmin，本篇博客我们用phpmyadmin做示例</p><p>首先进入 127.0.0.1/phpmyadmin/ ,进入MySQL操作界面</p><p>然后我们新建数据库20190407，选择编码类型为utf8_general_ci(若要按中文排序，可以用big5_chinese_ci,支持繁体)</p><p><img src="/../img/dbIMG/1.jpg" alt=""></p><p>创建好库后我们创建新表 user_table ，设置字段</p><p><img src="/../img/dbIMG/2.jpg" alt=""></p><p>值得一提的是，字段类型若为短文本可以用 VARCHAR ，若为长文本要用 TEXT ，A.I 表示自增，PRIMARY 是主键，具有限制作用，还可以提高搜索性能(可快速通过主键找到数据)，UNIQUE 表示不重复</p><h2 id="5-3">索引值</h2><br>1. UNIQUE(唯一),表示该字段的值为唯一不可重复<br><br>2. INDEX(索引)，提高查询性能，但相应的会降低其他操作性能，占用一定空间<br><br>3. PRIMARY(主键)，表示UNIQUE(唯一)加INDEX(索引)<br><br>4. FULLTEXT(全文搜索)，多用于文本搜索，搜索引擎常用，相当于多关键字搜索，INDEX(索引)相当于单关键字搜索<br><br><h2 id="5-4">SQL四大语句</h2><ol><li>增: INSERT INTO &lt;表&gt; (字段) VALUES(值,…)<br><code>INSERT INTO user_table (username,password) VALUES(&#39;1bin&#39;,&#39;123456&#39;)</code></li><li>删: DELETE FROM &lt;表&gt; WHERE 条件<br><code>DELETE FROM user_table WHERE ID=1</code></li><li>改: UPDATE &lt;表&gt; SET 字段=新值,… WHERE 条件<br><code>UPDATE user_table SET username=&#39;Crazy&#39;,password=&#39;654321&#39; WHERE ID=2</code></li><li>查: SELECT 字段列表 FROM &lt;表&gt; WHERE 条件 ORDER BY 字段 LIMIT 数据的数量<br><code>SELECT * FROM user_table WHERE ID&lt;5 ORDER BY ID DESC LIMIT 2</code><br>DESC表示降序</li></ol><h2 id="5-5">mysql模块</h2><p>mysql不是系统自带的，需要下载，其常规用法为<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> db = mysql.createConnection(&#123;</span><br><span class="line">  host:<span class="string">'localhost'</span>,</span><br><span class="line">  port:<span class="number">3306</span>,</span><br><span class="line">  user:<span class="string">'root'</span>,</span><br><span class="line">  password:<span class="string">"123456"</span>,</span><br><span class="line">  database:<span class="string">'20190407'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">db.query(<span class="string">`SELECT * FROM user_table`</span>,(err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(data));  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>上面代码为建立一个数据库服务连接，实际上我们需要建立连接池，而不只是一个服务器连接，这个时候我们需要用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db = mysql.createPool(&#123;</span><br><span class="line">    connectionLimit:<span class="number">10</span>, <span class="comment">//10为默认连接最大值</span></span><br><span class="line">    host:<span class="string">'localhost'</span>,</span><br><span class="line">    port:<span class="number">3306</span>,</span><br><span class="line">    user:<span class="string">'root'</span>,</span><br><span class="line">    password:<span class="string">"123456"</span>,</span><br><span class="line">    database:<span class="string">'20190407'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>然而数据库操作是异步处理，mysql模块需要自己写回调，很麻烦</p><h2 id="5-6">co-mysql模块</h2><p>co-mysql模块帮我们封装了mysql的异步操作，其配合http服务的例子如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co-mysql'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> conn = mysql.createPool(&#123;</span><br><span class="line">  connectionLimit:<span class="number">10</span>,</span><br><span class="line">  host:<span class="string">'localhost'</span>,</span><br><span class="line">  port:<span class="number">3306</span>,</span><br><span class="line">  user:<span class="string">'root'</span>,</span><br><span class="line">  password:<span class="string">'123456'</span>,</span><br><span class="line">  database:<span class="string">'20190407'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> db = co(conn);</span><br><span class="line"><span class="keyword">let</span> server = http.createServer(<span class="keyword">async</span> (req,res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="keyword">await</span> db.query(<span class="string">`SELECT * FROM user_table`</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">        res.write(<span class="string">'hi'</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        res.write(<span class="string">'数据库出错'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    res.end();</span><br><span class="line">&#125;).listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><p>加上try捕获错误会更好</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol style=&quot;background: #bdc3c7;
    border-radius: 5px;
    color: #2980b9;
    font-size: 20px;
    font-weight: bold;
    cursor: pointer;
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket</title>
    <link href="http://yoursite.com/2019/04/03/NodeJS-WebSocket/"/>
    <id>http://yoursite.com/2019/04/03/NodeJS-WebSocket/</id>
    <published>2019-04-03T02:00:00.000Z</published>
    <updated>2019-04-03T11:34:37.216Z</updated>
    
    <content type="html"><![CDATA[<p>WebSocket是H5提供的一种协议，它具有高效，双向通信的特点</p><p>说到WebSocket，先提一下http协议，我们都知道通过http协议和服务器完成数据交换需要三次握手，如果想等服务器一有数据就可以返回给客户端，只能通过Ajax轮询的方式进行，这样做的后果是，服务器会每隔一个固定时间就被请求一次，而http请求又是十分低效的(每次请求都要发送‘我是谁’等等数据给服务器，不能只发送真正要发的数据)，这势必会造成服务器资源浪费，要求服务器处理请求速度很快，这显然是不合适的</p><p>那既然重复请求效率低，我们是不是可以建立一次请求不断开呢？是的，我们有个技术叫long poll(长轮询)，它虽然是基于Ajax轮询的，不过采用的是阻塞式通信，也就是说会一直挂在服务器上不断开，这样确实解决了http请求效率低下的问题，不过也大大增加了服务器的负担，这要求服务器有足够多的空间进行挂载，这显然是不合理的</p><p>为了加快和服务器的通信速度，并且实现双向通信，WebSocket应运而生</p><p>WebSocket只会利用http协议和服务器进行第一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输，此后协议升级为WebSocket，http是超文本传输协议，本质上还是字符串传输，而WebSocket是基于二进制传输的，其效率自然大大提高，而WebSocket和长连接有些类似，但它只会占用很少的服务器资源，不会像long poll那样一直暂居服务器上大量资源</p><p>说了那么多，我们回到NodeJS的世界，来用一下WebSocket</p><p>WebSocket是H5出现的，则势必不兼容低版本浏览器，WebSocket连接也势必会有掉线的问题，这些问题都挺麻烦的，不过，有了socket.io库，这些都不是问题，它可以自动重连，可以兼容到IE5，还可以自动数据解析，最最重要的是，它还十分简单方便。</p><p>服务器<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = http.createServer(<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line">server.listen(<span class="number">8080</span>);</span><br><span class="line"><span class="comment">//WebSocket协议需要监听http协议，一旦第一次握手后，便会抢夺服务控制权</span></span><br><span class="line"><span class="keyword">let</span> wsServer = io.listen(server);</span><br><span class="line"></span><br><span class="line">wsServer.on(<span class="string">'connection'</span>, sock =&gt;&#123;</span><br><span class="line">  <span class="comment">//sock.emit('name', 数据);</span></span><br><span class="line">  <span class="comment">//sock.on('name', function(数据)&#123;&#125;);</span></span><br><span class="line">  <span class="comment">//响应浏览器 a事件</span></span><br><span class="line">  sock.on(<span class="string">'a'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a,b,a+b);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//提交 time事件 到浏览器</span></span><br><span class="line">  setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    sock.emit(<span class="string">'time'</span>,<span class="keyword">new</span> <span class="built_in">Date</span>().getTime());</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>浏览器<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//这个socket.io.js文件是服务器的socket.io提供的</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://localhost:8080/socket.io/socket.io.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// ws:// 是WebSocket协议的标识，表明将要把协议升级为ws</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> sock = io.connect(<span class="string">'ws://localhost:8080/'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">//提交 a事件 到服务器</span></span></span><br><span class="line"><span class="javascript">  sock.emit(<span class="string">'a'</span>,<span class="number">12</span>,<span class="number">5</span>);</span></span><br><span class="line"><span class="javascript">  <span class="comment">//响应服务器 time事件 </span></span></span><br><span class="line"><span class="javascript">  sock.on(<span class="string">'time'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">time</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(time);    </span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>原生WebSocket比较难写，设计到很多二进制的操作，缓存问题，在此只列出一下WebSocket是怎么做到协议升级的</p><p>首先WS请求头会比http请求头多出四个东西</p><p>//扩展<br>Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits<br>//把key发送到服务器，看看服务器能不能支持websocket连接<br>Sec-WebSocket-Key: jfnKy0Z2xEaZ0FyWhqWv7A==<br>//声明websocket连接版本<br>Sec-WebSocket-Version: 13<br>//最最重要的是，告诉浏览器，我要协议升级为websocket<br>Upgrade: websocket</p><p>服务器部分,需要用到 net模块<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = net.createServer(<span class="function"><span class="params">sock</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'有人请求连接'</span>);</span><br><span class="line"></span><br><span class="line">  sock.once(<span class="string">'data'</span>, buffer =&gt; &#123;</span><br><span class="line">    <span class="comment">//once表示只执行一次，第一次执行拿到的buffer全部都是请求头数据</span></span><br><span class="line">    <span class="comment">//这里面只需要解析一下请求头，并且返回一个响应头，ws连接就实现了</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).listen(<span class="number">8080</span>)</span><br></pre></td></tr></table></figure></p><p>响应头的result值需要经过一些处理，用到crypto模块进行shal编码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"><span class="comment">// key=&gt;http的请求头里来</span></span><br><span class="line"><span class="comment">// uuid=&gt;'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</span></span><br><span class="line"><span class="comment">// result = base64(shal(key+uuid))</span></span><br><span class="line"><span class="keyword">let</span> hash = crypto.createHash(<span class="string">'shal'</span>);</span><br><span class="line"></span><br><span class="line">hash.update(key+uuid);</span><br><span class="line"><span class="keyword">let</span> result = hash.digest(<span class="string">'base64'</span>);</span><br></pre></td></tr></table></figure><p>最后手写一个响应头发送到浏览器,101状态码表示协议切换，\r\s是http请求的分隔符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sock.write(</span><br><span class="line"><span class="string">`HTTP/1.1 101 Switching Protocols\r\n</span></span><br><span class="line"><span class="string">Upgrade:websocket\r\n</span></span><br><span class="line"><span class="string">Connection:upgrade\r\n</span></span><br><span class="line"><span class="string">Sec-Websocket-Accept:<span class="subst">$&#123;result&#125;</span>\r\n\r\n`</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;WebSocket是H5提供的一种协议，它具有高效，双向通信的特点&lt;/p&gt;
&lt;p&gt;说到WebSocket，先提一下http协议，我们都知道通过http协议和服务器完成数据交换需要三次握手，如果想等服务器一有数据就可以返回给客户端，只能通过Ajax轮询的方式进行，这样做的后果
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
      <category term="WebSocket" scheme="http://yoursite.com/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS-数据通信</title>
    <link href="http://yoursite.com/2019/04/02/NodeJS-%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2019/04/02/NodeJS-数据通信/</id>
    <published>2019-04-02T11:00:00.000Z</published>
    <updated>2019-04-07T02:33:37.578Z</updated>
    
    <content type="html"><![CDATA[<ol style="background: #bdc3c7;    border-radius: 5px;    color: #2980b9;    font-size: 20px;    font-weight: bold;    cursor: pointer;    padding-top: 10px;    padding-bottom: 10px;    text-decoration:none;    line-height:1;    width:80%;    margin:0;    list-style:none"><br>  <li style="list-decoration:none"><a href="#3-1" style="color: #4682BE;text-decoration:none;margin-left:10px">1. Ajax</a></li><br>  <li style="list-decoration:none"><a href="#3-2" style="color: #4682BE;text-decoration:none;margin-left:10px">2. fetch</a></li><br>  <li style="list-decoration:none"><a href="#3-3" style="color: #4682BE;text-decoration:none;margin-left:10px">3. jsonp</a></li><br>  <li style="list-decoration:none"><a href="#3-4" style="color: #4682BE;text-decoration:none;margin-left:10px">4. Ajax2.0</a></li><br></ol><hr><h2 id="3-1">Ajax</h2><p>Ajax是不支持跨域的，我们先看看原生的前端代码怎么写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ajax = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">ajax.open(<span class="string">'GET'</span>,<span class="string">'http://localhost:8080/a'</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//第一个参数为请求方式，第二个为请求域名，第三个true表示为异步操作</span></span><br><span class="line">ajax.send();</span><br><span class="line"><span class="comment">//若是POST请求则把数据写在send里面</span></span><br><span class="line"></span><br><span class="line">ajax.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//0:初始化 1：已连接 2：请求已发送 3：响应头已接收 4：响应体已接收 </span></span><br><span class="line">  <span class="keyword">if</span>(ajax.readState == <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ajax.status &gt;= <span class="number">200</span> &amp;&amp; ajax.status &lt; <span class="number">300</span> || ajax.status == <span class="number">304</span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">      <span class="keyword">let</span> json = <span class="built_in">JSON</span>.Parse(ajax.responseText)</span><br><span class="line">      <span class="built_in">console</span>.log(json);</span><br><span class="line">      <span class="comment">//还有个responseXML</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'fail'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于SOP(同源政策),Ajax把请求给浏览器去提交到服务器，而服务器是一定会返回结果(服务器不出错的情况下)给浏览器的，然而考虑到安全的原因，浏览器可以自己分辨响应回来的数据和发送的请求是不是在同一个域下，如果不是，浏览器会把响应丢弃</p><p>前端无法自己跨域，需要服务器来声明一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">'access-control-allow-origin'</span>,<span class="string">'*'</span>);</span><br></pre></td></tr></table></figure><p>当然，服务器不能一股脑所有请求都允许,req.headers对象里面有个origin属性存有请求的域名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> allowOrigin = &#123;</span><br><span class="line">  <span class="string">'http://localhost'</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="string">'http://a.com'</span>:<span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; origin &#125; = req.headers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(allowOrigin[origin])&#123;</span><br><span class="line">  res.setHeader(<span class="string">'access-control-allow-origin'</span>,<span class="string">'*'</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2">fetch</h2><p>fetch是原生的，设计出来的目的是为了取代Ajax(xhr)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">oImg = <span class="built_in">document</span>.querySelectorAll(<span class="string">'img'</span>)[<span class="number">0</span>];</span><br><span class="line">oVideo = <span class="built_in">document</span>.querySelectorAll(<span class="string">'video'</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> fetch(请求的文件路径);<span class="comment">// 1.请求</span></span><br><span class="line">  <span class="comment">// json文件解析</span></span><br><span class="line">  <span class="keyword">let</span> json = <span class="keyword">await</span> res.json()</span><br><span class="line">  <span class="comment">// 文本文件解析</span></span><br><span class="line">  <span class="keyword">let</span> text = <span class="keyword">await</span> res.text();</span><br><span class="line">  <span class="comment">// 二进制文件解析</span></span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">await</span> res.blob();</span><br><span class="line">  <span class="keyword">let</span> url = URL.createObjectURL(data);</span><br><span class="line"></span><br><span class="line">  oImg.src = url;</span><br><span class="line">  oVideo.src = url;</span><br><span class="line">  <span class="comment">//blob()方法会等待所有数据解析完才返回，所以对于video来说很不友好，一般拿来处理图片</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3">jsonp</h2><p>jsonp在Ajax不能跨域的时候很火，由于安全性，现在已经不流行了</p><p>jsonp本质上是script标签，其实就是引用别人js文件来执行你在前端写的代码</p><p>假设有个别人服务器上的js文件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure></p><p>前端上只需要这样写<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(a+b);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://a.com"</span>&gt;</span><span class="undefined">cript&gt;</span></span><br></pre></td></tr></table></figure></p><p>jsonp的原理配合jQuery可以这样写</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">    url:<span class="string">'https://a.com'</span>,</span></span><br><span class="line"><span class="javascript">    data: <span class="string">''</span>,<span class="comment">//传送过去的数据</span></span></span><br><span class="line"><span class="javascript">    dataType: <span class="string">'jsonp'</span>,</span></span><br><span class="line"><span class="javascript">    jsonp: <span class="string">'add'</span> <span class="comment">//想要触发的回调函数</span></span></span><br><span class="line"><span class="javascript">  &#125;).then(<span class="function">(<span class="params">&#123;s&#125;</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(s);</span></span><br><span class="line"><span class="undefined">  &#125;, res =&gt; &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'fail'</span>);</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-4">Ajax2.0</h2><p>Ajax2.0没有添加很多东西，主要是添加了FormData，它可以把表单数据整个提交</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"form1"</span> <span class="attr">action</span>=<span class="string">"http://localhost:8080/"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    用户：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"user"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"pass"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    文件：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"f1"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> oForm=<span class="built_in">document</span>.querySelector(<span class="string">'#form1'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">oForm.onsubmit=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> formdata=<span class="keyword">new</span> FormData(oForm);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  xhr.open(oForm.method, oForm.action, <span class="literal">true</span>);</span></span><br><span class="line"><span class="undefined">  xhr.send(formdata);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  xhr.onreadystatechange=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(xhr.readyState==<span class="number">4</span>)&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span>(ajax.status &gt;= <span class="number">200</span> &amp;&amp; ajax.status &lt; <span class="number">300</span> || ajax.status == <span class="number">304</span>)&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">'success'</span>);</span></span><br><span class="line"><span class="javascript">      &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">'fail'</span>);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//取消表单默认提交事件</span></span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配合jQuery</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#form1'</span>).on(<span class="string">'submit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> formdata=<span class="keyword">new</span> FormData(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      url: <span class="keyword">this</span>.action,</span><br><span class="line">      type: <span class="keyword">this</span>.method,</span><br><span class="line">      data: formdata,</span><br><span class="line">      processData: <span class="literal">false</span>, <span class="comment">//不让jq自动解析data</span></span><br><span class="line">      contentType: <span class="literal">false</span>  <span class="comment">//不让jq乱改content-type</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">      alert(<span class="string">'success'</span>);</span><br><span class="line">    &#125;, err=&gt;&#123;</span><br><span class="line">      alert(<span class="string">'fail'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//取消表单默认提交事件</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果我们想要自己构建表单，也不是不行，只不过需要手动给formData加东西，比较麻烦</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span></span><br><span class="line">    用户：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"user"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"pass"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    文件：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"f1"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"btn1"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> oBtn=<span class="built_in">document</span>.querySelector(<span class="string">'#btn1'</span>);</span></span><br><span class="line"><span class="javascript">oBtn.onclick=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> formdata=<span class="keyword">new</span> FormData();</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  formdata.append(<span class="string">'username'</span>, <span class="built_in">document</span>.querySelector(<span class="string">'#user'</span>).value);</span></span><br><span class="line"><span class="javascript">  formdata.append(<span class="string">'password'</span>, <span class="built_in">document</span>.querySelector(<span class="string">'#pass'</span>).value);</span></span><br><span class="line"><span class="javascript">  <span class="comment">//添加文件需要加下标，若是多个文件需要加循环</span></span></span><br><span class="line"><span class="javascript">  formdata.append(<span class="string">'f1'</span>, <span class="built_in">document</span>.querySelector(<span class="string">'#f1'</span>).files[<span class="number">0</span>]); </span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">  <span class="comment">//这里不再能用form的属性，需要自己手写</span></span></span><br><span class="line"><span class="javascript">  xhr.open(<span class="string">'post'</span>, <span class="string">'http://localhost:8080/'</span>, <span class="literal">true</span>); </span></span><br><span class="line"><span class="undefined">  xhr.send(formdata);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  xhr.onreadystatechange=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(xhr.readyState==<span class="number">4</span>)&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span>(ajax.status &gt;= <span class="number">200</span> &amp;&amp; ajax.status &lt; <span class="number">300</span> || ajax.status == <span class="number">304</span>)&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">'success'</span>);</span></span><br><span class="line"><span class="javascript">      &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">'fail'</span>);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;;</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol style=&quot;background: #bdc3c7;
    border-radius: 5px;
    color: #2980b9;
    font-size: 20px;
    font-weight: bold;
    cursor: pointer;
      
    
    </summary>
    
    
      <category term="Ajax" scheme="http://yoursite.com/tags/Ajax/"/>
    
      <category term="fetch" scheme="http://yoursite.com/tags/fetch/"/>
    
      <category term="jsonp" scheme="http://yoursite.com/tags/jsonp/"/>
    
      <category term="Ajax2.0" scheme="http://yoursite.com/tags/Ajax2-0/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS-原生篇2</title>
    <link href="http://yoursite.com/2019/03/30/NodeJS-%E5%8E%9F%E7%94%9F%E7%AF%872/"/>
    <id>http://yoursite.com/2019/03/30/NodeJS-原生篇2/</id>
    <published>2019-03-30T04:00:00.000Z</published>
    <updated>2019-04-03T11:38:17.706Z</updated>
    
    <content type="html"><![CDATA[<ol style="background: #bdc3c7;    border-radius: 5px;    color: #2980b9;    font-size: 20px;    font-weight: bold;    cursor: pointer;    padding-top: 10px;    padding-bottom: 10px;    text-decoration:none;    line-height:1;    width:80%;    margin:0;    list-style:none"><br>  <li style="list-decoration:none"><a href="#2-1" style="color: #4682BE;text-decoration:none;margin-left:10px">1. fs模块</a></li><br>  <li><a href="#2-2" style="color: #4682BE;text-decoration:none;margin-left:10px">2. querystring模块</a></li><br>  <li><a href="#2-3" style="color: #4682BE;text-decoration:none;margin-left:10px">3. url模块</a></li><br>  <li><a href="#2-4" style="color: #4682BE;text-decoration:none;margin-left:10px">4. multiparty</a></li><br>  <li><a href="#2-5" style="color: #4682BE;text-decoration:none;margin-left:10px">5. 接口应用</a></li><br></ol><h2 id="2-1">fs模块</h2><p>fs模块可以实现文件的操作，在这里，我们主要了解一下fs的两个方法<br><br><br>1.fs.writeFile(path,data,callback(err))，该方法实现文件内容的写入，其回调函数有个err错误对象参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fs.writeFile('</span>./a.txt, <span class="string">'crazy492 is 1bin'</span>, err =&gt; &#123;</span><br><span class="line"> <span class="keyword">if</span>(err)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'失败'</span>,err);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'成功'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2.fs.readFile(path,callback(err,buffer))，该方法是读取文件，其回调函数不仅有个err错误对象参数，还有个buffer数据(二进制数据)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs);</span></span><br><span class="line"><span class="string">fs.readFile('</span>./a.txt, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'失败'</span>,err);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'成功'</span>,data);</span><br><span class="line">    <span class="comment">//data打印出来是一堆buffer数据</span></span><br><span class="line">    <span class="comment">//若该文件只是一些简单的字符串，可以data.toString()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>fs和http搭配的一种应用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server=http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//req.url 是请求的地址</span></span><br><span class="line">  fs.readFile(req.url, (err, buffer)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">      <span class="comment">//发送状态码给浏览器</span></span><br><span class="line">      res.writeHeader(<span class="number">404</span>);</span><br><span class="line">      res.write(<span class="string">'Not Found'</span>);</span><br><span class="line">      res.end();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      res.writeHeader(<span class="number">200</span>);</span><br><span class="line">      res.write(buffer);</span><br><span class="line">      res.end();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><h2 id="2-2">querystring模块</h2><p>get请求数据在url里面，获取url里面的数据可以用querystring</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring);</span></span><br><span class="line"><span class="string">//假设get请求为 localhost:8080/a?username=1bin&amp;password=123456</span></span><br><span class="line"><span class="string">let [url, query] = req.url.split('</span>?<span class="string">');</span></span><br><span class="line"><span class="string">let get = querystring.parse(query);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">console.log(url, get);</span></span><br><span class="line"><span class="string">//url : /a</span></span><br><span class="line"><span class="string">//get : &#123;uername:'</span><span class="number">1</span>bin<span class="string">',password:'</span><span class="number">123456</span><span class="string">'&#125;</span></span><br></pre></td></tr></table></figure><p>get数据都在url里面，可以一次送达服务器，但对于post请求来说，数据都是分批送达的，此时需要将所有buffer整合为一个整体，post的body部分只有数据，可以用querystring模块解决，另外，利用req自带的两个事件，req.on(‘data’)和req.on(‘end),可以解决buffer分批接收整合的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring=<span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr=[];</span><br><span class="line">req.on(<span class="string">'data'</span>, buffer=&gt;&#123;</span><br><span class="line">  arr.push(buffer);</span><br><span class="line">&#125;);</span><br><span class="line">req.on(<span class="string">'end'</span>, ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">let</span> buffer=Buffer.concat(arr);</span><br><span class="line">  <span class="keyword">let</span> post=querystring.parse(buffer.toString());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(post);</span><br><span class="line">  <span class="comment">//post : &#123;uername:'1bin',password:'123456'&#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-3">url模块</h2><p>url模块比querystring模块更方便解析get数据，只需要url.parse(***,true)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url=<span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;pathname, query&#125;=url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//url.parse()第二个参数是true是会自动解析url</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">console</span>.log(pathname, query);</span><br><span class="line"><span class="comment">//pathname : /a</span></span><br><span class="line"><span class="comment">//query : &#123;uername:'1bin',password:'123456'&#125;</span></span><br></pre></td></tr></table></figure><h2 id="2-4">multiparty模块</h2><br>multiparty可以一同处理post的文件请求和普通请求，如果用原生写post文件请求则特别恶心,multiparty模块不是系统自带，需要下载<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> multiparty = <span class="built_in">require</span>(<span class="string">'multiparty'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> form=<span class="keyword">new</span> multiparty.Form(&#123;</span><br><span class="line">  uploadDir: <span class="string">'./upload'</span> <span class="comment">//上传到的地址</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//若上传账号和密码两个字段加一个1.txt文件</span></span><br><span class="line">form.parse(req);<span class="comment">//解析数据</span></span><br><span class="line"><span class="comment">//普通字段</span></span><br><span class="line">form.on(<span class="string">'field'</span>, (name, value)=&gt;&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'字段：'</span>, name, value);   </span><br><span class="line">  <span class="comment">// 字段： username 1bin</span></span><br><span class="line">  <span class="comment">// 字段： password 123456</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//文件上传</span></span><br><span class="line">form.on(<span class="string">'file'</span>, (name, file)=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'文件：'</span>, name, file);</span><br><span class="line">  <span class="comment">// 文件： f1 &#123; fieldName: 'f1',</span></span><br><span class="line">  <span class="comment">//   originalFilename: '1.txt',</span></span><br><span class="line">  <span class="comment">//   path: 'upload\\T8w1Kiny20fNsWDlVPgaJ9iJ.txt',</span></span><br><span class="line">  <span class="comment">//   headers:</span></span><br><span class="line">  <span class="comment">//    &#123; 'content-disposition': 'form-data; name="f1"; filename="1.txt"',</span></span><br><span class="line">  <span class="comment">//      'content-type': 'text/plain' &#125;,</span></span><br><span class="line">  <span class="comment">//   size: 0 &#125;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//表单解析完成</span></span><br><span class="line">form.on(<span class="string">'close'</span>, ()=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'表单解析完成'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">req.on(<span class="string">'error'</span>, err =&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><br>假设post上传文件，前端表单enctype需要设置为”multipart/form-data”，<br><br><h2 id="2-5">接口应用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> path =<span class="string">''</span> , get =&#123;&#125;, post =&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(req.method == <span class="string">'GET'</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;pathname, query&#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    path = pathname;</span><br><span class="line">    get = query;</span><br><span class="line">    afterGetData()</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(req.method == <span class="string">'POST'</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> arr =[];</span><br><span class="line"></span><br><span class="line">    req.on(<span class="string">'data'</span>, buffer =&gt;&#123;</span><br><span class="line">      arr.push(buffer);</span><br><span class="line">    &#125;);</span><br><span class="line">    req.on(<span class="string">'end'</span>, () =&gt;&#123;</span><br><span class="line">      <span class="keyword">let</span> buffer = Buffer.concat(arr);</span><br><span class="line">      </span><br><span class="line">      post = querystring.parse(buffer.toString());</span><br><span class="line">      path = req.url;</span><br><span class="line">      <span class="comment">//post的url就是地址</span></span><br><span class="line">      afterGetData();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//设置拿到数据后的回调函数，在这里只区分了两个接口/reg和/login，以及文件请求</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">afterGetData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(path == <span class="string">'/reg'</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(path == <span class="string">'/login'</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//www 为默认文件请求文件夹</span></span><br><span class="line">      fs.readFile(<span class="string">`www<span class="subst">$&#123;path&#125;</span>`</span>, (err, buffer) =&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">          res.writeHeader(<span class="number">404</span>);</span><br><span class="line">          res.write(<span class="string">'NOT FOUND'</span>);</span><br><span class="line">          res.end();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          res.write(buffer);</span><br><span class="line">          res.end();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><p>以上用NodeJS原生自带的模块实现了get/post请求以及文件操作，此外有个favicon.ico请求经常出现，此为goole浏览器申请网页图标的请求，而对于post上传文件参考上面的multiparty模块</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol style=&quot;background: #bdc3c7;
    border-radius: 5px;
    color: #2980b9;
    font-size: 20px;
    font-weight: bold;
    cursor: pointer;
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS-原生篇1</title>
    <link href="http://yoursite.com/2019/03/29/NodeJS-%E5%8E%9F%E7%94%9F%E7%AF%871/"/>
    <id>http://yoursite.com/2019/03/29/NodeJS-原生篇1/</id>
    <published>2019-03-29T12:00:00.000Z</published>
    <updated>2019-04-09T02:18:35.042Z</updated>
    
    <content type="html"><![CDATA[<ol style="background: #bdc3c7;    border-radius: 5px;    color: #2980b9;    font-size: 20px;    font-weight: bold;    cursor: pointer;    padding-top: 10px;    padding-bottom: 10px;    text-decoration:none;    line-height:1;    width:80%;    margin:0;    list-style:none"><br>  <li style="list-decoration:none"><a href="#1-1" style="color: #4682BE;text-decoration:none;margin-left:10px">1. assert模块</a></li><br>  <li style="list-decoration:none"><a href="#1-2" style="color: #4682BE;text-decoration:none;margin-left:10px">2. path模块</a></li><br>  <li style="list-decoration:none"><a href="#1-3" style="color: #4682BE;text-decoration:none;margin-left:10px">3. url模块</a></li><br>  <li style="list-decoration:none"><a href="#1-4" style="color: #4682BE;text-decoration:none;margin-left:10px">4. querystring模块</a></li><br>  <li style="list-decoration:none"><a href="#1-5" style="color: #4682BE;text-decoration:none;margin-left:10px">5. net模块</a></li><br>  <li style="list-decoration:none"><a href="#1-6" style="color: #4682BE;text-decoration:none;margin-left:10px">6. http模块</a></li><br></ol><p>  学习NodeJS，其实是学习一些服务器，数据库知识，以及一些模块(中间件)调用的方法，本文就先从NodeJS的一些常用系统自带模块讲起</p><hr><h2 id="1-1">assert模块</h2><p>断言，在函数调用前使用，可确保参数如预期</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</span><br><span class="line"></span><br><span class="line">assert(<span class="number">1</span>&gt;<span class="number">2</span>,<span class="string">'no!'</span>); <span class="comment">// no！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//assert.deepEqual(变量，预期值，msg);</span></span><br><span class="line"><span class="comment">//相当于 ==</span></span><br><span class="line"><span class="comment">//assert.deepStrictEqual(变量，预期值，msg);</span></span><br><span class="line"><span class="comment">//相当于 ===</span></span><br></pre></td></tr></table></figure><h2 id="1-2">path模块</h2><p>路径，帮助我们做路径拼装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path =<span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'/root/a/b/c/1.html'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(path.dirname(str)); <span class="comment">//  /root/a/b/c</span></span><br><span class="line"><span class="built_in">console</span>.log(path.extname(str)); <span class="comment">//  .html</span></span><br><span class="line"><span class="built_in">console</span>.log(path.basename(str)); <span class="comment">//  1.html</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(__dirname,<span class="string">'1.txt'</span>));</span><br><span class="line"><span class="comment">//path.resolve()是做路径拼接处理的， __dirname是魔术变量，值为当前文件绝对路径</span></span><br></pre></td></tr></table></figure><h2 id="1-3">url模块</h2><p>url的解析和拼接<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str=<span class="string">'http://www.1bin.com:8080/a/b/1.html?a=1&amp;a=2&amp;a=3'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(url.parse(str));</span><br><span class="line"><span class="comment">// Url &#123;  protocol: 'http:',</span></span><br><span class="line"><span class="comment">// slashes: true,</span></span><br><span class="line"><span class="comment">// auth: null,</span></span><br><span class="line"><span class="comment">// host: 'www.1bin.com:8080',</span></span><br><span class="line"><span class="comment">// port: '8080',</span></span><br><span class="line"><span class="comment">// hostname: 'www.1bin.com',</span></span><br><span class="line"><span class="comment">// hash: null,</span></span><br><span class="line"><span class="comment">// search: '?a=1&amp;a=2&amp;a=3',</span></span><br><span class="line"><span class="comment">// query: 'a=1&amp;a=2&amp;a=3',</span></span><br><span class="line"><span class="comment">// pathname: '/a/b/1.html',</span></span><br><span class="line"><span class="comment">// path: '/a/b/1.html?a=1&amp;a=2&amp;a=3',</span></span><br><span class="line"><span class="comment">// href: 'http://www.bing.com:8080/a/b/1.html?a=1&amp;a=2&amp;a=3' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(url.parse(str, <span class="literal">true</span>));</span><br><span class="line"><span class="comment">//加了true后会自动帮你把query解析成&#123; a: [ '1', '2', '3' ] &#125;</span></span><br><span class="line"><span class="comment">//这里a为数组的原因是url解析会帮你把重复变量整合成一个数组</span></span><br></pre></td></tr></table></figure></p><h2 id="1-4">querystring模块</h2><p>数据解析<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//parse stringify 就是数据解析与反向操作</span></span><br><span class="line"><span class="built_in">console</span>.log(querystring.parse(<span class="string">"a=1&amp;b=2&amp;c=3"</span>));</span><br><span class="line"><span class="comment">// &#123; a: '1', b: '2', c: '3' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(querystring.stringify(&#123;<span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">1</span>&#125;));</span><br><span class="line"><span class="comment">// a=3&amp;b=2&amp;c=1</span></span><br></pre></td></tr></table></figure></p><h2 id="1-5">net模块</h2><p>相当于tcp协议node的实现，是http模块的超集，应用于websocket，此处暂且不谈</p><h2 id="1-6">http模块</h2><p>  http模块是实现原生NodeJS服务器链接的一个模块，主要使用方式为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'request:'</span>,req);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'response:'</span>,res);</span><br><span class="line">&#125;).listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><p>  上面的代码，实现了在本机8080端口创立服务器的功能，其中createServer方法有两个参数req，res</p><p>  把这两个参数打印出来，会发现是一个有一大堆属性的对象，在这里，我们看看一些比较重要的属性方法</p><ul><li>res.write()可以把字符串或者buffer(不能发json,可用JSON.stringify())发给服务器</li><li>res.end()是结束此次与服务器的请求，值得一提的是，write后必须要end，否则浏览器不会断开请求链接，你将接受不到服务器的响应，在浏览器界面上显示为左上角刷新圈圈一直在转。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol style=&quot;background: #bdc3c7;
    border-radius: 5px;
    color: #2980b9;
    font-size: 20px;
    font-weight: bold;
    cursor: pointer;
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>事件循环</title>
    <link href="http://yoursite.com/2018/11/10/Event%20Loop/"/>
    <id>http://yoursite.com/2018/11/10/Event Loop/</id>
    <published>2018-11-10T03:30:00.000Z</published>
    <updated>2018-11-10T08:11:30.689Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  从 JavaScript 诞生以来，JavaScript 就被设计为<strong>单线程</strong>且<strong>永不阻塞</strong>的脚本语言。</p><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>  JavaScript 代码在任何时候都只有一个主线程处理所有的任务。</p><p>  设计为单线程的原因主要是 JavaScript 是与浏览器交互的语言，需要完成一些 DOM 操作。若将 JavaScript 设计为多线程，则可能发生下面这种情况：</p><p>  第一个线程创造了 DOM 结点，并进行了相应的 DOM 操作。<br>  第二个线程删除了该 DOM 结点。<br>  此时就遇到问题了，该 DOM 结点该如何存在？毁灭还是新生？</p><p>  因此 JavaScript 要设计成单线程。</p><p>  可是，单线程注定会限制 JavaScript 的效率，因此开发了 <strong>Web Worker</strong> 技术，该技术号称能将 JavaScript 变为多线程的语言。</p><p>  然而，该技术所开发的多线程有很多限制，例如所有新线程必须在主线程的完全控制下，不能独立执行，对于 I/O 操作，新线程更是没有这个权限进行。严格来说，<strong>Web Worker</strong> 技术并没有改变 JavaScript 是单线程的语言的实质。可以预见，JavaScript 在未来也只能是单线程的。</p><h2 id="永不阻塞"><a href="#永不阻塞" class="headerlink" title="永不阻塞"></a>永不阻塞</h2><p>  当代码中有异步任务(无法立刻返回结果的任务，如 I/O 事件),主线程可以暂时挂起该任务,然后在异步任务返回结果后再执行相应回调函数。</p><hr><h1 id="任务队列-task-queue"><a href="#任务队列-task-queue" class="headerlink" title="任务队列(task queue)"></a>任务队列(task queue)</h1><p>单线程的 JavaScript 意味着任务需要一个个来实现，若前一个任务耗时很长，后面的任务就不得不等待。</p><p>于是乎，JavaScript 的设计者意识到，如果将 I/O 操作等耗时长的任务先挂起，先运行后面的任务，等 I/O 操作等耗时长的任务返回了结果，再回头把挂起的任务完成，岂不美哉？</p><p>因此，所有任务可以分为两种，一是<strong>同步任务</strong>，另一种是<strong>异步任务</strong>。</p><p><strong>同步任务</strong>指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。</p><p><strong>异步任务</strong>指的是，不进入主线程、而进入<strong>任务队列</strong>的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p><p>异步任务必须指定<strong>回调函数</strong>，所谓回调函数，就是会被主线程挂起来的那些代码。所谓执行异步任务。就是执行其对应的回调函数。</p><p>任务队列是个 FIFO 的数据结构，一旦主线程的任务栈中所有同步任务执行完成，任务队列中的第一个任务就会被添加到主线程。</p><hr><h1 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环(Event Loop)"></a>事件循环(Event Loop)</h1><p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop。</p><p>加入到任务队列的异步任务其实分为两种，一是宏任务，二是微任务。</p><h2 id="宏任务-macro-task-amp-微任务-micro-task"><a href="#宏任务-macro-task-amp-微任务-micro-task" class="headerlink" title="宏任务(macro task) &amp; 微任务(micro task)"></a>宏任务(macro task) &amp; 微任务(micro task)</h2><p>异步任务也有优先级，微任务高于宏任务。</p><p>以下事件属于宏任务：</p><ul><li>setTimeout()</li><li>setInterval()</li></ul><p>以下事件属于微任务：</p><ul><li>new Promise()</li></ul><p>当主线程任务栈为空时，主线程会先处理微任务队列，当微任务队列也为空时，主线程再去处理宏任务队列。</p><p>而 setTimeout 第二个延迟参数的意义，是指主线程所有同步任务，以及微任务队列所有异步任务都完成后，再生效的延迟时间。</p><p>最后附上一道题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>按照上面的理解，setTimeout 就是作为宏任务来存在的，而 Promise.then 则是具有代表性的微任务，上述代码的执行顺序就是按照序号来输出的。</p><p>就是说 new Promise 在实例化的过程中所执行的代码都是同步进行的，而then中注册的回调才是异步执行的。回调函数，才能进入异步。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;  从 JavaScript 诞生以来，JavaScript 就被设计为&lt;strong&gt;单线程&lt;/strong&gt;且&lt;strong&gt;
      
    
    </summary>
    
    
      <category term="事件循环" scheme="http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    
      <category term="任务队列" scheme="http://yoursite.com/tags/%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
    
      <category term="宏任务与微任务" scheme="http://yoursite.com/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Vue-router</title>
    <link href="http://yoursite.com/2018/11/08/vue-router/"/>
    <id>http://yoursite.com/2018/11/08/vue-router/</id>
    <published>2018-11-08T11:00:00.000Z</published>
    <updated>2018-11-10T02:03:21.116Z</updated>
    
    <content type="html"><![CDATA[<hr><p>Vue 路由用于网页跳转，相较于 a 标签，路由的优势在于不用网页刷新，不用重新进行网页请求，便可以实现组件间的跳转，从而达到网页无刷新跳转的效果。</p><hr><h1 id="安装-vue-router-模块"><a href="#安装-vue-router-模块" class="headerlink" title="安装 vue-router 模块"></a>安装 vue-router 模块</h1><p>首先默认已经自行安装配置好基本的Vue的webpack打包工具<br>可以在 package.json 文件里面的 dependencies （或 devDependencies） 查看 vue-router 是否安装好，以及安装的版本。</p><p>若无安装可在终端内输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router --save</span><br></pre></td></tr></table></figure></p><p><strong>tips：简单区别 –save 和 –save-dev</strong></p><p> –save ：将依赖的模块添加到 dependencies 下，这是项目在发布后需要依赖的模块。<br> –save-dev : 将依赖的模块添加到 devDependencies 下，这是项目在开发过程中才需要依赖的模块。</p><hr><h1 id="实例化-VueRouter-对象"><a href="#实例化-VueRouter-对象" class="headerlink" title="实例化 VueRouter 对象"></a>实例化 VueRouter 对象</h1><p>在 main.js 下,首先引入并使用路由模块。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure></p><p>接着便是实例化 VueRouter 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes:[</span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">"/"</span>,<span class="attr">component</span>:Home&#125;,  <span class="comment">// 默认的首页</span></span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">"/helloworld"</span>,<span class="attr">component</span>:HelloWorld&#125;,</span><br><span class="line">  ],</span><br><span class="line">  mode:<span class="string">"history"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>routes 是路由数组，基本的数组成员就是有 path 和 component 两种属性的对象。值得注意的是，这里需要 import Home 和 HelloWorld 的模板</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">'./components/HelloWorld'</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./components/Home'</span></span><br></pre></td></tr></table></figure><p>mode:”history” 可将 # 号省略掉，避免造成路径的混乱.</p><p>最后在 Vue 实例对象内使用 router。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router, <span class="comment">//需要在 Vue 实例中使用 router</span></span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><hr><h1 id="使用-router-view-，router-link"><a href="#使用-router-view-，router-link" class="headerlink" title="使用 router-view ，router-link"></a>使用 router-view ，router-link</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/helloworld"</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>router-view 相当于 routers 容器，所有路由跳转的现实都在这个标签内。</p><p>router-link 相当于 a 标签的作用 ，to 后面写相对应路由。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;Vue 路由用于网页跳转，相较于 a 标签，路由的优势在于不用网页刷新，不用重新进行网页请求，便可以实现组件间的跳转，从而达到网页无刷新跳转的效果。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;安装-vue-router-模块&quot;&gt;&lt;a href=&quot;#安装-vue-route
      
    
    </summary>
    
    
      <category term="Vue-router" scheme="http://yoursite.com/tags/Vue-router/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="http://yoursite.com/2018/10/27/%E5%BC%82%E6%AD%A5Promise/"/>
    <id>http://yoursite.com/2018/10/27/异步Promise/</id>
    <published>2018-10-27T04:00:00.000Z</published>
    <updated>2018-10-28T13:34:26.589Z</updated>
    
    <content type="html"><![CDATA[<hr><p>  ES6提供了Promise对象，用来实现异步编程。</p><p>  传统的异步编程解决方案是<strong>回调函数和事件</strong>，通过不断嵌套回调函数实现逻辑上的异步，而这样的写法无疑是很复杂的，代码也很难维护。</p><hr><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><p>  一个 Promise 有以下几种状态：</p><p>  (1) pending：初始状态，既不是成功，也不是失败状态。</p><p>  (2) fulfilled：意味着操作成功完成。</p><p>  (3) rejected：意味着操作失败。</p><p>  Promise 对象的 then 方法包含两个参数：</p><p>  onfulfilled 和 onrejected，它们都是 Function 类型</p><p>  Promise 对象的参数函数是两个由 JavaScript 引擎提供的函数 resolve 和 reject</p><p>  resolve 和 reject 函数被调用时，分别将 Promise 的状态改为 fulfilled（完成）或 rejected（失败）</p><p>  当 Promise 状态为 fulfilled 时，调用 then 的 onfulfilled方法，当 Promise 状态为 rejected 时，调用 then 的 onrejected 方法</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...一些立即执行的代码</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="comment">/*异步操作成功*/</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//success code resolve</span></span><br><span class="line">&#125;,err =&gt; &#123;</span><br><span class="line">  <span class="comment">// failure code reject</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>  ES6 规定，Promise 对象是一个构造函数，用来生成Promise 实例。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>); <span class="comment">//立即执行</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> resolve(<span class="string">'resolve'</span>);</span><br><span class="line">     &#125;,<span class="number">1000</span>)</span><br><span class="line">  &#125;); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">  promise().then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hey'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Console</span></span><br><span class="line"><span class="comment">  promise</span></span><br><span class="line"><span class="comment">  Hey</span></span><br><span class="line"><span class="comment">  resolve</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>  Promise 新建后就会立即执行，故先输出 promise</p><p>  then 方法指定的回调函数，就在当前所有同步任务执行完才会执行，所以最后输出 resolve</p><hr><h1 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h1><p>  then 方法的第一个参数是 resolved 状态的回调函数，第二个参数（可选）是 rejected 状态的回调函数</p><p>  then 方法返回的是一个新的 Promise 实例（注意，不是原来那个 Promise 实例）。因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> resolve(<span class="number">2</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">promise()</span><br><span class="line">.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> val; </span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    val++;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Console</span></span><br><span class="line"><span class="comment">  1</span></span><br><span class="line"><span class="comment">  2</span></span><br><span class="line"><span class="comment">  3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>  在 then 方法中的返回值作为参数，传入下一个回调函数。</p><p>  如果 then 回调函数返回一个值，那么 then 返回的 Promise 对象将会成为接受状态，并接受该值作为接受状态的回调函数的参数值。</p><p>  同理 then 回调函数抛出一个错误，那么 then 返回的Promise 对象将成为接受状态，并且将抛出的错误作为拒绝状态的回调函数的参数值。</p><hr><h1 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h1><p>  catch 方法返回一个Promise，并且处理拒绝的情况。</p><p>  它的行为与调用Promise.prototype.then(undefined, onRejected) 相同。</p><p>  Promise 对象的状态一旦变为 rejected ，便不可以再改变，此时便会调用 catch 方法指定的回调函数，此外， then 方法指定的回调函数若在运行中抛出错误，也会被 catch 方法捕获</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/*success*/</span>)&#123;</span><br><span class="line">      resolve(<span class="string">'success'</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      reject(<span class="string">'error'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">promise()</span><br><span class="line">.then( <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//success</span></span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/*error*/</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>  Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。</p><p>  Promise 对象抛出的错误不会传递到外层代码，故要使用 catch 方法来捕获 Promise 对象内部抛出的错误。</p><hr><h1 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h1><p>  finally 方法返回一个 Promise，在执行 then 和catch 后，都会执行finally指定的回调函数。</p><p>  实际上，finally 与 .then(onFinally, onFinally) 类似，但也有一些区别。</p><p>  finally 不接受任何参数。并且 finally 方法总是会返回原来的值。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// resolve 的值是 undefined</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">2</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, () =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve 的值是 2</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">2</span>).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject 的值是 undefined</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">3</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, () =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject 的值是 3</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">3</span>).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><hr><h1 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h1><p>  将现有对象转为 Promise 对象</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//等价为</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>  其参数有四种情况：</p><p>  (1) 不带任何参数</p><p>  直接返回一个 resolved 状态的 Promise 对象</p><p>  (2) 参数不为对象，或者是不具有 then 方法的对象</p><p>  返回一个新的状态为 resolved 的 Promise 对象，此时会立即执行回调函数。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val) ;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//会立刻弹出 1</span></span><br></pre></td></tr></table></figure><p>  (3) 参数是一个thenable对象</p><p>  thenable 对象指的是具有 then 方法的对象，Promise.resolve 方法会将这个对象转为 Promise 对象，然后就立即执行 thenable 对象的 then 方法。</p><p>  (4) 参数是一个 Promise 实例</p><p>  不做任何修改，原封不动的返回这个实例。</p><hr><h1 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h1><p>  Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。</p><p>  该方法和 Promise.resolve 方法类似，但 Promise.reject() 方法的参数，会原封不动的作为reject 的理由，变为后续方法的参数。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">  then(resolve,reject)&#123;</span><br><span class="line">    reject(<span class="string">'error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject(thenable)</span><br><span class="line">.catch( <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err === thenable); <span class="comment">// true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>  上面代码中，Promise.reject 方法的参数是一个 thenable 对象，执行以后，后面 catch 方法的参数不是 reject 抛出的 ‘error’ 这个字符串，而是 thenable 对象</p><hr><h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h1><p>  Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><p>  Promise.all 方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="number">2</span>; <span class="comment">//Promise.all 里面将调用 Promise.resolve</span></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve(<span class="number">3</span>), <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p = [p1, p2, p3];</span><br><span class="line"><span class="built_in">Promise</span>.all(p)</span><br><span class="line">.then(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*Console</span></span><br><span class="line"><span class="comment">  [1,2,3]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>  上面代码中，p的状态有两种情况：</p><p>  (1) 只有p1、p2、p3 的状态都变成 fulfilled，p的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给p的回调函数。</p><p>  (2) 只要p1、p2、p3之中有一个被 rejected，p的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给p的回调函数。</p><p>  如果作为参数的 Promise 实例，自己定义了 catch 方法，那么它一旦被 rejected，并不会触发 Promise.all() 的 catch 方法。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">'p1 error!'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'p2 error!'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p2 catch '</span> + err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1,p2])</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'all catch '</span> + err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Console</span></span><br><span class="line"><span class="comment">p2 catch Error: p2 error!</span></span><br><span class="line"><span class="comment">all catch p1 error!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h1><p>  Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [p1, p2, p3] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1,p2,p3]);</span><br></pre></td></tr></table></figure><p>  上面代码中，只要 p1, p2, p3 之中有一个实例率先改变状态， p的状态就跟着改变，并将率先改变的 Promise 实例作为返回值， 传递给p的回调函数。</p><p>  同样，若参数不是 Promise 实例，则将先调用 Promise.resolve 方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;  ES6提供了Promise对象，用来实现异步编程。&lt;/p&gt;
&lt;p&gt;  传统的异步编程解决方案是&lt;strong&gt;回调函数和事件&lt;/strong&gt;，通过不断嵌套回调函数实现逻辑上的异步，而这样的写法无疑是很复杂的，代码也很难维护。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=
      
    
    </summary>
    
    
      <category term="Promise" scheme="http://yoursite.com/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>解构赋值</title>
    <link href="http://yoursite.com/2018/10/13/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>http://yoursite.com/2018/10/13/解构赋值/</id>
    <published>2018-10-13T11:33:43.000Z</published>
    <updated>2018-10-13T15:50:58.589Z</updated>
    
    <content type="html"><![CDATA[<div style="background-color:#bdc3c7; width:100%;padding:10px 20px ;margin:0 auto;color:white"><br>    <a style="color:white ;display:block;text-decoration:none;border:none" href="#1">1. 数组的解构赋值</a><br>    <a style="color:white;display:block;text-decoration:none;border:none" href="#2">2. 对象的解构赋值</a><br>    <a style="color:white;display:block;text-decoration:none;border:none" href="#3">3. 字符串的解构赋值</a><br>    <a style="color:white;display:block;text-decoration:none;border:none" href="#4">4. 数值和布尔值的解构赋值</a><br>    <a style="color:white;display:block;text-decoration:none;border:none" href="#5">5. 函数参数的解构赋值</a><br>    <a style="color:white;display:block;text-decoration:none;border:none" href="#6">6. 圆括号问题</a><br>    <a style="color:white;display:block;text-decoration:none;border:none" href="#7">7. 用途</a><br></div><div style="width:100%;height:2px;background-color:black;margin:10px 0;"></div><p>本文参考网址:<a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/destructuring</a></p><h1 id="1">1. 数组的解构赋值</h1><h2 id="1.1">1.1 基本用法</h2><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构</p><p>ES6之前，为了给变量赋值，只能直接指定值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> c = &#123;<span class="attr">foo</span>:<span class="number">1</span>,<span class="attr">bar</span>:<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><p>而在ES6中，则允许这样赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, [<span class="number">1</span>,<span class="number">2</span>], &#123;<span class="attr">foo</span>:<span class="number">1</span>,<span class="attr">bar</span>:<span class="number">2</span>&#125; ] ;</span><br></pre></td></tr></table></figure><p>上面代码很清晰的展示了所谓的解构赋值，就是按照相对应的位置，对变量赋值</p><p>实际上，这种赋值方式属于模式匹配，当等号两边的模式相同时，左边的变量便会被赋值为相对应的值</p><p>下面附上一些数组的解构赋值例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, , c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">c <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, , <span class="number">3</span>]; </span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// undefined</span></span><br><span class="line">c <span class="comment">// 3  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]]; </span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">c <span class="comment">// 3 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊的解构符号 '...'</span></span><br><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] ;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// [2,3,4]</span></span><br></pre></td></tr></table></figure><p>如果解构不成功，变量的值为<i>undefined</i></p><p>下面附上一些数组的解构赋值不完全(部分变量解构不成功)的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a] = [];</span><br><span class="line">a <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, b] = [<span class="number">1</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊的解构符号 '...'</span></span><br><span class="line"><span class="keyword">let</span> [a, b, ...c] = [<span class="number">1</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// undefined</span></span><br><span class="line">c <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>当然，不完全解构，也还有另外一种情况，那就是等号左边的模式，只匹配一部分的等号右边的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, b, [c]] = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">c <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果等号右边不是数组(或者说时不可以遍历的解构)，则会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下代码会报错</span></span><br><span class="line"><span class="keyword">let</span> [a] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> [a] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> [a] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> [a] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [a] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> [a] = &#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="1.2">1.2 默认值</h2><p>解构赋值允许为变量指定默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>] = [] ;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, b = <span class="number">2</span>] = [<span class="number">1</span>]</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">&lt;!-- 上面代码等效于下面代码 --&gt;</span><br><span class="line"><span class="keyword">let</span> [a, b = <span class="number">2</span>] = [<span class="number">1</span>, <span class="literal">undefined</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>ES6内部使用全等符号 ‘===’ 判断一个位置是否有值。故，只有一个数组成员严格等于undefined时，默认值才会生效</p><p>默认值也可以为表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [ a = f() ] = [];</span><br><span class="line">a <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>默认值可以引用解构赋值的其他变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b = a] = [];     <span class="comment">// a=1; b=1</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b = a] = [<span class="number">2</span>];    <span class="comment">// a=2; b=2</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b = a] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// a=1; b=2</span></span><br><span class="line"><span class="keyword">let</span> [a = b, b = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError: b is not defined</span></span><br><span class="line"><span class="comment">//报错原因是a用b做默认值时，b还没有声明</span></span><br></pre></td></tr></table></figure><p>再次强调，默认值只有当数组成员严格等于undefined时，才会调用</p><h1 id="2">对象的解构赋值</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b&#125; = &#123;<span class="attr">a</span>: <span class="number">1</span> , <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>对象的解构与数组有一个重要的不同</p><p>数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;b, a&#125; = &#123;<span class="attr">a</span>:<span class="number">1</span> ,<span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br><span class="line">a <span class="comment">// 1 </span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;c&#125; = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br><span class="line">c <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如变量名与属性名不一致，则必须写成下面这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span> : a&#125; = &#123;<span class="attr">foo</span> : <span class="number">1</span>, <span class="attr">a</span>:<span class="number">2</span>&#125;;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">foo <span class="comment">// foo is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">first</span> : a, <span class="attr">last</span> : b&#125; = &#123; <span class="attr">first</span> : <span class="number">1</span>, <span class="attr">last</span> : <span class="number">2</span>&#125;;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>实际上，对象的解构赋值是下面形式的简写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>:a, <span class="attr">b</span>:b&#125; = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><p>也就是说，对象的解构赋值内部机制，是先找到同名属性，再给赋值给相对应的变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span> : a&#125; = &#123;<span class="attr">foo</span> : <span class="number">1</span>, <span class="attr">a</span>:<span class="number">2</span>&#125;;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">foo <span class="comment">// foo is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，foo是匹配的模式，a才是变量</p><p>再举一个解构用于嵌套结构的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    p: [</span><br><span class="line">        <span class="string">'Hello'</span>,</span><br><span class="line">        &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// "Hello"</span></span><br><span class="line">y <span class="comment">// "World"</span></span><br></pre></td></tr></table></figure><p>这里的p是模式，不是变量。若需要将p作为变量赋值，可以写成下面这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; p, <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// "Hello"</span></span><br><span class="line">y <span class="comment">// "World"</span></span><br><span class="line">p <span class="comment">// ["Hello", &#123;y: "World"&#125;]</span></span><br></pre></td></tr></table></figure><p>同样，对象的解构也可以指定默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;</span><br><span class="line">y <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>默认值生效的条件，是对象的属性值严格等于<i>undefined</i></p><p>如果解构失败，变量的值等于undefined</p><p>如果要将已经声明的变量用于解构赋值，必须非常小心</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure><p>上面代码的写法之所以会报错，是因为JavaScript引擎会将{x}理解为一个代码块，从而发生语法错误</p><p>故不能将大括号写在行首,我们可以加一个圆括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><h1 id="3">3. 字符串的解构赋值</h1><p><br>字符串也可以解构赋值。因为此时，字符串被转换成了一个类似数组的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'Hello'</span>;</span><br><span class="line">a <span class="comment">// 'H'</span></span><br><span class="line">b <span class="comment">// 'e'</span></span><br><span class="line">c <span class="comment">// 'l'</span></span><br><span class="line">d <span class="comment">// 'l'</span></span><br><span class="line">e <span class="comment">// 'o'</span></span><br></pre></td></tr></table></figure><p>类似数组对象的<i>length</i>属性,可以对字符串的这个属性解构赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span>: len&#125; = <span class="string">'Hello'</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h1 id="4">4. 数值和布尔值的解构赋值</h1><p><br>解构赋值时，若等号右边是数值和布尔值，则会先转为对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，数值和布尔值的包装对象都有toString属性，故变量s都能取到值</p><p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined 和 null 无法转为对象，所以对它们解构赋值都会报错</p><h1 id="5">函数参数的解构赋值</h1><p><br>函数参数也可以使用解构赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y</p><p>可以为函数参数指定默认值</p><h1 id="6">圆括号问题</h1><p><br>解构赋值虽然方便了我们，但编译器解析起来并不容易，一个式子到底是模式，还是表达式，没办法一开始就知道。故ES6规则是，只要有可能导致解构的歧义，就不得使用圆括号</p><h2 id="6.1">不能使用圆括号的情况</h2><ol><li>变量声明语句</li></ol><p>变量声明语句，模式不能使用圆括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line">    <span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> &#123; <span class="attr">o</span>: (&#123; <span class="attr">p</span>: p &#125;) &#125; = &#123; <span class="attr">o</span>: &#123; <span class="attr">p</span>: <span class="number">2</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>函数参数</li></ol><p>函数参数也属于变量声明，因此不能带有圆括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[(z</span>)]) </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[z,(x</span>)]) </span>&#123; <span class="keyword">return</span> x; &#125;</span><br></pre></td></tr></table></figure><p>3.赋值语句的模式</p><p>下面代码将整个模式放在圆括号之中，导致报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line">(&#123; <span class="attr">p</span>: a &#125;) = &#123; <span class="attr">p</span>: <span class="number">42</span> &#125;;</span><br><span class="line">([a]) = [<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>下面代码将一部分模式放在圆括号之中，导致报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line">[(&#123; <span class="attr">p</span>: a &#125;), &#123; <span class="attr">x</span>: c &#125;] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure><h2 id="6.2">可以使用圆括号的情况</h2><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。</p><h1 id="7.1">用途</h1><h2>1. 交换变量的值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure><h2>2. 从函数返回多个值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        foo: <span class="number">1</span>,</span><br><span class="line">        bar: <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure><h2>3. 函数参数的定义</h2><p>解构赋值可以方便地将一组参数与变量名对应起来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><h2>4. 提取JSON数据</h2><p>解构赋值对提取 JSON 对象中的数据，尤其有用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">    id: <span class="number">42</span>,</span><br><span class="line">    status: <span class="string">"OK"</span>,</span><br><span class="line">    data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, "OK", [867, 5309]</span></span><br></pre></td></tr></table></figure><h2>5. 函数参数的默认值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">    beforeSend = function (</span>) </span>&#123;&#125;,</span><br><span class="line">    cache = <span class="literal">true</span>,</span><br><span class="line">    complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    crossDomain = <span class="literal">false</span>,</span><br><span class="line">    global = <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// ... more config</span></span><br><span class="line">&#125; = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2>6. 输入模块的指定方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;sin, cos, log&#125; = <span class="built_in">Math</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div style=&quot;background-color:#bdc3c7; width:100%;padding:10px 20px ;margin:0 auto;color:white&quot;&gt;&lt;br&gt;    &lt;a style=&quot;color:white ;display:block;
      
    
    </summary>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="解构赋值" scheme="http://yoursite.com/tags/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    
  </entry>
  
</feed>
