<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JS异步编程解决方案之Promise的原生实现</title>
      <link href="/2019/10/23/Promise%E5%8F%8A%E5%85%B6api%E7%9A%84%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/10/23/Promise%E5%8F%8A%E5%85%B6api%E7%9A%84%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>最近在深入学习JS的异步编程，为了更了解JS异步编程的解决方案 <code>Promise</code> ，实现了满足 <code>A+</code> 规范的 <code>Promise</code> 及其<code>API</code> </p><a id="more"></a><p>注意：本文不具体说明 <code>Promise</code> 的原生实现方式，要想知道每一步的由来，可点击 <a href="https://juejin.im/post/5b2f02cd5188252b937548ab" target="_blank" rel="noopener">这里</a></p><h1 id="Promise-初定义"><a href="#Promise-初定义" class="headerlink" title="Promise 初定义"></a>Promise 初定义</h1><p>ES6版本实现的 <code>Promise</code> 是一个类</p><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p><code>Promise</code> 的 <code>constructor</code> 接收一个 执行者函数 <strong>executor(resolve, reject)</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 一个 Promise 时候是这样写的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'1bin'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 其实就是给构造函数传了一个执行者函数</span></span><br><span class="line">executor = <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'1bin'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其中 executor 参数中的 resolve, reject 方法都应该由 Promise 类提供</span></span><br></pre></td></tr></table></figure><p>下面是 <code>Promise</code> 的 <code>constructor</code>  原生实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promise 三种状态</span></span><br><span class="line"><span class="built_in">Promise</span>.PENDING = <span class="string">'pending'</span></span><br><span class="line"><span class="built_in">Promise</span>.FULFILLED = <span class="string">'fulfilled'</span></span><br><span class="line"><span class="built_in">Promise</span>.REJECTED = <span class="string">'rejected'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> executor != <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'executor is not a function'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.status = <span class="built_in">Promise</span>.PENDING<span class="comment">// Promise 初始状态</span></span><br><span class="line">  <span class="keyword">this</span>.value = <span class="literal">undefined</span><span class="comment">// resolve 的返回值</span></span><br><span class="line">  <span class="keyword">this</span>.reason = <span class="literal">undefined</span><span class="comment">// reject 的返回值</span></span><br><span class="line">  <span class="comment">// 为解决异步操作而设立的数组，如果resolve或reject被异步挂起，</span></span><br><span class="line">  <span class="comment">// 其后then方法的所有回调都应该按顺序push到这个数组中，</span></span><br><span class="line">  <span class="comment">// 在resolve或reject被正式调用时再遍历数组执行所有回调方法</span></span><br><span class="line">  <span class="keyword">this</span>.resolvedCallbacks = []<span class="comment">// 成功回调数组</span></span><br><span class="line">  <span class="keyword">this</span>.rejectedCallbacks = []<span class="comment">// 失败回调数组</span></span><br><span class="line">  <span class="comment">// eg: P.then(res=&gt;res) </span></span><br><span class="line">  <span class="comment">// P.then(res=&gt;res)  这样resolvedCallbacks就会有两个成员</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">let</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="built_in">Promise</span>.PENDING) &#123;</span><br><span class="line">      <span class="keyword">this</span>.status = <span class="built_in">Promise</span>.FULFILLED</span><br><span class="line">      <span class="keyword">this</span>.value = value</span><br><span class="line">      <span class="keyword">this</span>.resolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="built_in">Promise</span>.PENDING) &#123;</span><br><span class="line">      <span class="keyword">this</span>.status = <span class="built_in">Promise</span>.REJECTED</span><br><span class="line">      <span class="keyword">this</span>.reason = reason</span><br><span class="line">      <span class="keyword">this</span>.rejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve, reject)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><p><strong>then(onFulfilled, onRejected)</strong> 方法返回一个 <code>Promise</code> ，参数为 <code>Promise</code> 的成功和失败情况的回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p为 Promise 实例，调用 then 方法时</span></span><br><span class="line">p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 其实就是给 then 方法传了两个回调函数</span></span><br><span class="line">onFulfilled = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;                     <span class="comment">//成功时</span></span><br><span class="line">onRejected = <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;                     <span class="comment">//失败时</span></span><br></pre></td></tr></table></figure><p>下面是 <code>then</code> 方法的原生实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// A+ 规范规定 onFulfilled如果不是函数，就忽略onFulfilled，直接返回value</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value </span><br><span class="line">  <span class="comment">// onRejected如果不是函数，就忽略onRejected，直接扔出错误</span></span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">err</span> =&gt;</span> &#123;<span class="keyword">throw</span> err&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// promise2 是 then 方法返回的 Promise 对象，为了实现链式调用</span></span><br><span class="line">  <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span>(<span class="keyword">this</span>.status) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">Promise</span>.FULFILLED:&#123;</span><br><span class="line">  <span class="comment">//ReferenceError: Cannot access 'promise2' before initialization</span></span><br><span class="line">  <span class="comment">//setTimeout 是为了模拟异步并且解决上面的报错</span></span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">  <span class="comment">//_resolvePromise 方法在下面有详细说明，这里暂且认为是为了解析 Promise 的返回值</span></span><br><span class="line">              <span class="keyword">this</span>._resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">Promise</span>.REJECTED:&#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">              <span class="keyword">this</span>._resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">Promise</span>.PENDING:&#123;</span><br><span class="line">          <span class="keyword">this</span>.resolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">                <span class="keyword">this</span>._resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">              &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                reject(e)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, <span class="number">0</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="keyword">this</span>.rejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">                <span class="keyword">this</span>._resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">              &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                reject(e)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, <span class="number">0</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="resolvePromise"><a href="#resolvePromise" class="headerlink" title="_resolvePromise()"></a>_resolvePromise()</h2><p><strong>_resolvePromise (promise2, x, resolve, reject)  </strong>方法用于解析 <code>Promise</code> 的返回值，<code>x</code> 为需要解析的值（ <code>return</code>返回值），x 的状态决定 <code>promise2</code> 的状态, 所以参数的 <code>resolve</code> , <code>reject</code>  是 <code>promise2</code> 的，为了在解析 <code>x</code> 后修改 <code>promise2</code> 的状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有时候我们会这样写</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'1bin'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//下面这个Promise无法直接获取到值，必须解析</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(res)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>下面是_resolvePromise 方法的原生实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">_resolvePromise(promis2, x, resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>( x === promis2) &#123;</span><br><span class="line">     <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>))</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">// 防止多次调用，只保留第一次改变的状态，之后的调用都会忽略</span></span><br><span class="line">   <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span>(x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'function'</span> || <span class="keyword">typeof</span> x === <span class="string">'object'</span>)) &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// A+ 规定，声明 then = x 的 then 方法</span></span><br><span class="line">       <span class="keyword">let</span> then = x.then</span><br><span class="line">   <span class="comment">// 如果 then 是函数，就默认是 Promise 了</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">         then.call(x, y =&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span>(called) <span class="keyword">return</span> ;</span><br><span class="line">           called = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// resolve 的结果依旧是 Promise 那就继续递归解析</span></span><br><span class="line">           <span class="keyword">this</span>._resolvePromise(promis2, y, resolve, reject)</span><br><span class="line">         &#125;, err =&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span>(called) <span class="keyword">return</span> ;</span><br><span class="line">           called = <span class="literal">true</span></span><br><span class="line">           reject(err)</span><br><span class="line">         &#125;)</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span>(called) <span class="keyword">return</span> ;</span><br><span class="line">         called = <span class="literal">true</span></span><br><span class="line">         resolve(x)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">       <span class="keyword">if</span>(called) <span class="keyword">return</span> ;</span><br><span class="line">       called = <span class="literal">true</span></span><br><span class="line">       reject(e)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     resolve(x)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="Promise-API"><a href="#Promise-API" class="headerlink" title="Promise API"></a>Promise API</h1><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><blockquote><p><strong>Promise.all(iterable)</strong> 方法返回一个 <code>Promise</code> 实例，此实例在 <code>iterable</code> 参数内所有的 <code>promise</code> 都完成（resolved）或参数中不包含 <code>Promise</code> 时回调完成（resolve）；如果参数中  <code>Promise</code> 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败的 <code>Promise</code> 的结果</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">arrPromise</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> LENGTH = arrPromise.length</span><br><span class="line">    <span class="keyword">let</span> conut = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> results = [] <span class="comment">//结果数组</span></span><br><span class="line">    <span class="built_in">Array</span>.from(arrPromise).forEach(<span class="function">(<span class="params">promise, idx</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(promise != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> promise === <span class="string">'function'</span> || <span class="keyword">typeof</span> promise === <span class="string">'object'</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          promise.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            results[idx] = result</span><br><span class="line">            <span class="keyword">if</span>(++conut == LENGTH) resolve(results)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        results[idx]  = promise</span><br><span class="line">        <span class="keyword">if</span>(++conut == LENGTH) resolve(results)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-allSettled"><a href="#Promise-prototype-allSettled" class="headerlink" title="Promise.prototype.allSettled()"></a>Promise.prototype.allSettled()</h2><blockquote><p><strong>Promise.allSettled(iterable) </strong>方法返回一个 <code>Promise</code>，该 <code>Promise</code> 在所有给定的 <code>Promise</code> 已被解析或被拒绝后解析，并且每个对象都描述每个 <code>Promise</code> 的结果。</p></blockquote><p><code>allSettled()</code> 已经加入 <code>ES2020</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.allSettled = <span class="function"><span class="keyword">function</span>(<span class="params">arrPromise</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> LENGTH = arrPromise.length</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> results = []</span><br><span class="line">    <span class="built_in">Array</span>.from(arrPromise).forEach(<span class="function">(<span class="params">promise, idx</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(promise != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> promise === <span class="string">'function'</span> || <span class="keyword">typeof</span> promise === <span class="string">'object'</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            results[idx] = &#123; <span class="attr">status</span>: <span class="string">"fulfiled"</span>, value &#125;</span><br><span class="line">            count++</span><br><span class="line">          &#125;, reason =&gt; &#123;</span><br><span class="line">            results[idx] = &#123; <span class="attr">status</span>: <span class="string">"rejected"</span>, reason &#125;</span><br><span class="line">            count++</span><br><span class="line">          &#125;).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(count === LENGTH) resolve(results)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><blockquote><p><strong>catch()</strong> 方法返回一个 <code>Promise</code> ，并且处理拒绝的情况。它的行为与调用<strong>Promise.prototype.then(undefined, onRejected)</strong> 相同。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><blockquote><p><strong>finally()</strong> 方法返回一个 <code>Promise</code>  。在  <code>Promise</code> 结束时，无论结果是 <code>fulfilled</code> 或者是 <code>rejected</code> ，都会执行指定的回调函数。这为在 <code>Promise</code> 是否成功完成后都需要执行的代码提供了一种方式。</p><p>这避免了同样的语句需要在<code>then()</code>和<code>catch()</code>中各写一次的情况。</p></blockquote><p><code>finally()</code> 已经加入 <code>ES8</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params">onFinally</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    result =&gt; <span class="built_in">Promise</span>.resolve(onFinally()).then(<span class="function"><span class="params">()</span> =&gt;</span> result),</span><br><span class="line">    err =&gt; <span class="built_in">Promise</span>.resolve(onFinally()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">throw</span> err&#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><blockquote><p><strong>Promise.race(iterable)</strong> 方法返回一个 <code>Promise</code> ，一旦迭代器中的某个 <code>Promise</code> 解决或拒绝，返回的  <code>Promise</code> 就会解决或拒绝。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">arrPromise</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Array</span>.from(arrPromise).forEach(<span class="function"><span class="params">promise</span> =&gt;</span> &#123;</span><br><span class="line">      promise.then(resolve, reject)</span><br><span class="line">    &#125;)</span><br><span class="line">  </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><blockquote><p><strong>Promise.reject(reason) </strong>方法返回一个带有拒绝原因 <code>reason</code> 参数的 <code>Promise</code> 对象。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(reason)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><blockquote><p><strong>Promise.resolve(value) </strong>方法返回一个以给定值解析后的 <code>Promise</code>  对象。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(value)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h2><blockquote><p><strong>Promise.any() </strong>方法接受一组 <code>Promise</code> 实例作为参数，包装成一个新的 <code>Promise</code> 实例。只要参数实例有一个变成 <code>fulfilled</code> 状态，包装实例就会变成 <code>fulfilled</code> 状态；如果所有参数实例都变成 <code>rejected</code> 状态，包装实例就会变成 <code>rejected</code> 状态。</p></blockquote><p><code>any()</code> 方法目前是一个第三阶段的<code>提案</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.any = <span class="function"><span class="keyword">function</span>(<span class="params">arrPromise</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> LENGTH = arrPromise.length</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> arrError = [];</span><br><span class="line">    <span class="built_in">Array</span>.from(arrPromise).forEach(<span class="function">(<span class="params">promise, idx</span>) =&gt;</span> &#123;</span><br><span class="line">      promise.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(result)</span><br><span class="line">      &#125;, reason =&gt; &#123;</span><br><span class="line">        arrError.push(reason)</span><br><span class="line">        count++</span><br><span class="line">        <span class="keyword">if</span>(count === LENGTH) reject(arrError)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h2><blockquote><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用  <code>Promise</code> 来处理它。因为这样就可以不管 <code>f</code> 是否包含异步操作，都用 <code>then</code> 方法指定下一步流程，用 <code>catch</code>方法处理 <code>f</code> 抛出的错误。</p></blockquote><p><code>try()</code> 方法还是一个<code>提案</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.try = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  (</span><br><span class="line">    () =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">      resolve =&gt; resolve(fn())</span><br><span class="line">    )</span><br><span class="line">  )()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块化三（CommonJS）</title>
      <link href="/2019/09/30/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%89/"/>
      <url>/2019/09/30/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p>传统的网页没有模块化也问题不大，但在服务器端，没有模块，就无法简单的与操作系统以及其他应用程序交流，所以 <code>NodeJS</code> 的诞生之初，就是参照 <code>CommonJS</code> 规范来实现其模块系统的</p><a id="more"></a><h4 id="CommonJS规范的定义"><a href="#CommonJS规范的定义" class="headerlink" title="CommonJS规范的定义"></a>CommonJS规范的定义</h4><p><code>CommonJS</code> 对模块的定义分为三个部分</p><ol><li>模块引用 <code>require</code> ，用于引入外部的模块</li><li>模块定义 <code>exports</code> ,  用于导出当前模块的方法或者变量，<code>exports</code> 对象是 <code>module</code> 的一个属性</li><li>模块标识 <code>module</code> ,  是一个对象，用来表示模块本身</li></ol><h4 id="NodeJS的模块实现"><a href="#NodeJS的模块实现" class="headerlink" title="NodeJS的模块实现"></a>NodeJS的模块实现</h4><p>在 <code>Node</code> 中引入模块，需要经历如下三个步骤</p><ol><li>路径分析</li><li>文件定位</li><li>编译执行</li></ol><p>在 <code>Node</code> 中，模块分为两类</p><ul><li><p>由 <code>Node</code> 提供的模块，称为核心模块，该部分在 <code>Node</code> 源代码的编译过程中，就被编译进入了二进制执行文件，在 <code>Node</code>进程启动时，部分核心模块就被直接加载进入内存中，所以这部分核心模块引入时，文件定位和编译执行可以省略，并且在路径分析中优先判断，所以其加载速度也是最快的</p></li><li><p>由用户编写的模块，称为文件模块，该部分在运行时动态加载，需要完整的经历上述的三个步骤，因此，其速度比核心模块慢</p></li></ul><h4 id="模块缓存"><a href="#模块缓存" class="headerlink" title="模块缓存"></a>模块缓存</h4><p><code>Node</code> 对引入模块，缓存的是模块编译和执行之后的对象，而浏览器仅仅缓存文件，<strong><code>require()</code> 方法对相同模块的二次加载都会采取缓存优先的方式</strong>，而核心模块的缓存检查会优先于文件模块的缓存检查</p><h4 id="路径分析"><a href="#路径分析" class="headerlink" title="路径分析"></a>路径分析</h4><p><code>require()</code> 方法接受一个<strong>标识符</strong>作为参数，路径分析的优先级是这样的</p><ol><li><p>缓存加载</p></li><li><p>核心模块加载</p></li><li><p>相对或绝对路径的形式加载（<strong>这种方式引入的模块都会被当做文件模块处理</strong>）</p></li><li><p>非路径形式的文件模块（自定义模块，一般引入别人的模块时会用到，可能是一个文件或者一个包，这种引入方式也是最慢的）</p></li></ol><p><strong>遍历模块路径数组</strong>是 <code>Node</code> 在定位文件模块的具体文件时制定的查找方式</p><p>在 <code>.js</code> 文件中打印出 <code>module.paths</code> ，可得类似这样的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">'D:\\前端\\demo\\模块化demo\\CommonJS\\node_modules'</span>,</span><br><span class="line">  <span class="string">'D:\\前端\\demo\\模块化demo\\node_modules'</span>,</span><br><span class="line">  <span class="string">'D:\\前端\\demo\\node_modules'</span>,</span><br><span class="line">  <span class="string">'D:\\前端\\node_modules'</span>,</span><br><span class="line">  <span class="string">'D:\\node_modules'</span> ]</span><br></pre></td></tr></table></figure><p>模块路径的生成规则是如下所示</p><ol><li>当前文件目录下的 <code>node_module</code> 目录</li><li>父目录下的 <code>node_module</code> 目录</li><li>父目录的父目录下的 <code>node_module</code> 目录</li><li>沿路径向上逐级递归，直到跟目录下的 <code>node_module</code> 目录</li></ol><p>在加载过程中， <code>Node</code> 会逐个尝试模块路径数组中的路径，直到找到目标文件为止，所以当文件的路径越深，其模块路径查找耗时会越多，这也是自定义模块的加载速度是最慢的原因</p><h4 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h4><p>文件定位的过程中，主要是以下两个事情的处理</p><ol><li>文件扩展名分析</li></ol><p><code>CommonJS</code> 规范允许标识符中不含文件扩展名，这种情况下，<code>Node</code> 会按<code>.js</code>,  <code>.json</code> , <code>.node</code> 的次序补全扩展名，依次尝试，在尝试过程中，需要调用 <code>fs</code> 模块同步阻塞式的判断文件是否存在</p><ol start="2"><li>目录分析和包</li></ol><p>在分析标识符过程中，<code>require()</code> 没有通过分析文件扩展名找到对应的文件，但却得到一个目录，这时候 <code>Node</code>会将这个目录当做一个包来处理</p><p>而在这个过程中，<code>Node</code> 对 <code>CommonJS</code> 包规范进行了一定程度的支持，处理包的过程如下</p><ol><li><p>Node在当前目录下查找 <code>package.json</code> （ <code>CommonJS</code> 包规范定义的包描述文件），然后通过 <code>JSON.parse()</code> 解析出包描述对象，取其 <code>main</code> 属性指定的文件名进行定位，如果缺少扩展名再进入扩展名分析的步骤</p></li><li><p>如果没有 <code>package.json</code> ，或者 <code>main</code> 属性指定的文件名出错，<code>Node</code> 会将 <code>index</code> 默认为文件名，并以此查找 <code>index.js</code>,  <code>index.json</code>,  <code>index.node</code></p></li><li><p>如果在目录分析的过程中没有成功定位到任何文件，则自定义模块会进入下一个模块路径进行查找，倘若模块路径数组被遍历完仍未查找到目标文件，则会抛出查找失败的异常</p></li></ol><h4 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h4><p>在Node中，每个文件模块都是一个对象，定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译，对于不同的文件扩展名，其载入方式也不一样</p><ol><li><p><code>.js</code> 文件，先 <code>fs</code> 模块同步读取后编译执行，后面会详细介绍</p></li><li><p><code>.json</code> 文件，先 <code>fs</code> 模块同步读取，然后再用 <code>JSON.parse()</code> 解析返回结果</p></li><li><p><code>.node</code> 文件，这是 <code>C/C++</code> 编写的扩展文件，通过 <code>dlopen()</code> 方法加载，最后编译生成文件</p></li><li><p>其余扩展名文件，当做 <code>.js</code> 文件载入</p></li></ol><p><strong>JavaScript模块的编译</strong></p><p>每个模块文件存在着 <code>require</code> ，<code>exports</code> ， <code>module</code> 这三个变量，以及<code>__dirname</code> ,<code>__filename</code>魔术变量</p><p>在我们没有定义这几个变量的情况下，为什么会出现这几个变量呢</p><p>原来，一个正常的 <code>.js</code> 文件会被 <code>Node</code> 包装成下面的样子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>)) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> fs = <span class="built_in">require</span>(fs);</span><br><span class="line"> exports.name = <span class="string">"1bin"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在头部添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>)) </span>&#123;\n</span><br></pre></td></tr></table></figure><p>在尾部添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\n&#125;);</span><br></pre></td></tr></table></figure><p>就这样，每个模块文件之间都进行了作用域的隔离，<strong>包装之后的代码会通过 <code>vm</code> 原生模块的<code>runInThisContext()</code> 方法执行</strong>，在模块代码内部只能访问到 <code>global</code> 对象，模块外部的代码也只能访问到<code>exports</code> 属性导出的值和模块内部定义的 <code>global</code> 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//modA.js</span></span><br><span class="line"><span class="keyword">const</span> vm = <span class="built_in">require</span>(<span class="string">'vm'</span>)</span><br><span class="line"><span class="keyword">const</span> filename = <span class="built_in">require</span>(<span class="string">'./resolveFileName.js'</span>) <span class="comment">//文件定位中得到的完整文件路径</span></span><br><span class="line"><span class="keyword">const</span> dirname = <span class="built_in">require</span>(<span class="string">'./resolveDirName.js'</span>)<span class="comment">//文件定位中得到的文件目录</span></span><br><span class="line"><span class="keyword">let</span> cb = vm.runInThisContext(<span class="string">`(function (require,exports,module,__filename, __dirname)&#123;</span></span><br><span class="line"><span class="string">exports.name = "1bin"</span></span><br><span class="line"><span class="string">let age = require('./a.js').age</span></span><br><span class="line"><span class="string">module.exports.age = age</span></span><br><span class="line"><span class="string">&#125;);`</span>)</span><br><span class="line">cb.call(<span class="built_in">module</span>, <span class="built_in">require</span>, <span class="built_in">module</span>.exports, <span class="built_in">module</span>, filename, dirname)<span class="comment">//参数顺序要对应好</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">let</span> modA = <span class="built_in">require</span>(<span class="string">'./modA.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(modA) <span class="comment">// &#123; name: '1bin', age: 18 &#125;</span></span><br></pre></td></tr></table></figure><h4 id="一点点小疑问"><a href="#一点点小疑问" class="headerlink" title="一点点小疑问"></a>一点点小疑问</h4><p>也许有人会有疑问，为什么在有 <code>exports</code> 的情况下，还存在 <code>module.exports</code> </p><p>简单来说，<code>exports</code> 是 <code>Node</code> 提供给我们的语法糖，实际上在模块的开始阶段都会加上这句话</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exports = <span class="built_in">module</span>.exports = &#123;&#125;</span><br></pre></td></tr></table></figure><p>也就是说，<code>exports</code> 只是 <code>module.exports</code> 的一个引用，下面两种写法是等效的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exports.name = <span class="string">"1bin"</span></span><br><span class="line"><span class="built_in">module</span>.exports.name = <span class="string">"1bin"</span></span><br></pre></td></tr></table></figure><p>只不过我们推荐这种写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.name = <span class="string">"1bin"</span></span><br><span class="line"><span class="comment">//如果想一次性全部导出的话</span></span><br><span class="line"><span class="built_in">module</span>.expotrs = &#123; age, id&#125; <span class="comment">//这种写法会覆盖掉 exports 的导出，使得 exports 的导出 name 无效</span></span><br></pre></td></tr></table></figure><p>此外，<code>exports</code> 不能导出一个函数或类，即</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//error</span></span><br><span class="line">exports = [<span class="function"><span class="keyword">function</span>]</span></span><br><span class="line"><span class="function">//<span class="title">error</span></span></span><br><span class="line">exports = [class]</span><br></pre></td></tr></table></figure><p>因为函数或类也是个对象，如果将 <code>exports</code> 赋值给一个新的对象，会导致引用修改，即此时 <code>exports</code> 和原引用 <code>module.exports</code> 再无关系，由于 <code>Node</code> 的默认是将 <code>module.exports</code> 给导出，这将导致 <code>exports</code> 导出失败，这种情况下，只能使用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = [<span class="function"><span class="keyword">function</span>]</span></span><br><span class="line"><span class="function">//<span class="title">or</span></span></span><br><span class="line">module.exports = [class]</span><br></pre></td></tr></table></figure><h4 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h4><p><code>ES6</code> 模块和 <code>CommonJS</code> 模块完全不同</p><blockquote><p>它们有两个重大差异</p><ol><li><p><code>CommonJS</code> 模块输出的是一个值的拷贝(其 <code>this</code> 为 <code>全局对象</code>)，而 <code>ES6</code> 模块输出的是值的引用(所以其 <code>this</code> 为 <code>undefined</code> )</p></li><li><p><code>CommonJS</code> 模块是运行时加载，而 <code>ES6</code> 模块是编译时输出接口</p></li></ol></blockquote><p><strong>第一个差异的原因</strong></p><p>​    <code>CommonJS</code> 模块的值一旦输出，模块内部的变化就影响不到这个值，不像 <code>ES6</code> 模块有动态绑定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//modB.js</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAge</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  age++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  age,</span><br><span class="line">  addAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">let</span> modB = <span class="built_in">require</span>(<span class="string">'./modB'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(modB.age); <span class="comment">//18</span></span><br><span class="line">modB.addAge()</span><br><span class="line"><span class="built_in">console</span>.log(modB.age); <span class="comment">//18</span></span><br></pre></td></tr></table></figure><p><code>modB</code> 加载后，其 <code>modB.age</code> 值是个原始类型的值，会被缓存，所以看不到其值的改变</p><p>但如果将其值写成一个函数，便能得到其内部变化后的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//modB.js</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAge</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  age++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  get age()&#123; <span class="comment">//取值器函数</span></span><br><span class="line">    <span class="keyword">return</span> age</span><br><span class="line">  &#125;,</span><br><span class="line">  addAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">let</span> modB = <span class="built_in">require</span>(<span class="string">'./modB'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(modB.age); <span class="comment">//18</span></span><br><span class="line">modB.addAge()</span><br><span class="line"><span class="built_in">console</span>.log(modB.age); <span class="comment">//19</span></span><br></pre></td></tr></table></figure><p><strong>第二个差异的原因</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; age, name &#125; = <span class="built_in">require</span>(<span class="string">'./modB.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _modB = <span class="built_in">require</span>(<span class="string">'./modB.js'</span>)</span><br><span class="line"><span class="keyword">let</span> age = _modB.age</span><br><span class="line"><span class="keyword">let</span> name = _modB.name</span><br></pre></td></tr></table></figure><p>上面代码的实质是加载 <code>modB</code> 模块的所有方法，生成一个对象<code>_modB</code>  然后再从这个对象解构读取所需值或方法，这种叫做<strong>运行时加载</strong>，因为<strong>只有运行时才能得到这个对象，导致完全没办法在编译时做静态优化</strong></p><p>而 <code>ES6</code> 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，再通过 <code>import</code>命令输入。这个特性使得<code>ES6</code> 可以在编译时就完成模块加载，效率要比 <code>CommonJS</code> 模块的加载方式高</p>]]></content>
      
      
      
        <tags>
            
            <tag> CommonJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块化二（ES6模块）</title>
      <link href="/2019/09/26/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%BA%8C/"/>
      <url>/2019/09/26/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p><code>AMD</code>, <code>CMD</code> 两种前端模块化标准都需要引入相应的 <code>.js</code>文件，而 <code>ES6模块</code> 算是官方模块化的一种标准，可以直接使用</p><p>内联引用 <code>script</code> 标签时引入模块，只需要给内联 <code>script</code> 标签设置 <code>type=&quot;module&quot;</code></p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"./main.js"</span> type=<span class="string">"module"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>浏览器对于带有<code>type=&quot;module&quot;</code>的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，<strong>等同于打开了<code>&lt;script&gt;</code>标签的<code>defer</code>属性</strong></p></blockquote><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><p>ES6的模块是编译时加载的，通过 <code>export</code> 命令指定输出，再通过 <code>import</code> 命令指定输入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//modA.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">saySomething</span>(<span class="params">myName</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;myName&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">"1bin"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, saySomething &#125;  <span class="keyword">from</span> <span class="string">'./modA.js'</span></span><br><span class="line">saySomething(name)</span><br></pre></td></tr></table></figure><p>值得注意的是，<strong><code>import</code> 模块的 <code>.js</code> 后缀名不能省，只能使用绝对或者相对路径</strong>，否则浏览器无法解析到模块导致报错</p><h4 id="export-命令"><a href="#export-命令" class="headerlink" title="export 命令"></a>export 命令</h4><p> <code>export</code> 命令规定的是对外的接口，<strong>该接口必须得和模块内部的变量建立起一对一的关系</strong></p><p>下面的写法就是典型的错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="string">"1bin"</span></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"1bin"</span></span><br><span class="line"><span class="keyword">export</span> name</span><br></pre></td></tr></table></figure><p>正确写法应该为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">"1bin"</span></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"1bin"</span></span><br><span class="line"><span class="keyword">export</span> &#123;name&#125; <span class="comment">//其他脚本可以通过这个接口，取到值 1bin</span></span><br><span class="line"><span class="comment">//or 使用as关键词取别名</span></span><br><span class="line"><span class="keyword">let</span> year = <span class="number">9102</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;year <span class="keyword">as</span> number&#125;</span><br></pre></td></tr></table></figure><p>函数和类也是一样得遵循这个写法来达到对外提供接口的效果，因为这样才能保证 <code>export</code> 输出的接口，与其对应的值是动态绑定关系</p><h4 id="import-命令"><a href="#import-命令" class="headerlink" title="import 命令"></a>import 命令</h4><p><code>import</code> 命令用于加载其他模块的对外接口，得到的变量都是只读的，也就是说，不允许在加载模块的脚本里面，改写接口（<strong><code>import</code> A模块的一个对象后，给该对象添加属性，其他模块引用A模块的该对象时也会受到影响，但这是极其不推荐的写法</strong>）</p><p><code>import</code> 命令会执行所加载的模块，所以可以有如下写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./modA.js'</span></span><br></pre></td></tr></table></figure><p><strong>多次加载一个模块只会执行一次，<code>import</code> 命令是在编译阶段执行，所以它是一个模块之中最早执行的，也就是具有所谓的提升效果</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line">saySomething();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; saySomething &#125; <span class="keyword">from</span> <span class="string">'./modA.js'</span>;</span><br></pre></td></tr></table></figure><h4 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h4><p><code>export default</code> 命令实质是将后面的值，赋给 <code>default</code> 变量，并将 <code>default</code>变量输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">"1bin"</span></span><br><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">let</span> name = <span class="string">"1bin"</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认函数输出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">saySomething</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I'm 1bin"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">import</span> saySomething <span class="keyword">from</span> <span class="string">'./modA.js'</span>; </span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> saySomething&#125; <span class="keyword">from</span> <span class="string">'./modA.js'</span></span><br><span class="line"><span class="comment">//同时引用默认接口和其他接口</span></span><br><span class="line"><span class="keyword">import</span> saySomething,&#123; name, age &#125; <span class="keyword">from</span> <span class="string">'./modA.js'</span></span><br></pre></td></tr></table></figure><h4 id="ES6模块思想"><a href="#ES6模块思想" class="headerlink" title="ES6模块思想"></a>ES6模块思想</h4><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量，而 <code>AMD</code> ，<code>CMD</code> ，<code>CommonJS</code>都只能在运行时确定这些东西</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; saySomething &#125; <span class="keyword">from</span> <span class="string">'./modA.js'</span></span><br></pre></td></tr></table></figure><p>像这样的加载叫做编译时加载（或称静态加载），只会从  <code>modA</code> 模块加载一个 <code>saySomething</code> 方法，其他属性或方法不加载，这样的加载效率自然比传统的模块化快，而这样也导致了不存在ES6模块本身，它压根不是个对象，因此其<strong>模块顶层的 <code>this</code> 为undefined</strong></p><p>正是由于这个编译时加载的特性，使得静态分析成为可能，有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏和类型检验这些只能靠静态分析实现的功能</p><p>这也是为什么 <code>export</code>，<code>import</code> 命令只能放在模块顶层，如果这些命令放在条件代码块里面，就无法做静态优化，这违背了ES6模块的设计初衷</p><p>也正是如此，<code>import</code> 命令不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//error</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="string">'na'</span>+ <span class="string">'me'</span>&#125; <span class="keyword">from</span> <span class="string">'./modA.js'</span></span><br><span class="line"><span class="comment">//error</span></span><br><span class="line"><span class="keyword">let</span> myMod = <span class="string">'./modA.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> myMod</span><br><span class="line"><span class="comment">//error</span></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">'./modA.js'</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; age &#125; <span class="keyword">from</span> <span class="string">'./modB.js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ES6模块运行机制"><a href="#ES6模块运行机制" class="headerlink" title="ES6模块运行机制"></a>ES6模块运行机制</h4><blockquote><p>JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，模块的原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//modA.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">"1bin"</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> name = <span class="string">"ebin"</span> , <span class="number">1000</span>)</span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">'./modA.js'</span></span><br><span class="line"><span class="built_in">console</span>.log(name,<span class="string">'&lt;&lt;==old name is here'</span>)  <span class="comment">//1bin</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(name, <span class="string">'&lt;&lt;==new name is here'</span>), <span class="number">1000</span>)  <span class="comment">//ebin</span></span><br></pre></td></tr></table></figure><h4 id="Import"><a href="#Import" class="headerlink" title="Import()"></a>Import()</h4><p>JS 引擎处理ES6模块的 <code>import</code>命令是在编译阶段，这就导致了无法在运行时选择加载模块，Node 的 <code>require()</code>方法就是运行时加载模块，也就是说 <code>require()</code> 到底加载哪个模块，只有运行的时候才知道，<code>import</code>命令无法做到这一点，所以，<code>Import()</code>诞生了，用来完成动态加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./modA.js'</span>).then(<span class="function"><span class="params">module</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">module</span>.name)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>import()</code>返回一个 <code>Promise</code>对象，加载模块成功后，这个模块会作为一个对象，当作 <code>then</code>的参数</p><p>想要同时加载多个模块，可以这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">    <span class="keyword">import</span>(<span class="string">'./modA.js'</span>),</span><br><span class="line">    <span class="keyword">import</span>(<span class="string">'./modB.js'</span>)</span><br><span class="line">])</span><br><span class="line">.then(<span class="function">(<span class="params">[modA, modB]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>按条件加载模块也成了可能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./modA.js'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./modB.js'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后</p><blockquote><p><code>import()</code>函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，<strong><code>import()</code>函数与所加载的模块没有静态连接关系</strong>，这点也是与<code>import</code>语句不相同。<strong><code>import()</code>类似于 Node 的<code>require</code>方法，区别主要是前者是异步加载，后者是同步加载。</strong></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> ES6模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块化一（AMD，CMD）</title>
      <link href="/2019/09/24/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2019/09/24/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>前端模块化是在web前端界面逻辑越来越复杂后出现的需求。先有<code>AMD</code>，后有<code>CMD</code>，到现在的<code>ES6</code>，这些都是为了解决前端模块化的标准</p><a id="more"></a><p>实现模块化的几个尝试</p><ul><li><p>函数封装：污染全局变量</p></li><li><p>对象：外部可以随意修改内部成员</p></li><li><p>IIFE：可以达到不暴露私有成员的目的，这也是模块化的基本写法</p><p><a href="https://www.cnblogs.com/dolphinX/p/4381855.html" target="_blank" rel="noopener">具体可见这里</a></p></li></ul><h4 id="AMD：requireJS"><a href="#AMD：requireJS" class="headerlink" title="AMD：requireJS"></a>AMD：requireJS</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config = &#123;</span><br><span class="line">  paths:&#123;</span><br><span class="line"><span class="comment">//键值对，用于改写路径</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依赖的顺序和回调函数的顺序一致</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">"modA"</span>, <span class="string">"modB"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">modA, modB</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名即模块名</span></span><br><span class="line">define([<span class="string">"modA"</span>, <span class="string">"modB"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">modA, modB</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">     fnC: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">`I'm modC`</span>)</span><br><span class="line">     &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果没有使用依赖，还可以这样define</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>([],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line">    exports.fnC = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="CMD：-seaJS"><a href="#CMD：-seaJS" class="headerlink" title="CMD： seaJS"></a>CMD： seaJS</h4><p>感觉和node的CommonJS规范很像</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">seajs.config(&#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line"><span class="comment">//键值对，用于改写路径</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//modA.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    exports.fnA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//or</span></span><br><span class="line">    <span class="built_in">module</span>.exports = &#123; <span class="attr">fnA</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>1.推崇文件名即为模块名</p><p>2.不推崇依赖提前（define写依赖），推崇依赖就近（factory里写依赖）</p><p>3.factory里的用法和node用法很像</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//modB.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fnA = <span class="built_in">require</span>(<span class="string">"modA"</span>).fnA</span><br><span class="line">    fnA()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在非factory里面是没有require的，如果要加载模块，可以这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line">seajs.use(<span class="string">"modA.js"</span>)</span><br><span class="line"><span class="comment">//or 下面需要callback的写法</span></span><br><span class="line">seajs.use(“modA.js”, <span class="function"><span class="keyword">function</span>(<span class="params">modA</span>)</span>&#123;</span><br><span class="line">    modA.fnA();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="AMD-与-CMD-的异同"><a href="#AMD-与-CMD-的异同" class="headerlink" title="AMD 与 CMD 的异同"></a>AMD 与 CMD 的异同</h4><p>​    最明显的区别在于<strong>模块定义时对依赖模块的处理不同</strong></p><blockquote><ol><li>AMD推崇依赖前置，在定义时候就要声明所需要的依赖模块</li><li>CMD推崇就近依赖，在用到依赖模块地方才去require</li></ol></blockquote><p>其实requireJS 和 seaJS 都可以支持对方的写法，但这两者的最大区别不在于语法，而在于<strong>对依赖模块的执行时机处理不同</strong></p><p>两者加载模块的方式都是异步的，只是AMD推崇依赖前置，js可以很快知道需要依赖的模块是什么，并且立即加载；而CMD推崇的就近依赖，需要把模块变成字符串解析一遍才能知道依赖了哪些模块，虽然解析模块的用时很短，不过还是对性能有所牺牲了</p><p>现假设定义某个模块需要依赖modA和modB两个模块，讨论两种规范的异同：</p><ul><li><p>同：两者都是异步加载依赖模块，等到所有模块都加载完（下载完），再去执行主逻辑回调函数</p></li><li><p>异：</p><p>AMD: 哪个模块先加载完，就先执行哪个模块，这样导致的问题便是依赖的执行顺序和程序员书写的顺序不一致，但是模块整体延迟就降低了</p><p>CMD: 依赖模块只有在需要用到它的时候（require的时候），才会执行模块，保证了模块的执行顺序和书写顺序是完全一致的</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> AMD </tag>
            
            <tag> CMD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域那些事</title>
      <link href="/2019/09/20/%E8%B7%A8%E5%9F%9F/"/>
      <url>/2019/09/20/%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="跨域是什么"><a href="#跨域是什么" class="headerlink" title="-  跨域是什么"></a>-  跨域是什么</h4><p>​    <strong>协议，域名，端口，有一个不同即为跨域，跨域是浏览器的一种保护机制</strong></p><a id="more"></a><h4 id="跨域会如何"><a href="#跨域会如何" class="headerlink" title="-  跨域会如何"></a>-  跨域会如何</h4><p>​        跨域会受到以下三点非同源限制                </p><blockquote><ol><li>无法获取网页的 Cookie, Local Storage, Indexed DB</li><li>无法获取网页的 DOM 元素</li><li>无法向非同源地址发送 AJAX 请求</li></ol></blockquote><h4 id="网页与网页间的跨域交流"><a href="#网页与网页间的跨域交流" class="headerlink" title="-  网页与网页间的跨域交流"></a>-  网页与网页间的跨域交流</h4><ol><li><p>为了让两个跨域页面可以共享Cookie（此方案仅限主域相同，子域不同的跨域应用场景）</p><p>将 document.domain 设置成相同的父域名</p><p>eg: 两个网页</p><ol><li><p>cba.testCors.com:8080  </p></li><li><p>abc.testCors.com:8080  </p></li></ol><p>两边都设置 document.domain = testCors.com</p><p>ps:  这个浏览器还是会检测的，不是你想改成什么域名就变成什么的</p></li></ol><ol start="2"><li>跨文档通信 API：window.postMessage()</li></ol><h4 id="网页和服务器间的跨域交流"><a href="#网页和服务器间的跨域交流" class="headerlink" title="-  网页和服务器间的跨域交流"></a>-  网页和服务器间的跨域交流</h4><p>​            对下文的几点说明</p><blockquote><ol><li>前端为vue-cli搭建，端口号为8080</li><li>后台为koa2搭建，端口号为9099</li><li>在 C:\Windows\System32\drivers\etc 目录下，修改hosts文件，在文件底部增加  <code>127.0.0.1 testCors.com</code> 将 127.0.0.1 别名为 testCors.com </li></ol></blockquote><h5 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1.JSONP"></a>1.JSONP</h5><p>​    JSONP 兼容 IE , 只支持 GET 不支持 POST, 原理在于 script 标签的 src 属性不受跨域限制</p><p>​    网页:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">saySomething</span><span class="params">(str)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(str)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://testCors.com:9099/testGet?cb=saySomething"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    后台:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/testGet'</span>, <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; cb &#125; = ctx.request.query;</span><br><span class="line">    ctx.body = <span class="string">`<span class="subst">$&#123;cb&#125;</span>('now you see me')`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>​    技巧在于请求参数 cb 的值 saySomething 要在网页中定义好，后台只是把 saySomething(‘now you see me’) 发送到网页并执行</p><h5 id="2-CORS"><a href="#2-CORS" class="headerlink" title="2. CORS"></a>2. CORS</h5><p>​    CORS有两种请求，一是简单请求，二是非简单请求</p><h4 id="何为简单请求"><a href="#何为简单请求" class="headerlink" title="- 何为简单请求"></a>- 何为简单请求</h4><p>​    只要同时满足以下两大条件，就属于简单请求</p><ol><li><p>请求方式属于以下几种</p><ul><li>GET</li><li>POST </li><li>HEAD</li></ul></li><li><p>HTTP 请求头信息不超出以下几种字段 </p><ul><li><p>Accept </p></li><li><p>Accept-Language</p></li><li><p>Content-Language</p></li><li><p>Last-Event-ID</p></li><li><p>Content-Type: 只限于 </p><p>application/x-www-form-urlencoded</p><p>multipart/form-data</p><p>text/plain </p></li></ul></li></ol><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="- 简单请求"></a>- 简单请求</h4><p>​    只需要后台设置 Access-Control-Allow-Origin (以下简称 ACAO )</p><p>​    需要允许某个域名的时候 ，注意 协议 域名 端口 缺一不可，而且域名要全小写，有大写的时候不匹配</p><p>​    我前端域名是 testCors.com 后台也这样设置的话还是会报跨域，域名需要</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/testGet'</span>, <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.set(<span class="string">'Acess-Control-Allow-Origin'</span>, <span class="string">'http://testcors.com:8080'</span>);</span><br><span class="line">    ctx.body=<span class="string">"now you see me"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="前后端-cookie-通信"><a href="#前后端-cookie-通信" class="headerlink" title="- 前后端 cookie 通信"></a>- 前后端 cookie 通信</h4><p>​    若想前后端用 cookie 通信, 并将 cookie 保存在前端,值得注意的是,后台若将ACAO改为* ，这时f etch 需要将 credentials 选项去掉，并且此时对 cookie 的设置无效</p><p>​    所以为了能正常 cookie 通信，需要后台设置准确的地址，并且前后端都要开启 cookie 认证</p><p>​    前端:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">fetch(`http:<span class="comment">//testCors.com:9099/testGet`, &#123;</span></span></span><br><span class="line"><span class="actionscript">    credentials: <span class="string">'include'</span></span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="javascript">.then( <span class="keyword">async</span> res =&gt; &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="keyword">await</span> res.test())</span></span><br><span class="line"><span class="undefined">&#125;)    </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    后台:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/testGet'</span>, <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.set(<span class="string">'Access-Control-Allow-Origin'</span>,<span class="string">'http://testcors.com:8080'</span>)</span><br><span class="line">    ctx.set(<span class="string">'Access-Control-Allow-Credentials'</span>, <span class="literal">true</span>)</span><br><span class="line">    ctx.cookies.set(<span class="string">'tokenId'</span>,<span class="string">'111'</span>,&#123;<span class="attr">httpOnly</span>:<span class="literal">false</span>&#125;)</span><br><span class="line">    ctx.body = <span class="string">"now you see me"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>​    前端可以通过 <code>document.cookie</code> 来获取到 httpOnly 不为true的cookie，所以上述代码设置 cookie 时添加了 <code>httpOnly:false</code> 选项</p><p>​    当然 cookie 存在前端十分不安全, 只要在浏览器将 cookie 修改, 后台用<code>ctx.cookie.get(&#39;token&#39;)</code>的时候也会修改</p><h4 id="非简单类型请求"><a href="#非简单类型请求" class="headerlink" title="- 非简单类型请求"></a>- 非简单类型请求</h4><p>若添加headers来触发非简单请求的条件二（多加了HTTP头信息）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">fetch(<span class="string">`http://testCors.com:9099/testGet`</span>, &#123;</span><br><span class="line">    credentials: <span class="string">'include'</span>,</span><br><span class="line">    headers: <span class="keyword">new</span> Headers(&#123;<span class="string">'Content-Type'</span>: <span class="string">'application/jsons'</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then( <span class="keyword">async</span> res =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> res.test())</span><br><span class="line">&#125;)    </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>控制台会毫不留情的报错<br><img src="/../img\Snipaste_2019-09-20_22-17-56.png" alt=""></p><p><img src="/../img\Snipaste_2019-09-20_21-04-38.png" alt=""></p><p>并且请求方式貌似变成了 OPTIONS 这是因为</p><blockquote><p>在跨域并且尝试添加一些特殊头及自定义头的情况下，由于浏览器的安全机制，会加多一次OPTIONS预请求（询问请求），与跨域服务器协商可以设置的头部信息，可以允许的HTTP协议等等信息</p></blockquote><p>这时按照控制台的提示，在前端加上 <code>mode : &quot;no-cors&quot;</code> (不跨域)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">fetch(<span class="string">`http://testcors.com:9099/testGet?msg=Helllooo`</span>,&#123;</span><br><span class="line">    credentials: <span class="string">'include'</span>,</span><br><span class="line">    headers:<span class="keyword">new</span> Headers(&#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    mode: <span class="string">'no-cors'</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="keyword">async</span> res =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> res.text())</span><br><span class="line">&#125;)</span><br><span class="line"> &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>后台变成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/testGet'</span>, <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.set(<span class="string">'Access-Control-Allow-Origin'</span>,<span class="string">'*'</span>)</span><br><span class="line">  ctx.set(<span class="string">'Access-Control-Allow-Credentials'</span>, <span class="literal">true</span>)</span><br><span class="line">  ctx.cookies.set(<span class="string">'token'</span>,<span class="string">'222'</span>,&#123;</span><br><span class="line">    httpOnly:<span class="literal">false</span></span><br><span class="line">  &#125;)</span><br><span class="line">   <span class="comment">//以下为新增</span></span><br><span class="line">  ctx.set(<span class="string">'Access-Control-Request-Method'</span>, <span class="string">'PUT,POST,GET,DELETE,OPTIONS'</span>)</span><br><span class="line">  ctx.set(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Origin, X-Requested-With, Content-Type, Accept'</span>);</span><br><span class="line">  ctx.body = <span class="string">"now you see me"</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时，即使 ACAO 为 * ，也能正常进行 cookie 交流</p><p>上述方式多少有点奇怪， 比如为什么mode设置为 no-cors 还能跨域呢？</p><p>想不明白，我们来用终极方案吧</p><h4 id="koa-cors"><a href="#koa-cors" class="headerlink" title="koa-cors"></a><strong>koa-cors</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">'koa-cors'</span>);</span><br><span class="line">app.use(cors(&#123;</span><br><span class="line">    credentials:<span class="literal">true</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>前端 credentials 设置为 include （默认情况下前端不开启 cookie）</p><p>这样就什么问题都没了，对了如果前端设置了新的 headers 字段，会先发送个 OPTIONS请求核对 headers等信息，所以在控制台会先收到 OPTION 204， 再收到 GET 200</p><p><img src="/../img\Snipaste_2019-09-20_21-52-37.png" alt=""></p><p>再说说 credentials 的几个选项的含义</p><blockquote><ol><li><p>same-origin 只想请求URL与调用的脚本处于同一起源处</p></li><li><p>include 为了让浏览器发送包含凭据的请求（即使是跨域源）</p></li><li><p>omit 为了让浏览器发送包含凭据的请求（即使是跨域源）不允许会报 OPTIONS 的错误</p></li></ol></blockquote><h4 id="前端代理"><a href="#前端代理" class="headerlink" title="-  前端代理"></a>-  前端代理</h4><p>proxyTable(开发时候用)</p><p>​     在 vue-cli 搭建的config&gt;index.js 下的 dev 选项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">  <span class="string">'/'</span>: &#123;</span><br><span class="line">    target: <span class="string">'http://testCors.com:9099/'</span>,</span><br><span class="line">    changOrigin: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">fetch(<span class="string">`/testGet?msg=Helllooo`</span>)</span><br><span class="line">.then( <span class="keyword">async</span> res =&gt; &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">await</span> res.text())</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>神奇的事情发生了，后台即使不使用 koa-cors ，也完全不会有跨域的问题，proxyTable的原理，应该是开了个和网页同域的服务器，网页请求跨域服务器时，这个同域的服务器会拦截请求，并且代理发送请求到目标服务器，利用的是服务器之间不存在跨域的原理</p>]]></content>
      
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下的mysql</title>
      <link href="/2019/09/05/linux%E4%B8%8B%E7%9A%84mysql/"/>
      <url>/2019/09/05/linux%E4%B8%8B%E7%9A%84mysql/</url>
      
        <content type="html"><![CDATA[<p>云服务器上的mysql一开始是用lnmp一键安装的，当时忘记了mysql的密码，于是在网上找到一些方法跳过密码直接进入mysql，再接着修改密码</p><a id="more"></a><ol><li>首先进到根目录，然后进入 <strong>etc</strong> 文件夹</li><li>找到mysql配置文件 <strong>my.cnf</strong>，拖到本地</li><li>打开my.cnf，找到[mysqld]，在该行下面添加一行 <strong>skip-grant-tables</strong> （跳过登录时的权限表）</li><li>覆盖服务器上的原配置文件，使用 <strong>service mysql restart</strong>  重启mysql</li><li>然后输入 <strong>mysql -uroot -p</strong> ，遇到输入密码直接回车即可进入mysql </li><li>在命令行 输入 <strong>use mysql</strong> 收到 Database changed 的反馈</li><li>输入 <strong>update user set password = password(‘新的密码’) where user = ‘root’;</strong> (注意分号不能漏)</li></ol><p><img src="/../img/20190905.png" alt=""></p><ol start="8"><li><p>然后输入 <strong>exit</strong> 退出mysql</p></li><li><p>修改本地的 <strong>my.cnf</strong> 文件，把刚刚添加的一行去掉，再覆盖服务器的原配置文件</p></li><li>再次重启服务器即可</li></ol><p>这里再记录几个linux命令</p><ul><li><p>service mysql start  开启mysql</p></li><li><p>service mysql stop   关闭mysql</p></li><li><p>service mysql restart 重启mysql</p></li><li><p>netstat -ntlp   //查看当前所有tcp端口·</p></li><li><p>netstat -an | grep 3306   //查看所有3306端口使用情况</p></li></ul><p><strong>另外在数据库初始化建表的时候遇到了字段长度过长（varchar255）的问题 Specified key was too long; max key length is 767 bytes  百度各种启用innodb_large_prefix 的方法，但没有一个试成功了，只能改字段长度</strong></p><blockquote><p>上面有提到单列索引限制767，起因是256×3-1。这个3是字符最大占用空间（utf8）。但是在5.5以后，开始支持4个字节的uutf8。255×4&gt;767, 于是增加了一个参数叫做 innodb_large_prefix这个参数默认值是OFF。当改为ON时，允许列索引最大达到3072。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用ts搭建koa项目</title>
      <link href="/2019/07/20/ts+koa%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/07/20/ts+koa%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>  这次许愿墙后台是用koa+ts+mysql写的，由于没有自带的koa+ts的项目结构，所以是先建了个koa项目，然后在配置ts文件</p><a id="more"></a> <h2 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h2><p>这是完整的ts配置文件，注意json文件不支持注释</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">      <span class="string">"module"</span>: <span class="string">"commonjs"</span>, <span class="comment">//模块处理是使用commonjs的方式</span></span><br><span class="line">      <span class="string">"target"</span>: <span class="string">"es2017"</span>,   <span class="comment">//使用es7是为了能使用async await</span></span><br><span class="line">      <span class="string">"noImplicitAny"</span>: <span class="literal">false</span>,   </span><br><span class="line">      <span class="string">"moduleResolution"</span>: <span class="string">"node"</span>,</span><br><span class="line">      <span class="string">"sourceMap"</span>: <span class="literal">false</span>,   <span class="comment">//开了的话会生成xxx.map.js文件</span></span><br><span class="line">      <span class="string">"esModuleInterop"</span>: <span class="literal">true</span>,  </span><br><span class="line">      <span class="string">"rootDirs"</span>: [         <span class="comment">//这是关键，这样声明可以实现多个出口，即不同目录结构</span></span><br><span class="line">        <span class="string">"./utils"</span>,          <span class="comment">//的ts文件可以按原目录文件结构编译，而outDir是单出口</span></span><br><span class="line">        <span class="string">"./routes"</span>,         <span class="comment">//的命令，配合rootDirs可以生成一个编译后保持原目录结</span></span><br><span class="line">        <span class="string">"./app.js"</span>          <span class="comment">//构的js目录</span></span><br><span class="line">      ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"include"</span>: [              <span class="comment">//声明需要被编译的文件夹</span></span><br><span class="line">    <span class="string">"./utils"</span>,</span><br><span class="line">    <span class="string">"./routes"</span>,</span><br><span class="line">    <span class="string">"./app.ts"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"exclude"</span>: [              <span class="comment">//声明不需要被编译的文件夹      </span></span><br><span class="line">    <span class="string">"node_modules"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在package.json配置两条命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&quot;dev&quot;: &quot;nodemon --watch routes --watch utils --watch ./ -e ts --exec ts-node bin/www&quot;</span><br></pre></td></tr></table></figure><p>平时开发用，用了nodemon监控routes，utils和根目录文件后缀为ts的修改，一旦触发，就会执行重新编译的命令，重新编译使用的<code>ts-node</code>可保证在不显式生成js文件的情况下，使得ts文件能够正常运行起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;build&quot;: &quot;tsc -w --outDir ./dist --project ./tsconfig.json&quot;</span><br></pre></td></tr></table></figure><p>上线打包测试用，-w是监控，<code>--outDir ./dist</code>表示编译后重定向文件到dist文件夹，<code>--project ./tsconfig.json</code>表示ts编译的时候使用tsconfig.json配置文件的规则，默认其实是不用给也会寻找tsconfig.json的</p>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
            <tag> koa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器，webpack打包</title>
      <link href="/2019/07/19/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8Cwebpack%E6%89%93%E5%8C%85/"/>
      <url>/2019/07/19/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8Cwebpack%E6%89%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><strong>写在前面：</strong></p><p>这算是第一次将完整的项目丢到服务器上去，包括后台服务和前端打包好的文件，下面将记录这次操作遇到的一些情况</p><a id="more"></a><h2 id="后台部分"><a href="#后台部分" class="headerlink" title="后台部分"></a>后台部分</h2><p>后台项目是用express框架，里面的静态文件在放在public文件夹内，只需把前端代码打包后生成的index.html和static文件夹丢到public文件夹内即可，后台代码放在了<code>/home/wwwroot</code>下</p><h3 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h3><p>用PuTTY命令行工具的时候，会有一个问题，一旦启动了其中一个服务，就无法进行其他操作(比如开启另一个服务)，这样还会导致退出PuTTY的时候，刚开启的服务会自己断开</p><p>为解决这个问题，需要用到Screen工具，一般Linux机都会自带</p><p><strong>这里记录几个常用命令</strong></p><ol><li><code>screen -S name</code>  —&gt; 新建一个名叫name的会话</li><li><code>screen -ls</code>      —&gt; 列出当前所有会话</li><li><code>screen -r name</code>  —&gt; 回到name这个会话，配合-ls命令，name用会话序号代替即可</li><li><code>screen -d name</code>  —&gt; 远程detach某个会话，状态为Attached的会话不能用-r命令进入</li><li><code>C-a + z</code>        —&gt; 把当前会话放到后台执行，用 shell 的 fg 命令则可回去</li><li><code>C-a + c</code>         —&gt; 创建一个新的运行shell的窗口并切换到该窗口</li><li><code>screen -S name -X quit</code> —&gt;关闭某个会话</li></ol><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>安装MongoDB在 <code>/usr/local</code>，在MongoDB文件夹内执行 <code>bin/mongod</code> 即可开启MongoDB</p><h2 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h2><p>前端项目是用vue框架，用Webpcak打包时遇到了很多问题</p><h3 id="assets"><a href="#assets" class="headerlink" title="assets"></a>assets</h3><p>assets里面的文件会根据url-loader的limit分情况处理，vue-cli的limit为10000b，略小于10k</p><ol><li><p>小于url-loader的limit限制的文件会直接变成base64</p><ul><li><code>eg: xxx.png =&gt; data:image/xxx;base64,ixxxxxxx</code></li></ul></li><li><p>大于limit限制的是重新命名一下，不变成base64</p><ul><li><code>eg: xxx.png =&gt; xxx.0974910.png</code></li></ul></li></ol><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>static里面的文件会原封不动的放在打包后的static文件夹里</p><h2 id="图片资源打包情况分析"><a href="#图片资源打包情况分析" class="headerlink" title="图片资源打包情况分析"></a>图片资源打包情况分析</h2><h3 id="npm-run-dev"><a href="#npm-run-dev" class="headerlink" title="npm run dev"></a>npm run dev</h3><p>在开发模式下，讨论两种引用图片资源的情况：</p><ol><li><p>template中通过img标签的src来引用图片资源</p><ul><li><p>通过<code>&quot;../assets/xxx.png&quot;</code>或者<code>&quot;../../static/xxx.png&quot;</code>这两种都是通过相对路径引用也会有两种情况</p><ol><li>小于limit的图片：仍然是base64</li><li>大于limit的图片：<code>/static/img/xxx.0974910.png</code></li></ol></li><li><p>通过<code>/static/xxx.png</code>绝对路径的方式引用图片，是可以被loader识别并且不被webpack打包，即可以保持原文件不变，在img的src中为<code>/static/xxx.png</code></p><p><strong>注意：可以用<code>static/xxx.png</code>(即省略开头的’/‘)来达到上述效果，不过在<code>npm run build</code>后会报错，所以还是不推荐</strong></p></li></ul></li><li><p>style中通过background-img的url来引用图片资源</p><ul><li><p>通过<code>../../static/xxx.png</code>或者<code>../assets/xxx.png</code>这两种相对路径引用也会有两种情况</p><ol><li>小于limit的图片：仍然是base64</li><li>大于limit的图片：<code>/static/img/xxx.0974910.png</code></li></ol></li><li><p>通过<code>/static/xxx.png</code>绝对路径的方式引用图片，是可以被loader识别并且不被webpack打包，即可以保持原文件不变，在img的src中为<code>/static/xxx.png</code></p></li><li><p><strong>注意：不可以用<code>static/xxx.png</code>(即省略开头的/)来达到上述效果</strong></p><p><strong>总结：在 <code>npm run dev</code> 后，如使用到相对路径引用图片资源，就会被webpack打包到<code>/static/img/</code>下，即被webpack处理；若使用绝对路径引用图片资源，webpack会保持原文件不变，放在<code>/static/</code>下</strong></p></li></ul></li></ol><h3 id="npm-run-build"><a href="#npm-run-build" class="headerlink" title="npm run build"></a>npm run build</h3><p>这个模式下，和<code>npm run dev</code>的区别是teplate的img标签的src不能<code>static/xxx.png</code>（即不能省略’/‘)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>WebPack</title>
      <link href="/2019/07/11/WebPack/"/>
      <url>/2019/07/11/WebPack/</url>
      
        <content type="html"><![CDATA[<p>最近学了点webpack，算是入门了，对于webpack的进阶知识没有太多涉猎，对HMR热更新有一点点了解，但没有深入其实现原理，或许未来会去专门深入学习HMR热更新原理</p><a id="more"></a><p>开始的学习是根据<a href="https://segmentfault.com/a/1190000006178770#articleHeader9" target="_blank" rel="noopener">这篇博客</a>进行搭建的,这篇博客用的webpack版本是3.x，虽然webpack思想没改变，但与现在的webpack4.x版本还是有点区别，自己搭建的时候还是遇到了一些意外的情况</p><ol><li><p>全局安装webpack的时候npm报错</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:<span class="symbol">\前</span>端<span class="symbol">\w</span>ebpack<span class="symbol">\d</span>emo&gt;npm install -g webpack</span><br><span class="line">npm ERR! Maximum call stack size exceeded</span><br></pre></td></tr></table></figure><p>原因是自己的npm版本过低(5.x)，升级npm后再装webpack，问题解决</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:<span class="symbol">\前</span>端<span class="symbol">\w</span>ebpack<span class="symbol">\d</span>emo&gt;npm i npm -g</span><br><span class="line">D:<span class="symbol">\前</span>端<span class="symbol">\w</span>ebpack<span class="symbol">\d</span>emo&gt;npm -v</span><br><span class="line">6.10.0</span><br></pre></td></tr></table></figure></li><li><p>webpack命令行现在需要使用webpack-cli，而且webpack-cli需要全局安装</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">D</span>:\前端\webpack\demo&gt;webpack</span><br><span class="line"><span class="keyword">One</span> <span class="keyword">CLI</span> <span class="keyword">for</span> webpack must be installed. These are recommended choices, delivered <span class="keyword">as</span> <span class="keyword">separate</span> packages:</span><br><span class="line">- webpack-<span class="keyword">cli</span> (https:<span class="comment">//github.com/webpack/webpack-cli)</span></span><br><span class="line">  The original webpack full-featured <span class="keyword">CLI</span>.</span><br><span class="line">We will <span class="keyword">use</span> <span class="string">"npm"</span> to install the <span class="keyword">CLI</span> via <span class="string">"npm install -D"</span>.</span><br><span class="line"><span class="keyword">Do</span> you want to install 'webpack-<span class="keyword">cli</span>' (yes/<span class="keyword">no</span>): <span class="built_in">y</span></span><br><span class="line">Installing 'webpack-<span class="keyword">cli</span>' (running 'npm install -<span class="keyword">D</span> webpack-<span class="keyword">cli</span>')...</span><br></pre></td></tr></table></figure><p>这里下载的webpack-cli不是全局安装，还是会报错，所以需要使用webpack命令行命令前全局安装webpack-cli，至此，意外的情况解决</p></li></ol><h2 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h2><p>下面是webpack配制文件的一些基础又重要的选项，在这里只说明这些选项是干什么的，不是api</p><h4 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h4><p>  <code>devtool: &#39;eval-source-map&#39;</code></p><ol><li>规定打包时候生成的文件的格式，不同值打包速度不同，完整性不同</li><li>在source-map模式，使用babel后，原文件的es6被转成es5在浏览器运行，若不使用devtool，在浏览器看到的js是es5，和自己源码的es6不一样，导致修改麻烦（suorce-map的作用就是在浏览器控制台可以看到原文件出错的地方，而不是经过转译后其他格式的文件）</li><li>在eval模式，在webpack打包生成的文件里面搜索eval，可以看到每个模块的地址</li></ol><h4 id="entry-amp-output"><a href="#entry-amp-output" class="headerlink" title="entry &amp; output"></a>entry &amp; output</h4><ul><li><p>单入口</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">entry:</span> __dirname + <span class="string">"/app/main.js"</span>,</span><br><span class="line"><span class="symbol">output:</span> &#123;</span><br><span class="line"><span class="symbol">  path:</span> __dirname + <span class="string">"/build"</span>,</span><br><span class="line"><span class="symbol">  filename:</span> <span class="string">"bundle.js"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>此时设置的entry为全文唯一入口，output设置打包后的文件名以及存放的地址</p></li><li><p>多入口</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">entry</span>: &#123;</span><br><span class="line">  <span class="attribute">index</span>: __dirname + <span class="string">"/app/index.js"</span>,</span><br><span class="line">  admin: __dirname + <span class="string">"/app/admin.js"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">output</span>: &#123;</span><br><span class="line">  <span class="attribute">path</span>: __dirname + <span class="string">"/build"</span>,</span><br><span class="line">  filename: <span class="string">"[name].min.js"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>多入口需要配置一个JSON对象，这样会编译出两个打包后的文件 index.min.js 和 admin.min.js</p></li></ul><h4 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h4>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mode: <span class="string">'none'</span>, <span class="string">'production'</span>,<span class="string">'development'</span></span><br></pre></td></tr></table></figure><pre><code>none:只打包不压缩production:压缩到极限（默认值）development:保留必要信息，方便调试mode不设置则为默认值，但是会有warn</code></pre><h4 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h4><p>  下载 webpack-dev-server之后，浏览器监听你的代码的修改，并自动刷新显示修改后的结果, This should be used for development only.</p>  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">devServer:</span> &#123;</span><br><span class="line"><span class="symbol">  contentBase:</span> <span class="string">"./public"</span>,<span class="comment">//本地服务器所加载的页面所在的目录</span></span><br><span class="line"><span class="symbol">  historyApiFallback:</span> true,<span class="comment">//如果设置为true，所有的跳转将指向index.html</span></span><br><span class="line"><span class="symbol">  port:</span> <span class="number">4000</span>,</span><br><span class="line"><span class="symbol">  hot:</span> true<span class="comment">//这个是热替换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>热替换HMR和自动刷新（live-reload）的区别</strong></p><p>  热替换可以只替换某个组件，自动刷新就是所有组件一起重置，热替换可以保存组件原来的状态信息，不去重新渲染没有修改的组件</p><h4 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h4><p>  webpack只认识js，只能打包js，所以需要各种loader来把不同的文件变成字符串等webpack可以认识的东西，从而实现把各种各样的文件打包到一起的效果，可以说，没有loader，webpack什么都不是</p><p>  下面介绍接种常见的loader</p><ul><li>css-loader<br>  把css文化变成字符串，让webpack能接受并打包</li><li>style-loader<br>  把打包后的css样式，在head标签内生成style标签</li><li><p>postcss-loader<br>  依赖于autoprefixer，给样式加前缀</p><p>三个loader配合使用写法如下，use的执行顺序为有后向前，这个三个loader的执行顺序不能乱</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">module</span>: &#123;</span><br><span class="line">  <span class="attribute">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.css$/,</span><br><span class="line">      use: [</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">"style-loader"</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          <span class="attribute">loader</span>: <span class="string">"css-loader"</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            modules: true, // 指定启用css modules</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">          <span class="attribute">loader</span>: <span class="string">"postcss-loader"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>file-loader<br>输出成文件，只是改个名（md5规范）</p></li><li><p>url-loader<br>读取并输出成base64 </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">loader</span>: 'url-loader,</span><br><span class="line">    <span class="attribute">options</span>: &#123;</span><br><span class="line">      <span class="attribute">outputPath </span>: <span class="string">'images/'</span>,</span><br><span class="line">      <span class="attribute">limit</span>: <span class="number">8</span>*<span class="number">1024</span> <span class="comment">//小于这个的打包成base64,大于这个的变成文件</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>bable-loader<br>把es6转成es5，避免某些浏览器不能识别es6，其配置信息可以另外写在 .bablerc 文件里，webpack会自动调用.babelrc里的babel配置选项</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>  以上便是这几天入门webpack学到的一些皮毛，虽然学的很浅，不过自己对于工程化的理解加深了不少，对模块化的理解更深了一点，webpack更深层次的东西，希望以后能够有时间有能力去探秘</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序爬坑笔记2</title>
      <link href="/2019/05/31/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9D%82%E8%AE%B0/"/>
      <url>/2019/05/31/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9D%82%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>下面是个人做破碎时间微信小程序时碰到的琐碎的坑点(其实是自己太菜)</p><a id="more"></a><ol><li><p>wx:for<br>当需要两重循环的时候，需要绑定不同的 item 值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;block wx:<span class="keyword">for</span>=<span class="string">"&#123;&#123; days &#125;&#125;"</span> wx:<span class="keyword">for</span>-item=<span class="string">"cardList"</span> wx:key=<span class="string">"key1"</span>&gt;</span><br><span class="line">   &lt;view wx:<span class="keyword">for</span>=<span class="string">"&#123;&#123; cardList &#125;&#125;"</span> wx:<span class="keyword">for</span>-item=<span class="string">"card"</span> wx:key=<span class="string">"key2"</span>&gt;</span><br><span class="line">   &lt;<span class="regexp">/view&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>block&gt;</span><br></pre></td></tr></table></figure></li><li><p>picker 时间选择,不给默认初值,就强行当前时间开始选择(安卓机(小米)是如此,ios 却是从 00:00 开始)</p></li><li><p>textarear 的 placeholder 若想为空,修改其值为 ‘’ 是无效的,要改为 ‘ ‘</p></li><li><p>textarea 的 placeholder 样式穿透问题，placeholder永远在最上面一层显示,只能强行让其消失(改值为空)，貌似所有原生组件都会有在其他引用组件上方的z-index无效的问题( vue 的好像相反？当初用 vant 做日历选择的时候被遮盖)</p></li><li><p>传事件的参数是个对象，不是一个个传，和 vue 的不同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.triggerEvent(<span class="string">'myevent'</span>,&#123;<span class="attr">confirm</span>:<span class="literal">false</span>,<span class="attr">isTapX</span>:<span class="literal">false</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p>图片要放 CDN 上,不然预览不了  </p></li><li><p>真机调试发现用到全局对象时候更新渲染很慢，以后能用缓存的就要用缓存才行,少用慎用 setData ,用缓存</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set/getStrogeSync(<span class="string">''</span>)</span><br></pre></td></tr></table></figure></li><li><p>text-area 的焦点事件响应会很慢,如果不进行延迟,会导致出问题(莫名得到不对的值或者得不到值)</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序爬坑笔记1</title>
      <link href="/2019/05/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2019/05/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="Page-prototype-setData-Object-data-Function-callback"><a href="#Page-prototype-setData-Object-data-Function-callback" class="headerlink" title="Page.prototype.setData(Object data, Function callback)"></a>Page.prototype.setData(Object data, Function callback)</h2><p>  setData方法是自带的，也是微信小程序开发最常用的方法之一，然而使用这个方法的时候遇到了好几个问题</p><a id="more"></a><ol><li><p>setData里面键值对左边若存在变量，键值对左边需要用[ ]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ID = e.currentTarget.dataset.id;</span><br><span class="line"><span class="keyword">let</span> val = <span class="string">`cards[<span class="subst">$&#123;ID&#125;</span>].val`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.setData(&#123;</span><br><span class="line">    [val]: ID</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//不存在变量直接用""</span></span><br><span class="line"><span class="keyword">this</span>.setData(&#123;</span><br><span class="line">    <span class="string">"a[0].id"</span>: <span class="number">2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>用this.data对象修改值，并不会影响视图渲染层，只有用setData修改this.data时候能修改视图渲染层</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setData(&#123;</span><br><span class="line">  timeStart:<span class="string">'11:00'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.data.timeStart) <span class="comment">// "11:00",视图修改</span></span><br><span class="line"><span class="keyword">this</span>.data.timeStart = <span class="string">'12:00'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.data.timeStart) <span class="comment">// "12:00"，视图未修改</span></span><br></pre></td></tr></table></figure><p>由此可知setData里面修改的data对象并不是this.data对象，猜测为setData修改了一个直接和视图层挂钩的data对象，同时将this.data对象赋值为视图层的data对象</p></li><li><p>setData里面若存在过多的数据修改，会导致视图渲染层修改失败，但this.data对象值可正常修改</p></li><li><p>setData里面设置的数据，不用在this.data对象预先说明，会直接添加，但这样很不好</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS-文件流操作</title>
      <link href="/2019/04/09/NodeJS-%E6%96%87%E4%BB%B6%E6%B5%81%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/04/09/NodeJS-%E6%96%87%E4%BB%B6%E6%B5%81%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<ol style="background: #bdc3c7;    border-radius: 5px;    color: #2980b9;    font-size: 20px;    font-weight: bold;    cursor: pointer;    padding-top: 10px;    padding-bottom: 10px;    text-decoration:none;    line-height:1;    width:80%;    margin:0 auto;    list-style:none"><br>  <li style="list-decoration:none"><a href="#6-1" style="color: #4682BE;text-decoration:none;margin-left:10px">1. 文件流基本操作</a></li><br>  <li style="list-decoration:none"><a href="#6-2" style="color: #4682BE;text-decoration:none;margin-left:10px">2. 文件压缩</a></li><br>  <li style="list-decoration:none"><a href="#6-3" style="color: #4682BE;text-decoration:none;margin-left:10px">3. 服务器上应用</a></li><br>  <li style="list-decoration:none"><a href="#6-4" style="color: #4682BE;text-decoration:none;margin-left:10px">4. 启动器</a></li><br></ol><a id="more"></a><h2 id="6-1">文件流基本操作</h2><p>之前的文件操作是用了fs.readFile()和fs.writeFile(),这两种方式需要把所有文件读取或者写入才能执行下一步，这样做是十分耗资源的，所以我们应该用流的形式，读一块写一块，进行文件读写</p><p>还是用到了fs模块，只不过换成了fs.createReadStream()和fs.createWriteStream()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rs = fs.createReadStream(<span class="string">'1.txt'</span>);</span><br><span class="line"><span class="keyword">let</span> ws = fs.createWriteStream(<span class="string">'2.txt'</span>);</span><br><span class="line"></span><br><span class="line">rs.pipe(ws); <span class="comment">// 顺序不能反 rs==&gt;ws</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取操作的error事件重要，需要处理，写入操作也有error事件</span></span><br><span class="line">rs.on(<span class="string">'error'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//写入操作的finish事件才是真正表示文件操作结束</span></span><br><span class="line">ws.on(<span class="string">'finish'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finish'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>流的形式可以处理文本，二进制文件(图片，音视频等)</p><h2 id="6-2">文件压缩</h2><p>文件流操作不止可以读一块写一块，实际上读写流也是可以的，文件的压缩和加密就是把读取到的文件数据直接修改为另外一种形式</p><p>我们需要配合zlib模块创建gzip对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs =<span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rs = fs.createReadStream(<span class="string">'2.txt'</span>);</span><br><span class="line"><span class="keyword">let</span> gzip = zlib.createGzip();</span><br><span class="line"><span class="keyword">let</span> ws = fs.createWriteStream(<span class="string">'2.txt.gz'</span>);</span><br><span class="line"></span><br><span class="line">rs.pipe(gzip).pipe(ws);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'error'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ws.on(<span class="string">'finish'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finish'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="6-3">服务器上应用</h2><p>配合服务器的情况下，req本身就是一种读入流，res本身就是一种写入流</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span><br><span class="line"><span class="keyword">const</span> fs =<span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server =  http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;pathname&#125; = url.parse(req.url,<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">//pathname 会自动带 / 要特别注意,如 /1.txt 会报错没有这个文件</span></span><br><span class="line">  <span class="keyword">let</span> rs = fs.createReadStream(<span class="string">`www<span class="subst">$&#123;pathname&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">let</span> gzip = zlib.createGzip();</span><br><span class="line">  rs.pipe(gzip).pipe(res);</span><br><span class="line"></span><br><span class="line">  rs.on(<span class="string">'error'</span>, err =&gt; &#123;</span><br><span class="line">    res.writeHeader(<span class="number">404</span>);</span><br><span class="line">    res.write(<span class="string">'not found'</span>);</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><p>以上代码，会造成浏览器直接下载文件，因为浏览器不认识gz格式的数据，打开会是一堆乱码</p><p><img src="/../img/fsStream/1.jpg" alt=""></p><p>解决这个问题也很简单，只要加一句</p><p><code>res.setHeader(&#39;content-encoding&#39;, &#39;gzip&#39;);</code></p><p>但如果只是单纯告诉浏览器我要换格式，若请求的是不存在的文件，你发送的’not found’可不是gzip格式，这个时候浏览器也一脸懵逼</p><p>解决这个问题只需要在error事件回调函数中重新修改响应头信息</p><p><code>res.setHeader(&#39;content-encoding&#39;, &#39;&#39;);</code></p><p>为了解决读取文件的错误，最好在最外层就抛出错误，而不是传到一半才发现有问题，我们可以使用fs.stat()</p><p>下面代码是比较合适的一种服务器文件流操作写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server =  http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;pathname&#125; = url.parse(req.url,<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">let</span> fileName = <span class="string">`www<span class="subst">$&#123;pathname&#125;</span>`</span>;</span><br><span class="line">  </span><br><span class="line">  fs.stat(fileName, (err, stat) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">      res.writeHeader(<span class="number">404</span>);</span><br><span class="line">      res.write(<span class="string">'not found'</span>);</span><br><span class="line">      res.end();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      res.setHeader(<span class="string">'content-encoding'</span>,<span class="string">'gzip'</span>);</span><br><span class="line">      <span class="keyword">let</span> gzip = zlib.createGzip();</span><br><span class="line">      <span class="keyword">let</span> rs = fs.createReadStream(fileName);</span><br><span class="line">      rs.on(<span class="string">'error'</span>, err =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;)</span><br><span class="line">      rs.pipe(gzip).pipe(res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><h2 id="6-4">启动器</h2><p>在以往开启服务器的过程中，一旦我们关闭了控制台，服务也就中断了，一旦某次请求出了错误，服务器直接崩溃死机，为了解决这个问题，NodeJS提供了很多启动器插件</p><p>在这里，我们就以forever来介绍</p><p><code>forever start xxx.js</code> 以启动器进行服务<br><code>forever list</code>  查看执行了启动器的服务<br><code>forever restart xxx.js</code>  更新服务器代码并重新开启<br><code>forever stop xxx.js</code>  关闭某个服务<br><code>forever stopall</code>  关闭所有服务<br><code>forever start xxx.js -l path1 -e path2 -a</code><br>-l ==&gt; -log 把控制台输出放到path1<br>-e ==&gt; -error 把错误输出到path2<br>-a ==&gt; 不清除日志</p>]]></content>
      
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS-数据库</title>
      <link href="/2019/04/07/NodeJS-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/04/07/NodeJS-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<ol style="background: #bdc3c7;    border-radius: 5px;    color: #2980b9;    font-size: 20px;    font-weight: bold;    cursor: pointer;    padding-top: 10px;    padding-bottom: 10px;    text-decoration:none;    line-height:1;    width:80%;    margin:0;    list-style:none"><br>  <li style="list-decoration:none"><a href="#5-1" style="color: #4682BE;text-decoration:none;margin-left:10px">1. 数据库类型</a></li><br>  <li style="list-decoration:none"><a href="#5-2" style="color: #4682BE;text-decoration:none;margin-left:10px">2. 数据库建表</a></li><br>  <li style="list-decoration:none"><a href="#5-3" style="color: #4682BE;text-decoration:none;margin-left:10px">3. 索引值</a></li><br>  <li style="list-decoration:none"><a href="#5-4" style="color: #4682BE;text-decoration:none;margin-left:10px">4. SQL四大语句</a></li><br>  <li style="list-decoration:none"><a href="#5-5" style="color: #4682BE;text-decoration:none;margin-left:10px">5. mysql模块</a></li><br>  <li style="list-decoration:none"><a href="#5-6" style="color: #4682BE;text-decoration:none;margin-left:10px">6. co-mysql模块</a></li><br></ol><hr><a id="more"></a><h2 id="5-1">数据库类型</h2><p>数据库可以简单的分为四个类型</p><ol><li><p>文件型<br>文件型数据库的特点就是简单，典型代表为access，SQLite(常用)，多用于app数据的本地存储，为单一用户服务</p></li><li><p>关系型<br>关系型数据库可以处理复杂逻辑，典型代表为MySQL，Oracle</p></li><li><p>分布型<br>分布型数据库把数据库分配到很多个服务器上，提高性能效率，典型代表为mongoDB</p></li><li><p>NoSQL<br>NoSQL不是 NO SQL 的意思，它代表 Not Only SQL ，也就是说NoSQL不只是可以提供常规SQL的服务，可以处理高并发，具有高性能的特点，典型代表为memcache，redis(常用)</p></li></ol><h2 id="5-2">数据库建表</h2><p>数据库有一些常用管理工具，如navicat(付费)，wamp的phpmyadmin，本篇博客我们用phpmyadmin做示例</p><p>首先进入 127.0.0.1/phpmyadmin/ ,进入MySQL操作界面</p><p>然后我们新建数据库20190407，选择编码类型为utf8_general_ci(若要按中文排序，可以用big5_chinese_ci,支持繁体)</p><p><img src="/../img/dbIMG/1.jpg" alt=""></p><p>创建好库后我们创建新表 user_table ，设置字段</p><p><img src="/../img/dbIMG/2.jpg" alt=""></p><p>值得一提的是，字段类型若为短文本可以用 VARCHAR ，若为长文本要用 TEXT ，A.I 表示自增，PRIMARY 是主键，具有限制作用，还可以提高搜索性能(可快速通过主键找到数据)，UNIQUE 表示不重复</p><h2 id="5-3">索引值</h2><br>1. UNIQUE(唯一),表示该字段的值为唯一不可重复<br><br>2. INDEX(索引)，提高查询性能，但相应的会降低其他操作性能，占用一定空间<br><br>3. PRIMARY(主键)，表示UNIQUE(唯一)加INDEX(索引)<br><br>4. FULLTEXT(全文搜索)，多用于文本搜索，搜索引擎常用，相当于多关键字搜索，INDEX(索引)相当于单关键字搜索<br><br><h2 id="5-4">SQL四大语句</h2><ol><li>增: INSERT INTO &lt;表&gt; (字段) VALUES(值,…)<br><code>INSERT INTO user_table (username,password) VALUES(&#39;1bin&#39;,&#39;123456&#39;)</code></li><li>删: DELETE FROM &lt;表&gt; WHERE 条件<br><code>DELETE FROM user_table WHERE ID=1</code></li><li>改: UPDATE &lt;表&gt; SET 字段=新值,… WHERE 条件<br><code>UPDATE user_table SET username=&#39;Crazy&#39;,password=&#39;654321&#39; WHERE ID=2</code></li><li>查: SELECT 字段列表 FROM &lt;表&gt; WHERE 条件 ORDER BY 字段 LIMIT 数据的数量<br><code>SELECT * FROM user_table WHERE ID&lt;5 ORDER BY ID DESC LIMIT 2</code><br>DESC表示降序</li></ol><h2 id="5-5">mysql模块</h2><p>mysql不是系统自带的，需要下载，其常规用法为<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> db = mysql.createConnection(&#123;</span><br><span class="line">  host:<span class="string">'localhost'</span>,</span><br><span class="line">  port:<span class="number">3306</span>,</span><br><span class="line">  user:<span class="string">'root'</span>,</span><br><span class="line">  password:<span class="string">"123456"</span>,</span><br><span class="line">  database:<span class="string">'20190407'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">db.query(<span class="string">`SELECT * FROM user_table`</span>,(err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(data));  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>上面代码为建立一个数据库服务连接，实际上我们需要建立连接池，而不只是一个服务器连接，这个时候我们需要用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db = mysql.createPool(&#123;</span><br><span class="line">    connectionLimit:<span class="number">10</span>, <span class="comment">//10为默认连接最大值</span></span><br><span class="line">    host:<span class="string">'localhost'</span>,</span><br><span class="line">    port:<span class="number">3306</span>,</span><br><span class="line">    user:<span class="string">'root'</span>,</span><br><span class="line">    password:<span class="string">"123456"</span>,</span><br><span class="line">    database:<span class="string">'20190407'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>然而数据库操作是异步处理，mysql模块需要自己写回调，很麻烦</p><h2 id="5-6">co-mysql模块</h2><p>co-mysql模块帮我们封装了mysql的异步操作，其配合http服务的例子如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co-mysql'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> conn = mysql.createPool(&#123;</span><br><span class="line">  connectionLimit:<span class="number">10</span>,</span><br><span class="line">  host:<span class="string">'localhost'</span>,</span><br><span class="line">  port:<span class="number">3306</span>,</span><br><span class="line">  user:<span class="string">'root'</span>,</span><br><span class="line">  password:<span class="string">'123456'</span>,</span><br><span class="line">  database:<span class="string">'20190407'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> db = co(conn);</span><br><span class="line"><span class="keyword">let</span> server = http.createServer(<span class="keyword">async</span> (req,res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="keyword">await</span> db.query(<span class="string">`SELECT * FROM user_table`</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">        res.write(<span class="string">'hi'</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        res.write(<span class="string">'数据库出错'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    res.end();</span><br><span class="line">&#125;).listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><p>加上try捕获错误会更好</p>]]></content>
      
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket</title>
      <link href="/2019/04/03/NodeJS-WebSocket/"/>
      <url>/2019/04/03/NodeJS-WebSocket/</url>
      
        <content type="html"><![CDATA[<p>WebSocket是H5提供的一种协议，它具有高效，双向通信的特点</p><a id="more"></a><p>说到WebSocket，先提一下http协议，我们都知道通过http协议和服务器完成数据交换需要三次握手，如果想等服务器一有数据就可以返回给客户端，只能通过Ajax轮询的方式进行，这样做的后果是，服务器会每隔一个固定时间就被请求一次，而http请求又是十分低效的(每次请求都要发送‘我是谁’等等数据给服务器，不能只发送真正要发的数据)，这势必会造成服务器资源浪费，要求服务器处理请求速度很快，这显然是不合适的</p><p>那既然重复请求效率低，我们是不是可以建立一次请求不断开呢？是的，我们有个技术叫long poll(长轮询)，它虽然是基于Ajax轮询的，不过采用的是阻塞式通信，也就是说会一直挂在服务器上不断开，这样确实解决了http请求效率低下的问题，不过也大大增加了服务器的负担，这要求服务器有足够多的空间进行挂载，这显然是不合理的</p><p>为了加快和服务器的通信速度，并且实现双向通信，WebSocket应运而生</p><p>WebSocket只会利用http协议和服务器进行第一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输，此后协议升级为WebSocket，http是超文本传输协议，本质上还是字符串传输，而WebSocket是基于二进制传输的，其效率自然大大提高，而WebSocket和长连接有些类似，但它只会占用很少的服务器资源，不会像long poll那样一直暂居服务器上大量资源</p><p>说了那么多，我们回到NodeJS的世界，来用一下WebSocket</p><p>WebSocket是H5出现的，则势必不兼容低版本浏览器，WebSocket连接也势必会有掉线的问题，这些问题都挺麻烦的，不过，有了socket.io库，这些都不是问题，它可以自动重连，可以兼容到IE5，还可以自动数据解析，最最重要的是，它还十分简单方便。</p><p>服务器<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = http.createServer(<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line">server.listen(<span class="number">8080</span>);</span><br><span class="line"><span class="comment">//WebSocket协议需要监听http协议，一旦第一次握手后，便会抢夺服务控制权</span></span><br><span class="line"><span class="keyword">let</span> wsServer = io.listen(server);</span><br><span class="line"></span><br><span class="line">wsServer.on(<span class="string">'connection'</span>, sock =&gt;&#123;</span><br><span class="line">  <span class="comment">//sock.emit('name', 数据);</span></span><br><span class="line">  <span class="comment">//sock.on('name', function(数据)&#123;&#125;);</span></span><br><span class="line">  <span class="comment">//响应浏览器 a事件</span></span><br><span class="line">  sock.on(<span class="string">'a'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a,b,a+b);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//提交 time事件 到浏览器</span></span><br><span class="line">  setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    sock.emit(<span class="string">'time'</span>,<span class="keyword">new</span> <span class="built_in">Date</span>().getTime());</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>浏览器<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//这个socket.io.js文件是服务器的socket.io提供的</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://localhost:8080/socket.io/socket.io.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// ws:// 是WebSocket协议的标识，表明将要把协议升级为ws</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> sock = io.connect(<span class="string">'ws://localhost:8080/'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">//提交 a事件 到服务器</span></span></span><br><span class="line"><span class="javascript">  sock.emit(<span class="string">'a'</span>,<span class="number">12</span>,<span class="number">5</span>);</span></span><br><span class="line"><span class="javascript">  <span class="comment">//响应服务器 time事件 </span></span></span><br><span class="line"><span class="javascript">  sock.on(<span class="string">'time'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">time</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(time);    </span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>原生WebSocket比较难写，设计到很多二进制的操作，缓存问题，在此只列出一下WebSocket是怎么做到协议升级的</p><p>首先WS请求头会比http请求头多出四个东西</p><p>//扩展<br>Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits<br>//把key发送到服务器，看看服务器能不能支持websocket连接<br>Sec-WebSocket-Key: jfnKy0Z2xEaZ0FyWhqWv7A==<br>//声明websocket连接版本<br>Sec-WebSocket-Version: 13<br>//最最重要的是，告诉浏览器，我要协议升级为websocket<br>Upgrade: websocket</p><p>服务器部分,需要用到 net模块<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = net.createServer(<span class="function"><span class="params">sock</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'有人请求连接'</span>);</span><br><span class="line"></span><br><span class="line">  sock.once(<span class="string">'data'</span>, buffer =&gt; &#123;</span><br><span class="line">    <span class="comment">//once表示只执行一次，第一次执行拿到的buffer全部都是请求头数据</span></span><br><span class="line">    <span class="comment">//这里面只需要解析一下请求头，并且返回一个响应头，ws连接就实现了</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).listen(<span class="number">8080</span>)</span><br></pre></td></tr></table></figure></p><p>响应头的result值需要经过一些处理，用到crypto模块进行shal编码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"><span class="comment">// key=&gt;http的请求头里来</span></span><br><span class="line"><span class="comment">// uuid=&gt;'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</span></span><br><span class="line"><span class="comment">// result = base64(shal(key+uuid))</span></span><br><span class="line"><span class="keyword">let</span> hash = crypto.createHash(<span class="string">'shal'</span>);</span><br><span class="line"></span><br><span class="line">hash.update(key+uuid);</span><br><span class="line"><span class="keyword">let</span> result = hash.digest(<span class="string">'base64'</span>);</span><br></pre></td></tr></table></figure><p>最后手写一个响应头发送到浏览器,101状态码表示协议切换，\r\s是http请求的分隔符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sock.write(</span><br><span class="line"><span class="string">`HTTP/1.1 101 Switching Protocols\r\n</span></span><br><span class="line"><span class="string">Upgrade:websocket\r\n</span></span><br><span class="line"><span class="string">Connection:upgrade\r\n</span></span><br><span class="line"><span class="string">Sec-Websocket-Accept:<span class="subst">$&#123;result&#125;</span>\r\n\r\n`</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> WebSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS-数据通信</title>
      <link href="/2019/04/02/NodeJS-%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/"/>
      <url>/2019/04/02/NodeJS-%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<ol style="background: #bdc3c7;    border-radius: 5px;    color: #2980b9;    font-size: 20px;    font-weight: bold;    cursor: pointer;    padding-top: 10px;    padding-bottom: 10px;    text-decoration:none;    line-height:1;    width:80%;    margin:0;    list-style:none"><br>  <li style="list-decoration:none"><a href="#3-1" style="color: #4682BE;text-decoration:none;margin-left:10px">1. Ajax</a></li><br>  <li style="list-decoration:none"><a href="#3-2" style="color: #4682BE;text-decoration:none;margin-left:10px">2. fetch</a></li><br>  <li style="list-decoration:none"><a href="#3-3" style="color: #4682BE;text-decoration:none;margin-left:10px">3. jsonp</a></li><br>  <li style="list-decoration:none"><a href="#3-4" style="color: #4682BE;text-decoration:none;margin-left:10px">4. Ajax2.0</a></li><br></ol><hr><a id="more"></a><h2 id="3-1">Ajax</h2><p>Ajax是不支持跨域的，我们先看看原生的前端代码怎么写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ajax = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">ajax.open(<span class="string">'GET'</span>,<span class="string">'http://localhost:8080/a'</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//第一个参数为请求方式，第二个为请求域名，第三个true表示为异步操作</span></span><br><span class="line">ajax.send();</span><br><span class="line"><span class="comment">//若是POST请求则把数据写在send里面</span></span><br><span class="line"></span><br><span class="line">ajax.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//0:初始化 1：已连接 2：请求已发送 3：响应头已接收 4：响应体已接收 </span></span><br><span class="line">  <span class="keyword">if</span>(ajax.readState == <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ajax.status &gt;= <span class="number">200</span> &amp;&amp; ajax.status &lt; <span class="number">300</span> || ajax.status == <span class="number">304</span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">      <span class="keyword">let</span> json = <span class="built_in">JSON</span>.Parse(ajax.responseText)</span><br><span class="line">      <span class="built_in">console</span>.log(json);</span><br><span class="line">      <span class="comment">//还有个responseXML</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'fail'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于SOP(同源政策),Ajax把请求给浏览器去提交到服务器，而服务器是一定会返回结果(服务器不出错的情况下)给浏览器的，然而考虑到安全的原因，浏览器可以自己分辨响应回来的数据和发送的请求是不是在同一个域下，如果不是，浏览器会把响应丢弃</p><p>前端无法自己跨域，需要服务器来声明一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">'access-control-allow-origin'</span>,<span class="string">'*'</span>);</span><br></pre></td></tr></table></figure><p>当然，服务器不能一股脑所有请求都允许,req.headers对象里面有个origin属性存有请求的域名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> allowOrigin = &#123;</span><br><span class="line">  <span class="string">'http://localhost'</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="string">'http://a.com'</span>:<span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; origin &#125; = req.headers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(allowOrigin[origin])&#123;</span><br><span class="line">  res.setHeader(<span class="string">'access-control-allow-origin'</span>,<span class="string">'*'</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2">fetch</h2><p>fetch是原生的，设计出来的目的是为了取代Ajax(xhr)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">oImg = <span class="built_in">document</span>.querySelectorAll(<span class="string">'img'</span>)[<span class="number">0</span>];</span><br><span class="line">oVideo = <span class="built_in">document</span>.querySelectorAll(<span class="string">'video'</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> fetch(请求的文件路径);<span class="comment">// 1.请求</span></span><br><span class="line">  <span class="comment">// json文件解析</span></span><br><span class="line">  <span class="keyword">let</span> json = <span class="keyword">await</span> res.json()</span><br><span class="line">  <span class="comment">// 文本文件解析</span></span><br><span class="line">  <span class="keyword">let</span> text = <span class="keyword">await</span> res.text();</span><br><span class="line">  <span class="comment">// 二进制文件解析</span></span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">await</span> res.blob();</span><br><span class="line">  <span class="keyword">let</span> url = URL.createObjectURL(data);</span><br><span class="line"></span><br><span class="line">  oImg.src = url;</span><br><span class="line">  oVideo.src = url;</span><br><span class="line">  <span class="comment">//blob()方法会等待所有数据解析完才返回，所以对于video来说很不友好，一般拿来处理图片</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3">jsonp</h2><p>jsonp在Ajax不能跨域的时候很火，由于安全性，现在已经不流行了</p><p>jsonp本质上是script标签，其实就是引用别人js文件来执行你在前端写的代码</p><p>假设有个别人服务器上的js文件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure></p><p>前端上只需要这样写<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(a,b)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(a+b);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://a.com"</span>&gt;</span><span class="undefined">cript&gt;</span></span><br></pre></td></tr></table></figure></p><p>jsonp的原理配合jQuery可以这样写</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  $.ajax(&#123;</span></span><br><span class="line"><span class="actionscript">    url:<span class="string">'https://a.com'</span>,</span></span><br><span class="line"><span class="actionscript">    data: <span class="string">''</span>,<span class="comment">//传送过去的数据</span></span></span><br><span class="line"><span class="actionscript">    dataType: <span class="string">'jsonp'</span>,</span></span><br><span class="line"><span class="actionscript">    jsonp: <span class="string">'add'</span> <span class="comment">//想要触发的回调函数</span></span></span><br><span class="line"><span class="javascript">  &#125;).then(<span class="function">(<span class="params">&#123;s&#125;</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(s);</span></span><br><span class="line"><span class="undefined">  &#125;, res =&gt; &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'fail'</span>);</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-4">Ajax2.0</h2><p>Ajax2.0没有添加很多东西，主要是添加了FormData，它可以把表单数据整个提交</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"form1"</span> <span class="attr">action</span>=<span class="string">"http://localhost:8080/"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    用户：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"user"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"pass"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    文件：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"f1"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> oForm=<span class="built_in">document</span>.querySelector(<span class="string">'#form1'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">oForm.onsubmit=<span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> formdata=<span class="keyword">new</span> FormData(oForm);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">  xhr.open(oForm.method, oForm.action, <span class="literal">true</span>);</span></span><br><span class="line"><span class="undefined">  xhr.send(formdata);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">  xhr.onreadystatechange=<span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">if</span>(xhr.readyState==<span class="number">4</span>)&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">if</span>(ajax.status &gt;= <span class="number">200</span> &amp;&amp; ajax.status &lt; <span class="number">300</span> || ajax.status == <span class="number">304</span>)&#123;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">'success'</span>);</span></span><br><span class="line"><span class="actionscript">      &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">'fail'</span>);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//取消表单默认提交事件</span></span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配合jQuery</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#form1'</span>).on(<span class="string">'submit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> formdata=<span class="keyword">new</span> FormData(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      url: <span class="keyword">this</span>.action,</span><br><span class="line">      type: <span class="keyword">this</span>.method,</span><br><span class="line">      data: formdata,</span><br><span class="line">      processData: <span class="literal">false</span>, <span class="comment">//不让jq自动解析data</span></span><br><span class="line">      contentType: <span class="literal">false</span>  <span class="comment">//不让jq乱改content-type</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">      alert(<span class="string">'success'</span>);</span><br><span class="line">    &#125;, err=&gt;&#123;</span><br><span class="line">      alert(<span class="string">'fail'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//取消表单默认提交事件</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果我们想要自己构建表单，也不是不行，只不过需要手动给formData加东西，比较麻烦</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span></span><br><span class="line">    用户：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"user"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"pass"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    文件：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"f1"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"btn1"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> oBtn=<span class="built_in">document</span>.querySelector(<span class="string">'#btn1'</span>);</span></span><br><span class="line"><span class="actionscript">oBtn.onclick=<span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> formdata=<span class="keyword">new</span> FormData();</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  formdata.append(<span class="string">'username'</span>, <span class="built_in">document</span>.querySelector(<span class="string">'#user'</span>).value);</span></span><br><span class="line"><span class="javascript">  formdata.append(<span class="string">'password'</span>, <span class="built_in">document</span>.querySelector(<span class="string">'#pass'</span>).value);</span></span><br><span class="line"><span class="actionscript">  <span class="comment">//添加文件需要加下标，若是多个文件需要加循环</span></span></span><br><span class="line"><span class="javascript">  formdata.append(<span class="string">'f1'</span>, <span class="built_in">document</span>.querySelector(<span class="string">'#f1'</span>).files[<span class="number">0</span>]); </span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="actionscript">  <span class="comment">//这里不再能用form的属性，需要自己手写</span></span></span><br><span class="line"><span class="actionscript">  xhr.open(<span class="string">'post'</span>, <span class="string">'http://localhost:8080/'</span>, <span class="literal">true</span>); </span></span><br><span class="line"><span class="undefined">  xhr.send(formdata);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">  xhr.onreadystatechange=<span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">if</span>(xhr.readyState==<span class="number">4</span>)&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">if</span>(ajax.status &gt;= <span class="number">200</span> &amp;&amp; ajax.status &lt; <span class="number">300</span> || ajax.status == <span class="number">304</span>)&#123;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">'success'</span>);</span></span><br><span class="line"><span class="actionscript">      &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">'fail'</span>);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;;</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Ajax </tag>
            
            <tag> fetch </tag>
            
            <tag> jsonp </tag>
            
            <tag> Ajax2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS-原生篇2</title>
      <link href="/2019/03/30/NodeJS-%E5%8E%9F%E7%94%9F%E7%AF%872/"/>
      <url>/2019/03/30/NodeJS-%E5%8E%9F%E7%94%9F%E7%AF%872/</url>
      
        <content type="html"><![CDATA[<p><ol style="background: #bdc3c7;    border-radius: 5px;    color: #2980b9;    font-size: 20px;    font-weight: bold;    cursor: pointer;    padding-top: 10px;    padding-bottom: 10px;    text-decoration:none;    line-height:1;    width:80%;    margin:0;    list-style:none"><br>  <li style="list-decoration:none"><a href="#2-1" style="color: #4682BE;text-decoration:none;margin-left:10px">1. fs模块</a></li><br>  <li><a href="#2-2" style="color: #4682BE;text-decoration:none;margin-left:10px">2. querystring模块</a></li><br>  <li><a href="#2-3" style="color: #4682BE;text-decoration:none;margin-left:10px">3. url模块</a></li><br>  <li><a href="#2-4" style="color: #4682BE;text-decoration:none;margin-left:10px">4. multiparty</a></li><br>  <li><a href="#2-5" style="color: #4682BE;text-decoration:none;margin-left:10px">5. 接口应用</a></li><br></ol><br><a id="more"></a></p><h2 id="2-1">fs模块</h2><p>fs模块可以实现文件的操作，在这里，我们主要了解一下fs的两个方法<br><br><br>1.fs.writeFile(path,data,callback(err))，该方法实现文件内容的写入，其回调函数有个err错误对象参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fs.writeFile('</span>./a.txt, <span class="string">'crazy492 is 1bin'</span>, err =&gt; &#123;</span><br><span class="line"> <span class="keyword">if</span>(err)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'失败'</span>,err);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'成功'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2.fs.readFile(path,callback(err,buffer))，该方法是读取文件，其回调函数不仅有个err错误对象参数，还有个buffer数据(二进制数据)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs);</span></span><br><span class="line"><span class="string">fs.readFile('</span>./a.txt, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'失败'</span>,err);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'成功'</span>,data);</span><br><span class="line">    <span class="comment">//data打印出来是一堆buffer数据</span></span><br><span class="line">    <span class="comment">//若该文件只是一些简单的字符串，可以data.toString()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>fs和http搭配的一种应用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server=http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//req.url 是请求的地址</span></span><br><span class="line">  fs.readFile(req.url, (err, buffer)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">      <span class="comment">//发送状态码给浏览器</span></span><br><span class="line">      res.writeHeader(<span class="number">404</span>);</span><br><span class="line">      res.write(<span class="string">'Not Found'</span>);</span><br><span class="line">      res.end();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      res.writeHeader(<span class="number">200</span>);</span><br><span class="line">      res.write(buffer);</span><br><span class="line">      res.end();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><h2 id="2-2">querystring模块</h2><p>get请求数据在url里面，获取url里面的数据可以用querystring</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring);</span></span><br><span class="line"><span class="string">//假设get请求为 localhost:8080/a?username=1bin&amp;password=123456</span></span><br><span class="line"><span class="string">let [url, query] = req.url.split('</span>?<span class="string">');</span></span><br><span class="line"><span class="string">let get = querystring.parse(query);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">console.log(url, get);</span></span><br><span class="line"><span class="string">//url : /a</span></span><br><span class="line"><span class="string">//get : &#123;uername:'</span><span class="number">1</span>bin<span class="string">',password:'</span><span class="number">123456</span><span class="string">'&#125;</span></span><br></pre></td></tr></table></figure><p>get数据都在url里面，可以一次送达服务器，但对于post请求来说，数据都是分批送达的，此时需要将所有buffer整合为一个整体，post的body部分只有数据，可以用querystring模块解决，另外，利用req自带的两个事件，req.on(‘data’)和req.on(‘end),可以解决buffer分批接收整合的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring=<span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr=[];</span><br><span class="line">req.on(<span class="string">'data'</span>, buffer=&gt;&#123;</span><br><span class="line">  arr.push(buffer);</span><br><span class="line">&#125;);</span><br><span class="line">req.on(<span class="string">'end'</span>, ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">let</span> buffer=Buffer.concat(arr);</span><br><span class="line">  <span class="keyword">let</span> post=querystring.parse(buffer.toString());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(post);</span><br><span class="line">  <span class="comment">//post : &#123;uername:'1bin',password:'123456'&#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-3">url模块</h2><p>url模块比querystring模块更方便解析get数据，只需要url.parse(***,true)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url=<span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;pathname, query&#125;=url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//url.parse()第二个参数是true是会自动解析url</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">console</span>.log(pathname, query);</span><br><span class="line"><span class="comment">//pathname : /a</span></span><br><span class="line"><span class="comment">//query : &#123;uername:'1bin',password:'123456'&#125;</span></span><br></pre></td></tr></table></figure><h2 id="2-4">multiparty模块</h2><br>multiparty可以一同处理post的文件请求和普通请求，如果用原生写post文件请求则特别恶心,multiparty模块不是系统自带，需要下载<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> multiparty = <span class="built_in">require</span>(<span class="string">'multiparty'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> form=<span class="keyword">new</span> multiparty.Form(&#123;</span><br><span class="line">  uploadDir: <span class="string">'./upload'</span> <span class="comment">//上传到的地址</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//若上传账号和密码两个字段加一个1.txt文件</span></span><br><span class="line">form.parse(req);<span class="comment">//解析数据</span></span><br><span class="line"><span class="comment">//普通字段</span></span><br><span class="line">form.on(<span class="string">'field'</span>, (name, value)=&gt;&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'字段：'</span>, name, value);   </span><br><span class="line">  <span class="comment">// 字段： username 1bin</span></span><br><span class="line">  <span class="comment">// 字段： password 123456</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//文件上传</span></span><br><span class="line">form.on(<span class="string">'file'</span>, (name, file)=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'文件：'</span>, name, file);</span><br><span class="line">  <span class="comment">// 文件： f1 &#123; fieldName: 'f1',</span></span><br><span class="line">  <span class="comment">//   originalFilename: '1.txt',</span></span><br><span class="line">  <span class="comment">//   path: 'upload\\T8w1Kiny20fNsWDlVPgaJ9iJ.txt',</span></span><br><span class="line">  <span class="comment">//   headers:</span></span><br><span class="line">  <span class="comment">//    &#123; 'content-disposition': 'form-data; name="f1"; filename="1.txt"',</span></span><br><span class="line">  <span class="comment">//      'content-type': 'text/plain' &#125;,</span></span><br><span class="line">  <span class="comment">//   size: 0 &#125;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//表单解析完成</span></span><br><span class="line">form.on(<span class="string">'close'</span>, ()=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'表单解析完成'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">req.on(<span class="string">'error'</span>, err =&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><br>假设post上传文件，前端表单enctype需要设置为”multipart/form-data”，<br><br><h2 id="2-5">接口应用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> path =<span class="string">''</span> , get =&#123;&#125;, post =&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(req.method == <span class="string">'GET'</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;pathname, query&#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    path = pathname;</span><br><span class="line">    get = query;</span><br><span class="line">    afterGetData()</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(req.method == <span class="string">'POST'</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> arr =[];</span><br><span class="line"></span><br><span class="line">    req.on(<span class="string">'data'</span>, buffer =&gt;&#123;</span><br><span class="line">      arr.push(buffer);</span><br><span class="line">    &#125;);</span><br><span class="line">    req.on(<span class="string">'end'</span>, () =&gt;&#123;</span><br><span class="line">      <span class="keyword">let</span> buffer = Buffer.concat(arr);</span><br><span class="line">      </span><br><span class="line">      post = querystring.parse(buffer.toString());</span><br><span class="line">      path = req.url;</span><br><span class="line">      <span class="comment">//post的url就是地址</span></span><br><span class="line">      afterGetData();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//设置拿到数据后的回调函数，在这里只区分了两个接口/reg和/login，以及文件请求</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">afterGetData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(path == <span class="string">'/reg'</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(path == <span class="string">'/login'</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//www 为默认文件请求文件夹</span></span><br><span class="line">      fs.readFile(<span class="string">`www<span class="subst">$&#123;path&#125;</span>`</span>, (err, buffer) =&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">          res.writeHeader(<span class="number">404</span>);</span><br><span class="line">          res.write(<span class="string">'NOT FOUND'</span>);</span><br><span class="line">          res.end();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          res.write(buffer);</span><br><span class="line">          res.end();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><p>以上用NodeJS原生自带的模块实现了get/post请求以及文件操作，此外有个favicon.ico请求经常出现，此为goole浏览器申请网页图标的请求，而对于post上传文件参考上面的multiparty模块</p>]]></content>
      
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS-原生篇1</title>
      <link href="/2019/03/29/NodeJS-%E5%8E%9F%E7%94%9F%E7%AF%871/"/>
      <url>/2019/03/29/NodeJS-%E5%8E%9F%E7%94%9F%E7%AF%871/</url>
      
        <content type="html"><![CDATA[<ol style="background: #bdc3c7;    border-radius: 5px;    color: #2980b9;    font-size: 20px;    font-weight: bold;    cursor: pointer;    padding-top: 10px;    padding-bottom: 10px;    text-decoration:none;    line-height:1;    width:80%;    margin:0;    list-style:none"><br>  <li style="list-decoration:none"><a href="#1-1" style="color: #4682BE;text-decoration:none;margin-left:10px">1. assert模块</a></li><br>  <li style="list-decoration:none"><a href="#1-2" style="color: #4682BE;text-decoration:none;margin-left:10px">2. path模块</a></li><br>  <li style="list-decoration:none"><a href="#1-3" style="color: #4682BE;text-decoration:none;margin-left:10px">3. url模块</a></li><br>  <li style="list-decoration:none"><a href="#1-4" style="color: #4682BE;text-decoration:none;margin-left:10px">4. querystring模块</a></li><br>  <li style="list-decoration:none"><a href="#1-5" style="color: #4682BE;text-decoration:none;margin-left:10px">5. net模块</a></li><br>  <li style="list-decoration:none"><a href="#1-6" style="color: #4682BE;text-decoration:none;margin-left:10px">6. http模块</a></li><br></ol><a id="more"></a><p>  学习NodeJS，其实是学习一些服务器，数据库知识，以及一些模块(中间件)调用的方法，本文就先从NodeJS的一些常用系统自带模块讲起</p><hr><h2 id="1-1">assert模块</h2><p>断言，在函数调用前使用，可确保参数如预期</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</span><br><span class="line"></span><br><span class="line">assert(<span class="number">1</span>&gt;<span class="number">2</span>,<span class="string">'no!'</span>); <span class="comment">// no！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//assert.deepEqual(变量，预期值，msg);</span></span><br><span class="line"><span class="comment">//相当于 ==</span></span><br><span class="line"><span class="comment">//assert.deepStrictEqual(变量，预期值，msg);</span></span><br><span class="line"><span class="comment">//相当于 ===</span></span><br></pre></td></tr></table></figure><h2 id="1-2">path模块</h2><p>路径，帮助我们做路径拼装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path =<span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'/root/a/b/c/1.html'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(path.dirname(str)); <span class="comment">//  /root/a/b/c</span></span><br><span class="line"><span class="built_in">console</span>.log(path.extname(str)); <span class="comment">//  .html</span></span><br><span class="line"><span class="built_in">console</span>.log(path.basename(str)); <span class="comment">//  1.html</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(__dirname,<span class="string">'1.txt'</span>));</span><br><span class="line"><span class="comment">//path.resolve()是做路径拼接处理的， __dirname是魔术变量，值为当前文件绝对路径</span></span><br></pre></td></tr></table></figure><h2 id="1-3">url模块</h2><p>url的解析和拼接<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str=<span class="string">'http://www.1bin.com:8080/a/b/1.html?a=1&amp;a=2&amp;a=3'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(url.parse(str));</span><br><span class="line"><span class="comment">// Url &#123;  protocol: 'http:',</span></span><br><span class="line"><span class="comment">// slashes: true,</span></span><br><span class="line"><span class="comment">// auth: null,</span></span><br><span class="line"><span class="comment">// host: 'www.1bin.com:8080',</span></span><br><span class="line"><span class="comment">// port: '8080',</span></span><br><span class="line"><span class="comment">// hostname: 'www.1bin.com',</span></span><br><span class="line"><span class="comment">// hash: null,</span></span><br><span class="line"><span class="comment">// search: '?a=1&amp;a=2&amp;a=3',</span></span><br><span class="line"><span class="comment">// query: 'a=1&amp;a=2&amp;a=3',</span></span><br><span class="line"><span class="comment">// pathname: '/a/b/1.html',</span></span><br><span class="line"><span class="comment">// path: '/a/b/1.html?a=1&amp;a=2&amp;a=3',</span></span><br><span class="line"><span class="comment">// href: 'http://www.bing.com:8080/a/b/1.html?a=1&amp;a=2&amp;a=3' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(url.parse(str, <span class="literal">true</span>));</span><br><span class="line"><span class="comment">//加了true后会自动帮你把query解析成&#123; a: [ '1', '2', '3' ] &#125;</span></span><br><span class="line"><span class="comment">//这里a为数组的原因是url解析会帮你把重复变量整合成一个数组</span></span><br></pre></td></tr></table></figure></p><h2 id="1-4">querystring模块</h2><p>数据解析<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//parse stringify 就是数据解析与反向操作</span></span><br><span class="line"><span class="built_in">console</span>.log(querystring.parse(<span class="string">"a=1&amp;b=2&amp;c=3"</span>));</span><br><span class="line"><span class="comment">// &#123; a: '1', b: '2', c: '3' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(querystring.stringify(&#123;<span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">1</span>&#125;));</span><br><span class="line"><span class="comment">// a=3&amp;b=2&amp;c=1</span></span><br></pre></td></tr></table></figure></p><h2 id="1-5">net模块</h2><p>相当于tcp协议node的实现，是http模块的超集，应用于websocket，此处暂且不谈</p><h2 id="1-6">http模块</h2><p>  http模块是实现原生NodeJS服务器链接的一个模块，主要使用方式为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'request:'</span>,req);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'response:'</span>,res);</span><br><span class="line">&#125;).listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><p>  上面的代码，实现了在本机8080端口创立服务器的功能，其中createServer方法有两个参数req，res</p><p>  把这两个参数打印出来，会发现是一个有一大堆属性的对象，在这里，我们看看一些比较重要的属性方法</p><ul><li>res.write()可以把字符串或者buffer(不能发json,可用JSON.stringify())发给服务器</li><li>res.end()是结束此次与服务器的请求，值得一提的是，write后必须要end，否则浏览器不会断开请求链接，你将接受不到服务器的响应，在浏览器界面上显示为左上角刷新圈圈一直在转。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件循环</title>
      <link href="/2018/11/10/Event%20Loop/"/>
      <url>/2018/11/10/Event%20Loop/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  从 JavaScript 诞生以来，JavaScript 就被设计为<strong>单线程</strong>且<strong>永不阻塞</strong>的脚本语言。</p><a id="more"></a><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>  JavaScript 代码在任何时候都只有一个主线程处理所有的任务。</p><p>  设计为单线程的原因主要是 JavaScript 是与浏览器交互的语言，需要完成一些 DOM 操作。若将 JavaScript 设计为多线程，则可能发生下面这种情况：</p><p>  第一个线程创造了 DOM 结点，并进行了相应的 DOM 操作。<br>  第二个线程删除了该 DOM 结点。<br>  此时就遇到问题了，该 DOM 结点该如何存在？毁灭还是新生？</p><p>  因此 JavaScript 要设计成单线程。</p><p>  可是，单线程注定会限制 JavaScript 的效率，因此开发了 <strong>Web Worker</strong> 技术，该技术号称能将 JavaScript 变为多线程的语言。</p><p>  然而，该技术所开发的多线程有很多限制，例如所有新线程必须在主线程的完全控制下，不能独立执行，对于 I/O 操作，新线程更是没有这个权限进行。严格来说，<strong>Web Worker</strong> 技术并没有改变 JavaScript 是单线程的语言的实质。可以预见，JavaScript 在未来也只能是单线程的。</p><h2 id="永不阻塞"><a href="#永不阻塞" class="headerlink" title="永不阻塞"></a>永不阻塞</h2><p>  当代码中有异步任务(无法立刻返回结果的任务，如 I/O 事件),主线程可以暂时挂起该任务,然后在异步任务返回结果后再执行相应回调函数。</p><hr><h1 id="任务队列-task-queue"><a href="#任务队列-task-queue" class="headerlink" title="任务队列(task queue)"></a>任务队列(task queue)</h1><p>单线程的 JavaScript 意味着任务需要一个个来实现，若前一个任务耗时很长，后面的任务就不得不等待。</p><p>于是乎，JavaScript 的设计者意识到，如果将 I/O 操作等耗时长的任务先挂起，先运行后面的任务，等 I/O 操作等耗时长的任务返回了结果，再回头把挂起的任务完成，岂不美哉？</p><p>因此，所有任务可以分为两种，一是<strong>同步任务</strong>，另一种是<strong>异步任务</strong>。</p><p><strong>同步任务</strong>指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。</p><p><strong>异步任务</strong>指的是，不进入主线程、而进入<strong>任务队列</strong>的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p><p>异步任务必须指定<strong>回调函数</strong>，所谓回调函数，就是会被主线程挂起来的那些代码。所谓执行异步任务。就是执行其对应的回调函数。</p><p>任务队列是个 FIFO 的数据结构，一旦主线程的任务栈中所有同步任务执行完成，任务队列中的第一个任务就会被添加到主线程。</p><hr><h1 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环(Event Loop)"></a>事件循环(Event Loop)</h1><p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop。</p><p>加入到任务队列的异步任务其实分为两种，一是宏任务，二是微任务。</p><h2 id="宏任务-macro-task-amp-微任务-micro-task"><a href="#宏任务-macro-task-amp-微任务-micro-task" class="headerlink" title="宏任务(macro task) &amp; 微任务(micro task)"></a>宏任务(macro task) &amp; 微任务(micro task)</h2><p>异步任务也有优先级，微任务高于宏任务。</p><p>以下事件属于宏任务：</p><ul><li>setTimeout()</li><li>setInterval()</li></ul><p>以下事件属于微任务：</p><ul><li>new Promise()</li></ul><p>当主线程任务栈为空时，主线程会先处理微任务队列，当微任务队列也为空时，主线程再去处理宏任务队列。</p><p>而 setTimeout 第二个延迟参数的意义，是指主线程所有同步任务，以及微任务队列所有异步任务都完成后，再生效的延迟时间。</p><p>最后附上一道题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>按照上面的理解，setTimeout 就是作为宏任务来存在的，而 Promise.then 则是具有代表性的微任务，上述代码的执行顺序就是按照序号来输出的。</p><p>就是说 new Promise 在实例化的过程中所执行的代码都是同步进行的，而then中注册的回调才是异步执行的。回调函数，才能进入异步。</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 事件循环 </tag>
            
            <tag> 任务队列 </tag>
            
            <tag> 宏任务与微任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-router</title>
      <link href="/2018/11/08/vue-router/"/>
      <url>/2018/11/08/vue-router/</url>
      
        <content type="html"><![CDATA[<hr><p>Vue 路由用于网页跳转，相较于 a 标签，路由的优势在于不用网页刷新，不用重新进行网页请求，便可以实现组件间的跳转，从而达到网页无刷新跳转的效果。</p><a id="more"></a><hr><h1 id="安装-vue-router-模块"><a href="#安装-vue-router-模块" class="headerlink" title="安装 vue-router 模块"></a>安装 vue-router 模块</h1><p>首先默认已经自行安装配置好基本的Vue的webpack打包工具<br>可以在 package.json 文件里面的 dependencies （或 devDependencies） 查看 vue-router 是否安装好，以及安装的版本。</p><p>若无安装可在终端内输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router --save</span><br></pre></td></tr></table></figure></p><p><strong>tips：简单区别 –save 和 –save-dev</strong></p><p> –save ：将依赖的模块添加到 dependencies 下，这是项目在发布后需要依赖的模块。<br> –save-dev : 将依赖的模块添加到 devDependencies 下，这是项目在开发过程中才需要依赖的模块。</p><hr><h1 id="实例化-VueRouter-对象"><a href="#实例化-VueRouter-对象" class="headerlink" title="实例化 VueRouter 对象"></a>实例化 VueRouter 对象</h1><p>在 main.js 下,首先引入并使用路由模块。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure></p><p>接着便是实例化 VueRouter 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes:[</span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">"/"</span>,<span class="attr">component</span>:Home&#125;,  <span class="comment">// 默认的首页</span></span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">"/helloworld"</span>,<span class="attr">component</span>:HelloWorld&#125;,</span><br><span class="line">  ],</span><br><span class="line">  mode:<span class="string">"history"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>routes 是路由数组，基本的数组成员就是有 path 和 component 两种属性的对象。值得注意的是，这里需要 import Home 和 HelloWorld 的模板</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">'./components/HelloWorld'</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./components/Home'</span></span><br></pre></td></tr></table></figure><p>mode:”history” 可将 # 号省略掉，避免造成路径的混乱.</p><p>最后在 Vue 实例对象内使用 router。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router, <span class="comment">//需要在 Vue 实例中使用 router</span></span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><hr><h1 id="使用-router-view-，router-link"><a href="#使用-router-view-，router-link" class="headerlink" title="使用 router-view ，router-link"></a>使用 router-view ，router-link</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/helloworld"</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>router-view 相当于 routers 容器，所有路由跳转的现实都在这个标签内。</p><p>router-link 相当于 a 标签的作用 ，to 后面写相对应路由。</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Vue-router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise</title>
      <link href="/2018/10/27/%E5%BC%82%E6%AD%A5Promise/"/>
      <url>/2018/10/27/%E5%BC%82%E6%AD%A5Promise/</url>
      
        <content type="html"><![CDATA[<hr><p>  ES6提供了Promise对象，用来实现异步编程。</p><p>  传统的异步编程解决方案是<strong>回调函数和事件</strong>，通过不断嵌套回调函数实现逻辑上的异步，而这样的写法无疑是很复杂的，代码也很难维护。</p><a id="more"></a><hr><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><p>  一个 Promise 有以下几种状态：</p><p>  (1) pending：初始状态，既不是成功，也不是失败状态。</p><p>  (2) fulfilled：意味着操作成功完成。</p><p>  (3) rejected：意味着操作失败。</p><p>  Promise 对象的 then 方法包含两个参数：</p><p>  onfulfilled 和 onrejected，它们都是 Function 类型</p><p>  Promise 对象的参数函数是两个由 JavaScript 引擎提供的函数 resolve 和 reject</p><p>  resolve 和 reject 函数被调用时，分别将 Promise 的状态改为 fulfilled（完成）或 rejected（失败）</p><p>  当 Promise 状态为 fulfilled 时，调用 then 的 onfulfilled方法，当 Promise 状态为 rejected 时，调用 then 的 onrejected 方法</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...一些立即执行的代码</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="comment">/*异步操作成功*/</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//success code resolve</span></span><br><span class="line">&#125;,err =&gt; &#123;</span><br><span class="line">  <span class="comment">// failure code reject</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>  ES6 规定，Promise 对象是一个构造函数，用来生成Promise 实例。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>); <span class="comment">//立即执行</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> resolve(<span class="string">'resolve'</span>);</span><br><span class="line">     &#125;,<span class="number">1000</span>)</span><br><span class="line">  &#125;); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">  promise().then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hey'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Console</span></span><br><span class="line"><span class="comment">  promise</span></span><br><span class="line"><span class="comment">  Hey</span></span><br><span class="line"><span class="comment">  resolve</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>  Promise 新建后就会立即执行，故先输出 promise</p><p>  then 方法指定的回调函数，就在当前所有同步任务执行完才会执行，所以最后输出 resolve</p><hr><h1 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h1><p>  then 方法的第一个参数是 resolved 状态的回调函数，第二个参数（可选）是 rejected 状态的回调函数</p><p>  then 方法返回的是一个新的 Promise 实例（注意，不是原来那个 Promise 实例）。因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> resolve(<span class="number">2</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">promise()</span><br><span class="line">.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> val; </span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    val++;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Console</span></span><br><span class="line"><span class="comment">  1</span></span><br><span class="line"><span class="comment">  2</span></span><br><span class="line"><span class="comment">  3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>  在 then 方法中的返回值作为参数，传入下一个回调函数。</p><p>  如果 then 回调函数返回一个值，那么 then 返回的 Promise 对象将会成为接受状态，并接受该值作为接受状态的回调函数的参数值。</p><p>  同理 then 回调函数抛出一个错误，那么 then 返回的Promise 对象将成为接受状态，并且将抛出的错误作为拒绝状态的回调函数的参数值。</p><hr><h1 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h1><p>  catch 方法返回一个Promise，并且处理拒绝的情况。</p><p>  它的行为与调用Promise.prototype.then(undefined, onRejected) 相同。</p><p>  Promise 对象的状态一旦变为 rejected ，便不可以再改变，此时便会调用 catch 方法指定的回调函数，此外， then 方法指定的回调函数若在运行中抛出错误，也会被 catch 方法捕获</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/*success*/</span>)&#123;</span><br><span class="line">      resolve(<span class="string">'success'</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      reject(<span class="string">'error'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">promise()</span><br><span class="line">.then( <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//success</span></span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/*error*/</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>  Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。</p><p>  Promise 对象抛出的错误不会传递到外层代码，故要使用 catch 方法来捕获 Promise 对象内部抛出的错误。</p><hr><h1 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h1><p>  finally 方法返回一个 Promise，在执行 then 和catch 后，都会执行finally指定的回调函数。</p><p>  实际上，finally 与 .then(onFinally, onFinally) 类似，但也有一些区别。</p><p>  finally 不接受任何参数。并且 finally 方法总是会返回原来的值。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// resolve 的值是 undefined</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">2</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, () =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve 的值是 2</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">2</span>).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject 的值是 undefined</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">3</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, () =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject 的值是 3</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">3</span>).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><hr><h1 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h1><p>  将现有对象转为 Promise 对象</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//等价为</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>  其参数有四种情况：</p><p>  (1) 不带任何参数</p><p>  直接返回一个 resolved 状态的 Promise 对象</p><p>  (2) 参数不为对象，或者是不具有 then 方法的对象</p><p>  返回一个新的状态为 resolved 的 Promise 对象，此时会立即执行回调函数。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val) ;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//会立刻弹出 1</span></span><br></pre></td></tr></table></figure><p>  (3) 参数是一个thenable对象</p><p>  thenable 对象指的是具有 then 方法的对象，Promise.resolve 方法会将这个对象转为 Promise 对象，然后就立即执行 thenable 对象的 then 方法。</p><p>  (4) 参数是一个 Promise 实例</p><p>  不做任何修改，原封不动的返回这个实例。</p><hr><h1 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h1><p>  Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。</p><p>  该方法和 Promise.resolve 方法类似，但 Promise.reject() 方法的参数，会原封不动的作为reject 的理由，变为后续方法的参数。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">  then(resolve,reject)&#123;</span><br><span class="line">    reject(<span class="string">'error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject(thenable)</span><br><span class="line">.catch( <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err === thenable); <span class="comment">// true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>  上面代码中，Promise.reject 方法的参数是一个 thenable 对象，执行以后，后面 catch 方法的参数不是 reject 抛出的 ‘error’ 这个字符串，而是 thenable 对象</p><hr><h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h1><p>  Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><p>  Promise.all 方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="number">2</span>; <span class="comment">//Promise.all 里面将调用 Promise.resolve</span></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve(<span class="number">3</span>), <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p = [p1, p2, p3];</span><br><span class="line"><span class="built_in">Promise</span>.all(p)</span><br><span class="line">.then(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*Console</span></span><br><span class="line"><span class="comment">  [1,2,3]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>  上面代码中，p的状态有两种情况：</p><p>  (1) 只有p1、p2、p3 的状态都变成 fulfilled，p的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给p的回调函数。</p><p>  (2) 只要p1、p2、p3之中有一个被 rejected，p的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给p的回调函数。</p><p>  如果作为参数的 Promise 实例，自己定义了 catch 方法，那么它一旦被 rejected，并不会触发 Promise.all() 的 catch 方法。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">'p1 error!'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'p2 error!'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p2 catch '</span> + err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1,p2])</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'all catch '</span> + err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Console</span></span><br><span class="line"><span class="comment">p2 catch Error: p2 error!</span></span><br><span class="line"><span class="comment">all catch p1 error!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h1><p>  Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [p1, p2, p3] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1,p2,p3]);</span><br></pre></td></tr></table></figure><p>  上面代码中，只要 p1, p2, p3 之中有一个实例率先改变状态， p的状态就跟着改变，并将率先改变的 Promise 实例作为返回值， 传递给p的回调函数。</p><p>  同样，若参数不是 Promise 实例，则将先调用 Promise.resolve 方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解构赋值</title>
      <link href="/2018/10/13/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
      <url>/2018/10/13/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<div style="background-color:#bdc3c7; width:100%;padding:10px 20px ;margin:0 auto;color:white"><br>    <a style="color:white ;display:block;text-decoration:none;border:none" href="#1">1. 数组的解构赋值</a><br>    <a style="color:white;display:block;text-decoration:none;border:none" href="#2">2. 对象的解构赋值</a><br>    <a style="color:white;display:block;text-decoration:none;border:none" href="#3">3. 字符串的解构赋值</a><br>    <a style="color:white;display:block;text-decoration:none;border:none" href="#4">4. 数值和布尔值的解构赋值</a><br>    <a style="color:white;display:block;text-decoration:none;border:none" href="#5">5. 函数参数的解构赋值</a><br>    <a style="color:white;display:block;text-decoration:none;border:none" href="#6">6. 圆括号问题</a><br>    <a style="color:white;display:block;text-decoration:none;border:none" href="#7">7. 用途</a><br></div><div style="width:100%;height:2px;background-color:black;margin:10px 0;"></div><a id="more"></a><p>本文参考网址:<a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/destructuring</a></p><h1 id="1">1. 数组的解构赋值</h1><h2 id="1.1">1.1 基本用法</h2><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构</p><p>ES6之前，为了给变量赋值，只能直接指定值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> c = &#123;<span class="attr">foo</span>:<span class="number">1</span>,<span class="attr">bar</span>:<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><p>而在ES6中，则允许这样赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, [<span class="number">1</span>,<span class="number">2</span>], &#123;<span class="attr">foo</span>:<span class="number">1</span>,<span class="attr">bar</span>:<span class="number">2</span>&#125; ] ;</span><br></pre></td></tr></table></figure><p>上面代码很清晰的展示了所谓的解构赋值，就是按照相对应的位置，对变量赋值</p><p>实际上，这种赋值方式属于模式匹配，当等号两边的模式相同时，左边的变量便会被赋值为相对应的值</p><p>下面附上一些数组的解构赋值例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, , c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">c <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, , <span class="number">3</span>]; </span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// undefined</span></span><br><span class="line">c <span class="comment">// 3  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]]; </span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">c <span class="comment">// 3 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊的解构符号 '...'</span></span><br><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] ;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// [2,3,4]</span></span><br></pre></td></tr></table></figure><p>如果解构不成功，变量的值为<i>undefined</i></p><p>下面附上一些数组的解构赋值不完全(部分变量解构不成功)的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a] = [];</span><br><span class="line">a <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, b] = [<span class="number">1</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊的解构符号 '...'</span></span><br><span class="line"><span class="keyword">let</span> [a, b, ...c] = [<span class="number">1</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// undefined</span></span><br><span class="line">c <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>当然，不完全解构，也还有另外一种情况，那就是等号左边的模式，只匹配一部分的等号右边的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, b, [c]] = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">c <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果等号右边不是数组(或者说时不可以遍历的解构)，则会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下代码会报错</span></span><br><span class="line"><span class="keyword">let</span> [a] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> [a] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> [a] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> [a] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [a] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> [a] = &#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="1.2">1.2 默认值</h2><p>解构赋值允许为变量指定默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>] = [] ;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, b = <span class="number">2</span>] = [<span class="number">1</span>]</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">&lt;!-- 上面代码等效于下面代码 --&gt;</span><br><span class="line"><span class="keyword">let</span> [a, b = <span class="number">2</span>] = [<span class="number">1</span>, <span class="literal">undefined</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>ES6内部使用全等符号 ‘===’ 判断一个位置是否有值。故，只有一个数组成员严格等于undefined时，默认值才会生效</p><p>默认值也可以为表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [ a = f() ] = [];</span><br><span class="line">a <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>默认值可以引用解构赋值的其他变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b = a] = [];     <span class="comment">// a=1; b=1</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b = a] = [<span class="number">2</span>];    <span class="comment">// a=2; b=2</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b = a] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// a=1; b=2</span></span><br><span class="line"><span class="keyword">let</span> [a = b, b = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError: b is not defined</span></span><br><span class="line"><span class="comment">//报错原因是a用b做默认值时，b还没有声明</span></span><br></pre></td></tr></table></figure><p>再次强调，默认值只有当数组成员严格等于undefined时，才会调用</p><h1 id="2">对象的解构赋值</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b&#125; = &#123;<span class="attr">a</span>: <span class="number">1</span> , <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>对象的解构与数组有一个重要的不同</p><p>数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;b, a&#125; = &#123;<span class="attr">a</span>:<span class="number">1</span> ,<span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br><span class="line">a <span class="comment">// 1 </span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;c&#125; = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br><span class="line">c <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如变量名与属性名不一致，则必须写成下面这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span> : a&#125; = &#123;<span class="attr">foo</span> : <span class="number">1</span>, <span class="attr">a</span>:<span class="number">2</span>&#125;;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">foo <span class="comment">// foo is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">first</span> : a, <span class="attr">last</span> : b&#125; = &#123; <span class="attr">first</span> : <span class="number">1</span>, <span class="attr">last</span> : <span class="number">2</span>&#125;;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>实际上，对象的解构赋值是下面形式的简写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>:a, <span class="attr">b</span>:b&#125; = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><p>也就是说，对象的解构赋值内部机制，是先找到同名属性，再给赋值给相对应的变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span> : a&#125; = &#123;<span class="attr">foo</span> : <span class="number">1</span>, <span class="attr">a</span>:<span class="number">2</span>&#125;;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">foo <span class="comment">// foo is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，foo是匹配的模式，a才是变量</p><p>再举一个解构用于嵌套结构的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    p: [</span><br><span class="line">        <span class="string">'Hello'</span>,</span><br><span class="line">        &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// "Hello"</span></span><br><span class="line">y <span class="comment">// "World"</span></span><br></pre></td></tr></table></figure><p>这里的p是模式，不是变量。若需要将p作为变量赋值，可以写成下面这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; p, <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// "Hello"</span></span><br><span class="line">y <span class="comment">// "World"</span></span><br><span class="line">p <span class="comment">// ["Hello", &#123;y: "World"&#125;]</span></span><br></pre></td></tr></table></figure><p>同样，对象的解构也可以指定默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;</span><br><span class="line">y <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>默认值生效的条件，是对象的属性值严格等于<i>undefined</i></p><p>如果解构失败，变量的值等于undefined</p><p>如果要将已经声明的变量用于解构赋值，必须非常小心</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure><p>上面代码的写法之所以会报错，是因为JavaScript引擎会将{x}理解为一个代码块，从而发生语法错误</p><p>故不能将大括号写在行首,我们可以加一个圆括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><h1 id="3">3. 字符串的解构赋值</h1><p><br>字符串也可以解构赋值。因为此时，字符串被转换成了一个类似数组的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'Hello'</span>;</span><br><span class="line">a <span class="comment">// 'H'</span></span><br><span class="line">b <span class="comment">// 'e'</span></span><br><span class="line">c <span class="comment">// 'l'</span></span><br><span class="line">d <span class="comment">// 'l'</span></span><br><span class="line">e <span class="comment">// 'o'</span></span><br></pre></td></tr></table></figure><p>类似数组对象的<i>length</i>属性,可以对字符串的这个属性解构赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span>: len&#125; = <span class="string">'Hello'</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h1 id="4">4. 数值和布尔值的解构赋值</h1><p><br>解构赋值时，若等号右边是数值和布尔值，则会先转为对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，数值和布尔值的包装对象都有toString属性，故变量s都能取到值</p><p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined 和 null 无法转为对象，所以对它们解构赋值都会报错</p><h1 id="5">函数参数的解构赋值</h1><p><br>函数参数也可以使用解构赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y</p><p>可以为函数参数指定默认值</p><h1 id="6">圆括号问题</h1><p><br>解构赋值虽然方便了我们，但编译器解析起来并不容易，一个式子到底是模式，还是表达式，没办法一开始就知道。故ES6规则是，只要有可能导致解构的歧义，就不得使用圆括号</p><h2 id="6.1">不能使用圆括号的情况</h2><ol><li>变量声明语句</li></ol><p>变量声明语句，模式不能使用圆括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line">    <span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> &#123; <span class="attr">o</span>: (&#123; <span class="attr">p</span>: p &#125;) &#125; = &#123; <span class="attr">o</span>: &#123; <span class="attr">p</span>: <span class="number">2</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>函数参数</li></ol><p>函数参数也属于变量声明，因此不能带有圆括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[(z</span>)]) </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[z,(x</span>)]) </span>&#123; <span class="keyword">return</span> x; &#125;</span><br></pre></td></tr></table></figure><p>3.赋值语句的模式</p><p>下面代码将整个模式放在圆括号之中，导致报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line">(&#123; <span class="attr">p</span>: a &#125;) = &#123; <span class="attr">p</span>: <span class="number">42</span> &#125;;</span><br><span class="line">([a]) = [<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>下面代码将一部分模式放在圆括号之中，导致报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line">[(&#123; <span class="attr">p</span>: a &#125;), &#123; <span class="attr">x</span>: c &#125;] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure><h2 id="6.2">可以使用圆括号的情况</h2><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。</p><h1 id="7.1">用途</h1><h2>1. 交换变量的值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure><h2>2. 从函数返回多个值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        foo: <span class="number">1</span>,</span><br><span class="line">        bar: <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure><h2>3. 函数参数的定义</h2><p>解构赋值可以方便地将一组参数与变量名对应起来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><h2>4. 提取JSON数据</h2><p>解构赋值对提取 JSON 对象中的数据，尤其有用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">    id: <span class="number">42</span>,</span><br><span class="line">    status: <span class="string">"OK"</span>,</span><br><span class="line">    data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, "OK", [867, 5309]</span></span><br></pre></td></tr></table></figure><h2>5. 函数参数的默认值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">    beforeSend = function (</span>) </span>&#123;&#125;,</span><br><span class="line">    cache = <span class="literal">true</span>,</span><br><span class="line">    complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    crossDomain = <span class="literal">false</span>,</span><br><span class="line">    global = <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// ... more config</span></span><br><span class="line">&#125; = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2>6. 输入模块的指定方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;sin, cos, log&#125; = <span class="built_in">Math</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 解构赋值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js</title>
      <link href="/2018/10/06/Vue.js/"/>
      <url>/2018/10/06/Vue.js/</url>
      
        <content type="html"><![CDATA[<hr><p>前言：几天前尤雨溪介绍了即将发表的 Vue 3.0 版本，3.0版本的概要是除了渲染函数 API 和作用域插槽语法之外的所有内容都将保持不变，或者通过兼容性构建让其与 2.x 保持兼容。此文章是基于 Vue 2.x 版本写的初入门文章,主要针对Vue基础语法，模板，组件等所作的笔记。</p><a id="more"></a><hr><h1>1. Vue对象</h1>  <p>Vue.js是javaScript的框架</p><hr><h2 id="1-1-Vue-根-对象中的选项"><a href="#1-1-Vue-根-对象中的选项" class="headerlink" title="1.1 Vue(根)对象中的选项"></a>1.1 Vue(根)对象中的选项</h2><p>实例化Vue根对象时</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue()&#123;</span><br><span class="line">    el:<span class="string">"#app"</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        name:<span class="string">"1 bin"</span></span><br><span class="line">    &#125;,<span class="comment">//name 为可以调用的属性 ，vm.name 调用</span></span><br><span class="line">    methods:&#123;</span><br><span class="line">        greet: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Hello Vue!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="comment">//greet() 为方法，调用时要加括号 ，vm.greet() 调用</span></span><br><span class="line">    computed：&#123;</span><br><span class="line">        greetName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Hello"</span>+<span class="keyword">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;，<span class="comment">//greetName 为计算属性，是可以调用的属性 ，vm.greetName 调用</span></span><br><span class="line">    watch:&#123;</span><br><span class="line">        name: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Hello"</span>+<span class="keyword">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">//监听器不会产生新的属性，只是在原有属性变化时调用方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p></p><h3>el</h3><br>  Vue根组件中属性，值为html根容器元素<p></p></li><li><p></p><h3>data</h3><br>  用于各种数据的储存，是键值对对象<p></p></li><li><p></p><h3>methods</h3><br>  用于各种方法的储存，如其中一种方法被调用，则其他方法也会被调用，比较耗费性能，不设置缓存。<p></p></li><li><p></p><h3>computed</h3><br>  计算属性是基于它们的依赖进行缓存的，只有它们的依赖改变了，计算属性才会重新求值，这就意味着若依赖值没有变，计算属性将立刻返回之前的缓存值。<p></p></li><li><p></p><h3>watch</h3><br>  监听器，用来响应数据的变化，当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。<p></p></li></ul><hr><h2 id="1-2-Vue生命周期-钩子函数"><a href="#1-2-Vue生命周期-钩子函数" class="headerlink" title="1.2 Vue生命周期(钩子函数)"></a>1.2 Vue生命周期(钩子函数)</h2><p>钩子函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">""</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    beforeCreate:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"组件实例化之前执行的函数"</span>)；</span><br><span class="line">    &#125;，</span><br><span class="line">    created：<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"组件实例化完毕，但页面还未显示"</span>)；</span><br><span class="line">    &#125;，</span><br><span class="line">    beforeMount：<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"组件挂在前，页面仍未显示，但虚拟Dom已经配置"</span>)；</span><br><span class="line">    &#125;，</span><br><span class="line">    mounted：<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"组件挂在后，此方法执行后，页面显示"</span>)；</span><br><span class="line">    &#125;，</span><br><span class="line">    beforeUpdate:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"组件更新前，页面仍未更新，但虚拟Dom已经配置"</span>)；</span><br><span class="line">    &#125;，</span><br><span class="line">    updated:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"组件更新，页面显示"</span>)；</span><br><span class="line">    &#125;，</span><br><span class="line">    beforeDestory:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"组件销毁前"</span>)；</span><br><span class="line">    &#125;，</span><br><span class="line">    destoryed:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"组件销毁"</span>)；</span><br><span class="line">    &#125;，</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h1>2. Vue模板</h1><p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。</p><hr><h2 id="2-1-插值"><a href="#2-1-插值" class="headerlink" title="2.1 插值"></a>2.1 插值</h2><p>最常见的插值形式为双大括号文本插入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;My name is &#123;&#123; name &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure><p>如要将数据解释为 HTML 代码，则需要配合 v-html 指令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-html = <span class="string">" HtmlCode "</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>双大括号内可以使用JavaScript表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    &#123;&#123; number + <span class="number">1</span> &#125;&#125;</span><br><span class="line">    &#123;&#123; ok ? <span class="string">'YES'</span> : <span class="string">'NO'</span> &#125;&#125;</span><br><span class="line">    &#123;&#123; message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>) &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-2-指令"><a href="#2-2-指令" class="headerlink" title="2.2 指令"></a>2.2 指令</h2><p>指令 (Directives) 是带有 v- 前缀的特殊特性。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</p><ul><li><h3>属性绑定指令 <b><a href="https://cn.vuejs.org/v2/api/#v-bind" target="_blank" rel="noopener">v-bind</a></b></h3><p>  动态地绑定一个或多个特性，或一个组件 prop 到表达式<br></p><p>  示例</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 绑定一个属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">"imageSrc"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"imageSrc"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 内联字符串拼接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"'/path/to/images/' + fileName"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- class 绑定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"&#123; red: isRed &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"[classA, classB]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"[classA, &#123; classB: isB, classC: isC &#125;]"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- style 绑定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"&#123; fontSize: size + 'px' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"[styleObjectA, styleObjectB]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 绑定一个有属性的对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind</span>=<span class="string">"&#123; id: someProp, 'other-attr': otherProp &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 通过 prop 修饰符绑定 DOM 属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:text-content.prop</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">:prop</span>=<span class="string">"someThing"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child-component</span> <span class="attr">v-bind</span>=<span class="string">"$props"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h3>事件绑定指令 <b><a href="https://cn.vuejs.org/v2/api/#v-on" target="_blank" rel="noopener">v-on</a></b></h3><p>  绑定事件监听器<br></p><p>  示例</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 方法处理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 内联语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"doThat('hello', $event)"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 停止冒泡 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 阻止默认行为 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.prevent</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 阻止默认行为，没有表达式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> @<span class="attr">submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  串联修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop.prevent</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 键修饰符，键别名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">"onEnter"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 键修饰符，键代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.13</span>=<span class="string">"onEnter"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击回调只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.once</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 对象语法 (2.4.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on</span>=<span class="string">"&#123; mousedown: doThis, mouseup: doThat &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h3><b><a href="https://cn.vuejs.org/v2/guide/conditional.html" target="_blank" rel="noopener">条件渲染</a></b>指令</h3><p>  指令：<b>v-if</b> | <b>v-else</b> | <b>v-else-if</b> | <b>v-show</b><br></p><p>  根据表达式的值的真假条件渲染元素<br></p><p>  示例</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"type === 'A'"</span>&gt;</span></span><br><span class="line">    A</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'B'"</span>&gt;</span></span><br><span class="line">    B</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'C'"</span>&gt;</span></span><br><span class="line">    C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    Not A/B/C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">"ok"</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h3>列表渲染指令<b><a href="https://cn.vuejs.org/v2/api/#v-for" target="_blank" rel="noopener"> v-for</a></b></h3><p>  基于源数据多次渲染元素或模板块，v-for 指令需要使用 item in items 形式的特殊语法</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基础用法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">&#123;&#123; item.text &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 值 val , 键 key ，数组索引 index ,数组 items  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(val, key) in object"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(val, key, index) in object"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">```    </span><br><span class="line">v-for 默认行为试着不改变整体，而是替换元素。迫使其重新排序的元素，则需要提供一个 key 的特殊属性</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">    &#123;&#123; item.text &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h3><a href="https://cn.vuejs.org/v2/guide/forms.html" target="_blank" rel="noopener">表单输入绑定</a>指令<b><a href="https://cn.vuejs.org/v2/api/#v-model" target="_blank" rel="noopener"> v-model</a></b></h3>    <p>  在表单控件或者组件上创建双向绑定。v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。故应该通过 JavaScript 在组件的 data 选项中声明初始值。<br>  <br><br>  有时我们可能想把值绑定到 Vue 实例的一个动态属性上，这时可以用 v-bind 实现，并且这个属性的值可以不是字符串。<br><br></p><ul><li><p>文本<br><br>   </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单行文本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"edit me"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 多行文本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Multiline message is:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"white-space: pre-line;"</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"add multiple lines"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>复选框<br><br>  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单个复选框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"checked"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"checkbox"</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 多个复选框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"jack"</span> <span class="attr">value</span>=<span class="string">"Jack"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"jack"</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"john"</span> <span class="attr">value</span>=<span class="string">"John"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"john"</span>&gt;</span>John<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"mike"</span> <span class="attr">value</span>=<span class="string">"Mike"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"mike"</span>&gt;</span>Mike<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  可在JS里面Vue对象data选项中设置默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">    checkedNames: [<span class="string">'John'</span>] <span class="comment">//默认选择John</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>单选按钮<br><br> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"one"</span> <span class="attr">value</span>=<span class="string">"One"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"two"</span> <span class="attr">value</span>=<span class="string">"Two"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Picked: &#123;&#123; picked &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  可在JS里面Vue对象data选项中设置默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">        picked: <span class="string">'One'</span> <span class="comment">//默认选择One</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    - 选择框</span></span><br><span class="line"><span class="string">&lt;br&gt;</span></span><br><span class="line"><span class="string">    `</span><span class="string">``</span>html</span><br><span class="line">    &lt;!-- 单选时 Js Vue对象data选项 selected:<span class="string">''</span> 只需绑定一个值--&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;select v-model=<span class="string">"selected"</span>&gt;</span><br><span class="line">            &lt;option disabled value=<span class="string">""</span>&gt;请选择&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">            &lt;option&gt;A&lt;/</span>option&gt;</span><br><span class="line">            &lt;option&gt;B&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">            &lt;option&gt;C&lt;/</span>option&gt;</span><br><span class="line">        &lt;<span class="regexp">/select&gt;</span></span><br><span class="line"><span class="regexp">        &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/</span>span&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!-- 多选时 Js Vue对象data选项 selected:[] 只需绑定一个数组--&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h1>3. Vue组件初级</h1><p>组件是可复用的Vue实例，故其与根组件有相同的选项，如data，methods，computed，watch，以及生命周期钩子函数，但它没有el选项。</p><hr><h2 id="3-1-子组件基本示例"><a href="#3-1-子组件基本示例" class="headerlink" title="3.1 子组件基本示例"></a>3.1 子组件基本示例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 button-counter 的新组件</span></span><br><span class="line">Vue.component(<span class="string">'button-counter'</span>, &#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">'&lt;button v-on:click="count++"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/* 组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 &lt;button-counter&gt;。我们可以在一个通过 new Vue 创建的 Vue 根实例中，把这个组件作为自定义元素来使用：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;div id="app"&gt;</span></span><br><span class="line"><span class="comment">  &lt;button-counter&gt;&lt;/button-counter&gt;</span></span><br><span class="line"><span class="comment">&lt;/div&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><b>每个组件必须只有一个根元素</b></p><hr><h2 id="3-2-子组件选项"><a href="#3-2-子组件选项" class="headerlink" title="3.2 子组件选项"></a>3.2 子组件选项</h2><ul><li><p>data </p><p>  data必须为一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝，这样避免了不同实例间的互相影响<br><br></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://cn.vuejs.org/v2/guide/components-props.html" target="_blank" rel="noopener">Prop</a></p><p>  父组件通过Prop向子组件传递数据(子组件通过$.emit向父组件传值).Prop 是你可以在组件上注册的一些自定义特性。当一个值传递给一个 prop 特性的时候，它就变成了那个组件实例的一个属性。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</span><br><span class="line">    props: [<span class="string">'title'</span>],</span><br><span class="line">    template: <span class="string">'&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>  一个 prop 被注册之后，你就可以像这样把数据作为一个自定义特性传递进来：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">"My journey with Vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">"Blogging with Vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">"Why Vue is so fun"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  若要从父组件中取得数据</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        posts: [</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">'My journey with Vue'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">title</span>: <span class="string">'Blogging with Vue'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">title</span>: <span class="string">'Why Vue is so fun'</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>  使用 v-bind 来动态传递 prop</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"post in posts"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:key</span>=<span class="string">"post.id"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:title</span>=<span class="string">"post.title"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  当组件越来越复杂，属性越来越多时，为每个相关的信息定义一个 prop 会变得很麻烦</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">    v-<span class="keyword">for</span>=<span class="string">"post in posts"</span></span><br><span class="line">    v-bind:key=<span class="string">"post.id"</span></span><br><span class="line">    v-bind:title=<span class="string">"post.title"</span></span><br><span class="line">    v-bind:content=<span class="string">"post.content"</span></span><br><span class="line">    v-bind:publishedAt=<span class="string">"post.publishedAt"</span></span><br><span class="line">    v-bind:comments=<span class="string">"post.comments"</span></span><br><span class="line">&gt;<span class="xml"><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>  则需要重构一下这个 blog-post 组件了，让它变成接受一个单独的 post prop：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</span><br><span class="line">    props: [<span class="string">'post'</span>],</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div class="blog-post"&gt;</span></span><br><span class="line"><span class="string">        &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">        &lt;div v-html="post.content"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><a href="https://cn.vuejs.org/v2/api/#template" target="_blank" rel="noopener">template</a></p><p>  在这里是html的字符串模板，会替换挂载的元素</p><p>  我们希望在根组件中直接用 </p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  而不必下面这种方式调用该组件 </p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"post in posts"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:key</span>=<span class="string">"post.id"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:title</span>=<span class="string">"post.title"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:content</span>=<span class="string">"post.content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:publishedAt</span>=<span class="string">"post.publishedAt"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:comments</span>=<span class="string">"post.comments"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  我们需要用到模板template</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</span><br><span class="line">    props: [<span class="string">'post'</span>],</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div class="blog-post"&gt;</span></span><br><span class="line"><span class="string">        &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">        &lt;div v-html="post.content"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><hr><p>这篇文章关于组件的部分只是基础中的基础，特别是组件注册，插槽，Prop和$emit等都还没写好，下一篇博客再写吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON</title>
      <link href="/2018/09/30/json/"/>
      <url>/2018/09/30/json/</url>
      
        <content type="html"><![CDATA[<hr><p id="head" style="display:inline-block; float:left ;font-size:1rem;line-height:1rem;"><br>    <b>文<br><br>    章<br><br>    目<br><br>    录</b><br></p><div style="display:flex;align-items:center;justify-content:center; "><br>    <div style="display:flex ;justify-content:space-around;align-items:center; font-size:0.8rem; width:100%;line-height:0.8rem;"><br>        <div><br>            <li><a href="#1"> 1 JSON简介</a></li><br>            <ul style="margin-top:0"><br>                <li><a href="#1.1"> 1.1 JSON与JavaScript</a></li><br>                <li><a href="#1.2"> 1.2 JSON与XML</a></li><br>            </ul><br>        </div><br>        <div><br>            <li><a href="#2"> 2 JSON语法</a></li><br>            <ul style="margin-top:0"><br>                <li><a href="#2.1"> 2.1 简单值</a></li><br>                <li><a href="#2.2"> 2.2 对象</a></li><br>                <li><a href="#2.3"> 2.3 数组</a></li><br>                <li><a href="#2.4"> 2.4 JSON样例代码</a></li><br>            </ul><br>        </div><br>        <div><br>            <li><a href="#3"> 3 JSON解析与序列化</a></li><br>            <ul style="margin-top:0"><br>                <li><a href="#3.1"> 3.1 stringify()</a></li><br>                <li><a href="#3.2"> 3.2 parse()</a></li><br>                <li><a href="#3.3"> 3.3 toJSON()</a></li><br>                <li><a href="#3.4"> 3.4 JSON.stringify()序列化对象的顺序</a></li><br>            </ul><br>        </div><br>    </div><br></div><hr><a id="more"></a><h1 id="1">JSON简介</h1><p>&nbsp;&nbsp;JSON：JavaScript对象表示法(<span style="color:red">J</span>ava<span style="color:red">S</span>cript <span style="color:red">O</span>bject <span style="color:red">N</span>oatation)</p><p>&nbsp;&nbsp;根据MDN的说法:</p><blockquote><p><em>JSON是一种用于序列化对象，数组，数字，字符串，布尔值和null的结构化数据的格式</em>  </p></blockquote><p>&nbsp;&nbsp;JSON基于JavaScript语法，类似XML，但却和它们有区别</p><hr><ul><li><h2 id="1.1"> JSON与JavaScript </h2><br>JSON是一种数据格式，不是一种编程语言，JSON也不从属于JavaScript</li></ul><hr><ul><li><h2 id="1.2"> JSON与XML </h2><p>JSON能够使用 <a href="&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval&quot;">eval()</a> 方法进行解析，不必创建DOM对象</p></li></ul><hr><h1 id="2">JSON语法</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;JSON的语法可以表示以下三种类型的值：</p><hr><ul><li><h2 id="2.1">简单值</h2><p>  JSON与JavaScript简单值最大区别是：<br><br></p><blockquote><ol><li>JSON字符串必须使用双引号</li><li>JSON不支持JavaScript中特殊值undefined</li></ol></blockquote></li></ul><hr><ul><li><h2 id="2.2">对象</h2><p>  JSON对象与JavaScript对象两个不同点：<br><br></p><blockquote><ol><li>没有声明变量（JSON中没有变量的概念）</li><li>没有末尾分号（因为这不是JavaScript语句，所以不需要分号）</li></ol></blockquote></li></ul><hr><ul><li><h2 id="2.3">数组</h2><p>  JSON数组采用的就是JavaScript的数组字面量形式，但没有变量和分号<br>  <br></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"Hello World!"</span>,<span class="number">3</span>,<span class="literal">true</span>,<span class="literal">null</span>,&#123;&#125;]</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><h2 id="2.4">JSON样例代码</h2>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- <span class="built_in">JSON</span>样例 --&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"String"</span>:<span class="string">"Hello World!"</span>,   &lt;!-- 字符串--&gt;</span><br><span class="line">    <span class="string">"Number"</span>:<span class="number">3</span>,                &lt;!-- 数值--&gt;</span><br><span class="line">    <span class="string">"Boolean"</span>:<span class="literal">true</span>,            &lt;!-- 布尔值--&gt;</span><br><span class="line">    <span class="string">"Null"</span>:<span class="literal">null</span>,               &lt;!-- <span class="literal">null</span>--&gt;</span><br><span class="line">    <span class="string">"_1Bin"</span>:&#123;                  &lt;!-- 对象--&gt;</span><br><span class="line">        <span class="string">"Name"</span>:<span class="string">"1bin"</span>,</span><br><span class="line">        <span class="string">"Age"</span>:<span class="number">18</span>,</span><br><span class="line">        <span class="string">"Tag"</span>:[</span><br><span class="line">            <span class="string">"Lonely patient"</span>,<span class="string">"Crazy"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"Sex"</span>:&#123;</span><br><span class="line">            <span class="string">"IsBoy"</span>:<span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="3">JSON解析与序列化</h1><p>&nbsp;&nbsp;JSON对象可以直接解析为JavaScript对象</p><p>&nbsp;&nbsp;早期JSON解析器基本上就是使用JavaScript的eval()函数，但eval()存在风险，现在已经摒弃。</p><p>&nbsp;&nbsp;现在基本上都是用JSON对象的两个方法进行解析与序列化</p><hr><ul><li><h2 id="3.1">stringify()</h2><p>  stringify()把JavaScript对象序列化为JSON字符串,有三个参数</p>  <h4>JSON.stringify(value,replacer,space)</h4><blockquote><ol><li>value<br>   将要序列化成JSON字符串的JavaScript对象</li><li>replacer(可选)<br>   <strong>函数</strong>：则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理<br>   <strong>数组</strong>：则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中<br>   <strong>null或者未提供</strong>：则对象所有的属性都会被序列化</li><li>space(可选)<br>   指定缩进用的字符串,可为一般字符串或空格。</li></ol></blockquote><p>  <em>值得注意的是，所有值为undefined的属性都会被stringify()自动忽略，所以也可以用第二个参数作为过滤器(如用switch_case筛选,但一定要记得提供default项)给特定的属性返回undefined让其消失</em><br>  <br></p><p>  <strong>使用stringify()的样例：</strong></p></li></ul><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">                title:<span class="string">"Hello World!"</span>,</span><br><span class="line">                author:&#123;</span><br><span class="line">                          name:<span class="string">"1 bin"</span></span><br><span class="line">                       &#125;</span><br><span class="line">           &#125;;</span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book);</span><br><span class="line"></span><br><span class="line">&lt;!-- jsonText的值为：<span class="string">"&#123;"</span>title<span class="string">":"</span>Hello World<span class="string">","</span>author<span class="string">":&#123;"</span>name<span class="string">":"</span><span class="number">1</span> bin<span class="string">"&#125;"</span>&#125; --&gt;</span><br></pre></td></tr></table></figure></code></pre><hr><ul><li><h2 id="3.2">parse()</h2><p>  parse()把JSON字符串解析为原生JavaScript值</p>  <h4>parse(text,reviver)</h4><blockquote><ol><li>text<br>   将要被解析成JavaScript值的字符串</li><li>reviver(可选)<br>   还原函数：规定了原始值如何被解析改造，在被返回之前</li></ol></blockquote>  <h4>reviver函数</h4><p>  根据MDN：</p><blockquote><p>如果指定了 reviver 函数，则解析出的 JavaScript 值（解析值）会经过一次转换后才将被最终返回（返回值）。更具体点讲就是：解析值本身以及它所包含的所有属性，会按照一定的顺序（从最最里层的属性开始，一级级往外，最终到达顶层，也就是解析值本身）分别的去调用 reviver 函数，在调用过程中，当前属性所属的对象会作为 this 值，当前属性名和属性值会分别作为第一个和第二个参数传入 reviver 中。如果 reviver 返回 undefined，则当前属性会从所属对象中删除，如果返回了其他值，则返回的值会成为当前属性新的属性值。</p></blockquote><blockquote><p>当遍历到最顶层的值（解析值）时，传入 reviver 函数的参数会是空字符串 “”（因为此时已经没有真正的属性）和当前的解析值（有可能已经被修改过了），当前的 this 值会是 {“”: 修改过的解析值}，在编写 reviver 函数时，要注意到这个特例。（这个函数的遍历顺序依照：从最内层开始，按照层级顺序，依次向外遍历）</p></blockquote><p>   <strong>使用parse()的样例：</strong></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bookCopy = <span class="built_in">JSON</span>.parse(jsonText);</span><br></pre></td></tr></table></figure><p>  <em>值得注意的是，这里的jsonText的值为：”xxx”,要用双引号，对于一些代码块，需要用反逗号</em></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book2 = <span class="string">`&#123;</span></span><br><span class="line"><span class="string">                "a":"Hello Wolrd!",</span></span><br><span class="line"><span class="string">                "b":2</span></span><br><span class="line"><span class="string">             &#125;`</span>;</span><br><span class="line"><span class="keyword">var</span> Copy = <span class="built_in">JSON</span>.parse(book2);</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><h2 id="3.3">toJSON()</h2><p>  用于补充JSON.stringify()所不能满足的自定义序列化需求。可以直接给对象定义toJSON()方法，返回其自身的JSON数据格式(如原生Date对象的toJSON方法)</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">                title:<span class="string">"Hello World!"</span>,</span><br><span class="line">                year:<span class="number">2018</span>,</span><br><span class="line">                toJSON: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.title;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;;</span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(jsonText)     &lt;!-- <span class="string">"Hello World!"</span> --&gt;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><h2 id="3.4">JSON.stringify()序列化对象的顺序</h2></li></ul><pre><code>(1)调用toJSON()方法(如果存在，若不存在，则返回对象本身)(2)应用过滤器(如存在第二个参数，传入过滤器的值是第(1)步返回的值)(3)对第(2)步返回的每个值进行相应的序列化(4)如提供了第三个参数，执行相应的格式化</code></pre><div style="color:black;diplay:flex;justify-content:center;align-items:center;"><div><a href="#head">回到目录</a></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暑假培训总结 (7.12 - 8.4)</title>
      <link href="/2018/08/25/summer/"/>
      <url>/2018/08/25/summer/</url>
      
        <content type="html"><![CDATA[<h4 id="第一个星期"><a href="#第一个星期" class="headerlink" title="第一个星期"></a>第一个星期</h4><h5 id="空调不凉，没有风扇的第一周，想它。"><a href="#空调不凉，没有风扇的第一周，想它。" class="headerlink" title="空调不凉，没有风扇的第一周，想它。"></a>空调不凉，没有风扇的第一周，想它。</h5><a id="more"></a><p>暑假培训的关键词就是热。刚开始的时候确实热到有点受不了，学东西也有点不够心静。</p><p>刚开始接触github，开始学js，看高程，写博客，算是前端刚刚入门吧。</p><p>自己学前端就是因为兴趣，所以呢学东西是越学越进状态吧，然后学得也挺快的(后来用的时候发现还是没有掌握牢固，这时候博客的作用就体现出来了)</p><p>每次写博客都感觉是自己学东西学的最细，学得最深，最投入的时候，真的是沉迷写博，日常熬夜。</p><p>第一个星期主要在调整状态，静心。</p><h4 id="第二个星期"><a href="#第二个星期" class="headerlink" title="第二个星期"></a>第二个星期</h4><h5 id="空调不凉，但有风扇的第二周，还是想它。"><a href="#空调不凉，但有风扇的第二周，还是想它。" class="headerlink" title="空调不凉，但有风扇的第二周，还是想它。"></a>空调不凉，但有风扇的第二周，还是想它。</h5><p>这个时间点呢，大家都成了老油条，各各都压点到工作室。真是应该批评！一到休息时间就相约打游戏，太可怕了吧！！！别的工作室严肃紧张，我们工作室却是轻松活泼，真的是太，，，好了吧！</p><p>第二周主要在学JQ以及一些交互的知识，为了第三周的开发做准备。</p><p>此时，前端组都还比较轻松，就设计在疯狂抠图，后台在疯狂，，学前端0.0</p><p>第二个星期主要在学习，以及体会前端地位的低下(被设计打压，被后台欺负)</p><h4 id="第三个星期"><a href="#第三个星期" class="headerlink" title="第三个星期"></a>第三个星期</h4><h6 id="空调凉些了，也有风扇的第三周，却还是想它。"><a href="#空调凉些了，也有风扇的第三周，却还是想它。" class="headerlink" title="空调凉些了，也有风扇的第三周，却还是想它。"></a>空调凉些了，也有风扇的第三周，却还是想它。</h6><p>开始做项目了，看着后台愁眉苦脸，一筹莫展，心态奔溃，我觉得还是前端的任务轻松点啊，因为 阿肥项目 没有什么动态，基本是静态，静态的样式还有重复，这对前端er来说确实不难。</p><p>于是我疯狂两天做完自己负责的六七个界面，然后看其他小伙伴都还在疯狂打码呢，再加上我觉得我做太快，做得粗糙，没注意细节，于是我又花了一天，重做了所有界面。</p><p>前端交接的时候，要用到git操作，此时，我留下了不学无术的泪水，疯狂出问题，疯狂出bug，我甚至都怀疑人生了，还好有张老板，周老板，菠萝教我。</p><p>前端交接终于问题不大了，于是就开始和后台交互，然后再次出一堆bug(这就是所谓的攘外必先安内吧)，不过这次前端er不背锅，后台小伙伴接口有问题！</p><p>于是乎，交互尚未完成，出游就已经到来，于是就0.0</p><p>第三个星期主要在前端交接代码，前后端交互，以及体会人生的绝望，不学无术只能默默流泪的无奈。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 暑假总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery(part4)</title>
      <link href="/2018/07/24/12th/"/>
      <url>/2018/07/24/12th/</url>
      
        <content type="html"><![CDATA[<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><a id="more"></a><h4 id="load-：从服务器加载数据，并把返回的数据放入被选元素中"><a href="#load-：从服务器加载数据，并把返回的数据放入被选元素中" class="headerlink" title="load() ：从服务器加载数据，并把返回的数据放入被选元素中"></a>load() ：从服务器加载数据，并把返回的数据放入被选元素中</h4><p>语法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).load(URL,data,callback)</span><br></pre></td></tr></table></figure></p><p>必需的 URL 参数规定加载的 URL。</p><p>可选的 data 参数规定与请求一同发送的查询字符串键/值对集合。</p><p>可选的 callback 参数是 load() 方法完成后所执行的函数名称。</p><p>可将jQuery选择器添加到URL参数,例如：</p><p>把 “a.txt” 文件中 id=”p1” 的元素的内容，加载到指定的 <div> 元素中</div></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#div1"</span>).load(<span class="string">"a.txt #p1"</span>);</span><br></pre></td></tr></table></figure><p>load()回调函数为callback(responseTxt,statusTxt,xhr)</p><ol><li><p>responseTxt - 包含调用成功时的结果内容</p></li><li><p>statusTXT - 包含调用的状态</p></li><li><p>xhr - 包含 XMLHttpRequest 对象</p></li></ol><h4 id="get-：通过-HTTP-GET-请求从服务器上请求数据"><a href="#get-：通过-HTTP-GET-请求从服务器上请求数据" class="headerlink" title="$.get() ：通过 HTTP GET 请求从服务器上请求数据"></a>$.get() ：通过 HTTP GET 请求从服务器上请求数据</h4><p>语法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.get(URL,callback)</span><br></pre></td></tr></table></figure></p><p>$.get()回调函数callback(data,status) </p><p>第一个回调参数存有被请求页面的内容，第二个回调参数存有请求的状态</p><h4 id="post-通过-HTTP-POST-请求向服务器提交数据"><a href="#post-通过-HTTP-POST-请求向服务器提交数据" class="headerlink" title="$.post() : 通过 HTTP POST 请求向服务器提交数据"></a>$.post() : 通过 HTTP POST 请求向服务器提交数据</h4><p>语法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.post(URL,data,callback)</span><br></pre></td></tr></table></figure></p><p>必需的 URL 参数规定您希望请求的 URL</p><p>可选的 data 参数规定连同请求发送的数据</p><p>可选的 callback 参数是请求成功后所执行的函数名</p><p>$.post()回调函数callback(data,status) </p><p>第一个回调参数存有被请求页面的内容，第二个回调参数存有请求的状态</p><h2 id="jQuery-noConflict-方法"><a href="#jQuery-noConflict-方法" class="headerlink" title="jQuery noConflict() 方法"></a>jQuery noConflict() 方法</h2><p>jQuery使用$符号作为jQuery的简写，如果其他javascript框架也使用美元符作为简写,可通过 noConflict()方法解决命名冲突的问题 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jq = $.noConflict();</span><br><span class="line"></span><br><span class="line">jq(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以直接用jQuery代替$</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jQuery(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;                                     </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>Jsonp可以让我们跨域读取数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.getJSON(URL, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><a href="http://www.runoob.com/jquery/jquery-examples.html" target="_blank" rel="noopener">http://www.runoob.com/jquery/jquery-examples.html</a></p><h2 id="jQuery-参考手册"><a href="#jQuery-参考手册" class="headerlink" title="jQuery 参考手册"></a>jQuery 参考手册</h2><h5 id="jQuery-选择器-：http-www-runoob-com-jquery-jquery-ref-selectors-html"><a href="#jQuery-选择器-：http-www-runoob-com-jquery-jquery-ref-selectors-html" class="headerlink" title="jQuery 选择器 ：http://www.runoob.com/jquery/jquery-ref-selectors.html"></a>jQuery 选择器 ：<a href="http://www.runoob.com/jquery/jquery-ref-selectors.html" target="_blank" rel="noopener">http://www.runoob.com/jquery/jquery-ref-selectors.html</a></h5><h5 id="jQuery-事件方法-：http-www-runoob-com-jquery-jquery-ref-events-html"><a href="#jQuery-事件方法-：http-www-runoob-com-jquery-jquery-ref-events-html" class="headerlink" title="jQuery 事件方法 ：http://www.runoob.com/jquery/jquery-ref-events.html"></a>jQuery 事件方法 ：<a href="http://www.runoob.com/jquery/jquery-ref-events.html" target="_blank" rel="noopener">http://www.runoob.com/jquery/jquery-ref-events.html</a></h5><h5 id="jQuery-效果方法-：-http-www-runoob-com-jquery-jquery-ref-effects-html"><a href="#jQuery-效果方法-：-http-www-runoob-com-jquery-jquery-ref-effects-html" class="headerlink" title="jQuery 效果方法 ： http://www.runoob.com/jquery/jquery-ref-effects.html"></a>jQuery 效果方法 ： <a href="http://www.runoob.com/jquery/jquery-ref-effects.html" target="_blank" rel="noopener">http://www.runoob.com/jquery/jquery-ref-effects.html</a></h5><h5 id="jQuery-HTML-CSS-方法-：http-www-runoob-com-jquery-jquery-ref-html-html"><a href="#jQuery-HTML-CSS-方法-：http-www-runoob-com-jquery-jquery-ref-html-html" class="headerlink" title="jQuery HTML/CSS 方法 ：http://www.runoob.com/jquery/jquery-ref-html.html"></a>jQuery HTML/CSS 方法 ：<a href="http://www.runoob.com/jquery/jquery-ref-html.html" target="_blank" rel="noopener">http://www.runoob.com/jquery/jquery-ref-html.html</a></h5><h5 id="jQuery-遍历方法-：http-www-runoob-com-jquery-jquery-ref-traversing-html"><a href="#jQuery-遍历方法-：http-www-runoob-com-jquery-jquery-ref-traversing-html" class="headerlink" title="jQuery 遍历方法 ：http://www.runoob.com/jquery/jquery-ref-traversing.html"></a>jQuery 遍历方法 ：<a href="http://www.runoob.com/jquery/jquery-ref-traversing.html" target="_blank" rel="noopener">http://www.runoob.com/jquery/jquery-ref-traversing.html</a></h5><h5 id="jQuery-AJAX方法-：-http-www-runoob-com-jquery-jquery-ref-ajax-html"><a href="#jQuery-AJAX方法-：-http-www-runoob-com-jquery-jquery-ref-ajax-html" class="headerlink" title="jQuery AJAX方法 ： http://www.runoob.com/jquery/jquery-ref-ajax.html"></a>jQuery AJAX方法 ： <a href="http://www.runoob.com/jquery/jquery-ref-ajax.html" target="_blank" rel="noopener">http://www.runoob.com/jquery/jquery-ref-ajax.html</a></h5><h5 id="jQuery-杂项方法-：http-www-runoob-com-jquery-jquery-ref-misc-html"><a href="#jQuery-杂项方法-：http-www-runoob-com-jquery-jquery-ref-misc-html" class="headerlink" title="jQuery 杂项方法 ：http://www.runoob.com/jquery/jquery-ref-misc.html"></a>jQuery 杂项方法 ：<a href="http://www.runoob.com/jquery/jquery-ref-misc.html" target="_blank" rel="noopener">http://www.runoob.com/jquery/jquery-ref-misc.html</a></h5><h5 id="jQuery-属性-http-www-runoob-com-jquery-jquery-ref-prop-html"><a href="#jQuery-属性-http-www-runoob-com-jquery-jquery-ref-prop-html" class="headerlink" title="jQuery 属性 : http://www.runoob.com/jquery/jquery-ref-prop.html"></a>jQuery 属性 : <a href="http://www.runoob.com/jquery/jquery-ref-prop.html" target="_blank" rel="noopener">http://www.runoob.com/jquery/jquery-ref-prop.html</a></h5><p><strong>人生的刺，就在这里，留恋着不肯快走的，偏是你所不留恋的东西。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery(part3)</title>
      <link href="/2018/07/23/tenthDay/"/>
      <url>/2018/07/23/tenthDay/</url>
      
        <content type="html"><![CDATA[<h2 id="jQuery遍历方法"><a href="#jQuery遍历方法" class="headerlink" title="jQuery遍历方法"></a>jQuery遍历方法</h2><a id="more"></a><h4 id="祖先（向上遍历-DOM-树）"><a href="#祖先（向上遍历-DOM-树）" class="headerlink" title="祖先（向上遍历 DOM 树）"></a>祖先（向上遍历 DOM 树）</h4><ol><li><p>parent() , 返回被选元素的直接父元素</p></li><li><p>parents(可选参数) , 返回被选元素的所有祖先元素，它一路向上直到文档的根元素(html) </p></li><li><p>parentsUntil(参数)</p></li></ol><p>祖先部分html代码:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span> body (曾曾祖父元素)</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>div (曾祖父元素)</span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"ul1"</span>&gt;</span>ul (祖父元素)  </span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>li (父元素)</span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span>&gt;</span>span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>parent():</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'span'</span>).parent()  <span class="comment">//  返回&lt;li&gt;</span></span><br></pre></td></tr></table></figure><p>parents():</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'span'</span>).parents() ;<span class="comment">// 返回所有是&lt;span&gt;的祖先</span></span><br></pre></td></tr></table></figure><p><strong>可选参数来过滤对祖先元素的搜索</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'span'</span>).parents(<span class="string">'div'</span>) ;<span class="comment">// 返回所有是&lt;div&gt;的&lt;spa&gt;n的祖先</span></span><br></pre></td></tr></table></figure><p>parentsUntil():要带参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'span'</span>).parentsUntil(<span class="string">'div'</span>);<span class="comment">// 返回&lt;li&gt; &lt;ul&gt; ,不包括&lt;div&gt;</span></span><br></pre></td></tr></table></figure><h4 id="后代-向下遍历dom树"><a href="#后代-向下遍历dom树" class="headerlink" title="后代(向下遍历dom树)"></a>后代(向下遍历dom树)</h4><ol><li>children(可选参数) ，返回被选元素的所有直接子元素</li><li>find(参数) ， 被选元素的后代元素，一路向下直到最后一个后代</li></ol><p>后代部分html代码:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"ul1"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>children():</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).children()  <span class="comment">// 返回所有&lt;div&gt;的所有直接子元素 &lt;ul&gt; &lt;span&gt; &lt;ul&gt;</span></span><br></pre></td></tr></table></figure><p><strong>可选参数来过滤对子元素的搜索</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).children(<span class="string">'.ul1'</span>)  <span class="comment">// 返回所有类名为 .ul的,&lt;div&gt;的直接子元素</span></span><br></pre></td></tr></table></figure><p>find(): 要带参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).find(<span class="string">'span'</span>)  <span class="comment">// 返回所有为&lt;span&gt;标签的,&lt;div&gt;的子元素</span></span><br></pre></td></tr></table></figure><p>若要全选div所有子元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).find(<span class="string">'*'</span>)</span><br></pre></td></tr></table></figure><h4 id="同胞siblings-DOM-树中水平遍历"><a href="#同胞siblings-DOM-树中水平遍历" class="headerlink" title="同胞siblings(DOM 树中水平遍历)"></a>同胞siblings(DOM 树中水平遍历)</h4><ol><li><p>siblings(可选参数),返回被选元素的所有同胞元素</p></li><li><p>next(),返回被选元素的下一个同胞元素</p></li><li><p>nextAll(),返回被选元素的所有跟随(next)的同胞元素</p></li><li><p>nextUntil(参数),返回介于两个给定参数之间的所有跟随(next)的同胞元素</p></li><li><p>prev()</p></li><li><p>prevAll()</p></li><li><p>prevUntil()</p></li></ol><p><strong>prev(), prevAll() 以及 prevUntil() 方法的工作方式与上面的方法类似，只不过方向相反而已：它们返回的是前面的同胞元素（在 DOM 树中沿着同胞之前元素遍历，而不是之后元素遍历)</strong></p><p>以next（在 DOM 树中沿着同胞之后元素遍历）为例<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>div (父元素)</span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>p<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>h3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>p<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h4</span>&gt;</span>h4<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>siblings():</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'h2'</span>).siblings();  <span class="comment">//返回 &lt;h2&gt; 的所有同胞元素 &lt;p&gt; &lt;span&gt; &lt;h3&gt; &lt;p&gt; &lt;h4&gt;</span></span><br></pre></td></tr></table></figure><p><strong>可选参数来过滤对同胞元素的搜索</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'h2'</span>).siblings(<span class="string">'p'</span>);  <span class="comment">//返回 &lt;h2&gt; 的所有同胞 &lt;p&gt;元素 &lt;p&gt; &lt;p&gt;</span></span><br></pre></td></tr></table></figure><p>next():</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"h2"</span>).next(); <span class="comment">//返回 &lt;h3&gt;</span></span><br></pre></td></tr></table></figure><p>nextAll():</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'h2'</span>).nextAll(); <span class="comment">//返回 &lt;h3&gt; &lt;p&gt; &lt;h4&gt;</span></span><br></pre></td></tr></table></figure><p>nextUntil():</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'h2'</span>).nextUntil(<span class="string">'h4'</span>);<span class="comment">//返回 &lt;h3&gt; &lt;p&gt; &lt;h4&gt;</span></span><br></pre></td></tr></table></figure><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><p>下面这三个最基本的过滤方法允许基于其在一组元素中的位置来选择一个特定的元素</p><ol><li><p>first(),返回被选元素的首个元素</p></li><li><p>last(),返回被选元素的最后一个元素</p></li><li><p>eq()，返回被选元素中带有指定索引号的元素</p></li></ol><p>下面这两个选取匹配或不匹配某项指定标准的元素</p><ol start="4"><li><p>filter()，允许规定一个标准。不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回</p></li><li><p>not()，返回不匹配标准的所有元素</p></li></ol><p>过滤部分的html代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"pp"</span>&gt;</span>p1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>p2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>first():</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div p'</span>).first() <span class="comment">//返回首个 &lt;div&gt; 元素内部的第一个 &lt;p&gt; 元素  p1</span></span><br></pre></td></tr></table></figure><p>last():</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"div p"</span>).last() <span class="comment">//返回最后一个 &lt;div&gt; 元素中的最后一个 &lt;p&gt; 元素  p2</span></span><br></pre></td></tr></table></figure><p>eq() : 索引号从 0 开始，因此首个元素的索引号是 0 而不是 1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'p'</span>).eq(<span class="number">0</span>)  <span class="comment">// 返回 p1</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">'p'</span>).eq(<span class="number">2</span>)  <span class="comment">// 返回 p3</span></span><br></pre></td></tr></table></figure><p>filter():</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).filter(<span class="string">"pp"</span>)  <span class="comment">//返回所有&lt;p&gt;元素中类名为pp的&lt;p&gt;元素  p1</span></span><br></pre></td></tr></table></figure><p>not() : 与 filter() 相反</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).not(<span class="string">"pp"</span>)  <span class="comment">//返回所有&lt;p&gt;元素中类名不为pp的&lt;p&gt;元素  p2 p3</span></span><br></pre></td></tr></table></figure><p><strong>如果有来生，</strong><br><strong>要做一棵树，</strong><br><strong>站成永恒，</strong><br><strong>没有悲欢的姿势。</strong><br><strong>一半在土里安详，</strong><br><strong>一半在风里飞扬，</strong><br><strong>一半洒落阴凉，</strong><br><strong>一半沐浴阳光，</strong><br><strong>非常沉默非常骄傲，</strong><br><strong>从不依靠，从不寻找</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery(part2)</title>
      <link href="/2018/07/22/ninthDay/"/>
      <url>/2018/07/22/ninthDay/</url>
      
        <content type="html"><![CDATA[<h2 id="jQuery-HTML-CSS操作"><a href="#jQuery-HTML-CSS操作" class="headerlink" title="jQuery HTML/CSS操作"></a>jQuery HTML/CSS操作</h2><a id="more"></a><h4 id="获得内容-text-、html-以及-val"><a href="#获得内容-text-、html-以及-val" class="headerlink" title="获得内容 - text()、html() 以及 val()"></a>获得内容 - text()、html() 以及 val()</h4><ol><li><p>text() - 设置或返回所选元素的文本内容（自动解析文本里面的 HTML 标签内容）</p></li><li><p>html() - 设置或返回所选元素的内容（包括 HTML 标签标记）</p></li><li><p><strong>val() - 设置或返回表单字段的值</strong></p></li></ol><h4 id="设置内容-text-、html-以及-val"><a href="#设置内容-text-、html-以及-val" class="headerlink" title="设置内容 - text()、html() 以及 val()"></a>设置内容 - text()、html() 以及 val()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#btn1"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"#test1"</span>).text(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">"#btn2"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"#test2"</span>).html(<span class="string">"&lt;b&gt;Hello world!&lt;/b&gt;"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">"#btn3"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"#test3"</span>).val(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>text()、html() 以及 val()，同样拥有回调函数。回调函数有两个参数：<strong>被选元素列表中当前元素的下标</strong>，以及<strong>原始（旧的）值</strong>。然后以<strong>函数新值返回您希望使用的字符串</strong>。</p><p>jQ代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">"#btn1"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">".test1"</span>).text(<span class="function"><span class="keyword">function</span>(<span class="params">i,origText</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"旧文本: "</span> + origText + <span class="string">" 新文本: Hello world! (index: "</span> + i + <span class="string">")"</span>; </span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>html代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"test1"</span>&gt;</span>这是一个有 <span class="tag">&lt;<span class="name">b</span>&gt;</span>粗体<span class="tag">&lt;/<span class="name">b</span>&gt;</span> 字的段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"test1"</span>&gt;</span>这是另外一个有 <span class="tag">&lt;<span class="name">b</span>&gt;</span>粗体<span class="tag">&lt;/<span class="name">b</span>&gt;</span> 字的段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn1"</span>&gt;</span>显示 新/旧 文本<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果：</p><p>旧文本: 这是一个有 粗体 字的段落。 新文本: Hello world! (index: 0)</p><p>旧文本: 这是另外一个有 粗体 字的段落。 新文本: Hello world! (index: 1)</p><h4 id="获取属性-attr"><a href="#获取属性-attr" class="headerlink" title="获取属性 - attr()"></a>获取属性 - attr()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).attr(<span class="string">'class'</span>)</span><br></pre></td></tr></table></figure><h4 id="设置属性-attr"><a href="#设置属性-attr" class="headerlink" title="设置属性 - attr()"></a>设置属性 - attr()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).attr(<span class="string">'class'</span>,<span class="string">'container'</span>)</span><br></pre></td></tr></table></figure><p>attr() 方法也允许同时设置多个属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>.).attr(&#123;</span><br><span class="line">    <span class="string">'class'</span> : <span class="string">'container'</span> ,</span><br><span class="line">    <span class="string">'style'</span> : <span class="string">'background-color:white'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>attr()，提供回调函数。回调函数有两个参数：<strong>被选元素列表中当前元素的下标</strong>，以及<strong>原始（旧的）值</strong>。然后以<strong>函数新值返回您希望使用的字符串</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).attr(<span class="string">'class'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"> i , origValue</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> origValue + <span class="string">'/jQ'</span> ;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><ol><li><p>append() - 在被选元素的结尾插入内容</p></li><li><p>prepend() - 在被选元素的开头插入内容</p></li><li><p>after() - 在被选元素之后插入内容</p></li><li><p>before() - 在被选元素之前插入内容</p></li></ol><p>append() 方法在被选元素的结尾插入内容（仍然该元素的内部）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'p'</span>).append(<span class="string">'追加文本'</span>);</span><br></pre></td></tr></table></figure><p>prepend() 方法在被选元素的开头插入内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $('p').prepend('在开头追加文本');</span></span><br><span class="line">$(<span class="string">'p'</span>).prepend(<span class="string">'&lt;li&gt;开头插入列表项&lt;/li&gt;'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果：</p><p>1.列表 1            ===&gt;&gt;&gt;             1.开头插入列表项<br>2.列表 2            ===&gt;&gt;&gt;      2.列表 1<br>3.列表 3            ===&gt;&gt;&gt;             3.列表 2<br>0空空空            ===&gt;&gt;&gt;            4.列表 3</p><p>append()和prepend()可以用来生成文本/html</p><p>三种生成文本的方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> txt1=<span class="string">"&lt;p&gt;文本。&lt;/p&gt;"</span>;              <span class="comment">// 使用 HTML 标签创建文本</span></span><br><span class="line"><span class="keyword">var</span> txt2=$(<span class="string">"&lt;p&gt;&lt;/p&gt;"</span>).text(<span class="string">"文本。"</span>);  <span class="comment">// 使用 jQuery 创建文本</span></span><br><span class="line"><span class="keyword">var</span> txt3=<span class="built_in">document</span>.createElement(<span class="string">"p"</span>);</span><br><span class="line"></span><br><span class="line">    txt3.innerHTML=<span class="string">"文本。"</span>;               <span class="comment">// 使用 DOM 创建文本 text with DOM</span></span><br><span class="line">    $(<span class="string">"body"</span>).append(txt1,txt2,txt3);        <span class="comment">// 追加新元素</span></span><br></pre></td></tr></table></figure><p>after() 和 before()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).before(<span class="string">'&lt;b&gt;之前&lt;/b&gt;'</span>;</span><br><span class="line"></span><br><span class="line">$(<span class="string">'div'</span>).after(<span class="string">'&lt;b&gt;之前&lt;/b&gt;'</span>);</span><br></pre></td></tr></table></figure><p>append()/prepend()和after()/before()的区别</p><p>append():</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"s1"</span>&gt;s1&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(<span class="string">"p"</span>).append(<span class="string">'&lt;span class="s2"&gt;s2&lt;/span&gt;'</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>作用后为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"s1"</span>&gt;s1&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;span class="s2"&gt;s2&lt;/</span>span&gt;</span><br><span class="line">&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure><p>after():</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"s1"</span>&gt;s1&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(<span class="string">"p"</span>).after(<span class="string">'&lt;span class="s2"&gt;s2&lt;/span&gt;'</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>作用后为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"s1"</span>&gt;s1&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>p&gt;</span><br><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"s2"</span>&gt;s2&lt;<span class="regexp">/span&gt;</span></span><br></pre></td></tr></table></figure><p>综上：<br>append/prepend 是在选择元素内部嵌入。<br>after/before 是在元素外面追加。</p><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><ol><li><p>remove(可选参数) - 删除被选元素（及其子元素）</p></li><li><p>empty() - 从被选元素中删除子元素</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).remove(); <span class="comment">//整个元素删除</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">'div'</span>).empty();  <span class="comment">//删除所有选中元素的子元素</span></span><br></pre></td></tr></table></figure><p>remove() 方法可接受一个参数，允许对被删元素进行过滤</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).remove(<span class="string">'.div1'</span>)  <span class="comment">//删除所有类名为div1的div元素</span></span><br></pre></td></tr></table></figure><p> remove() 的过滤器删除时，不能删除带有过滤器的子元素</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"wwww"</span>&gt;</span>www<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hhh<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).remove(<span class="string">'.www'</span>); <span class="comment">// 错误，不可删除带过滤器的元素div的子元素p</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">'p'</span>).remove(<span class="string">'.www'</span>) <span class="comment">// 删除所有类名为www的p元素</span></span><br></pre></td></tr></table></figure><h4 id="获取并设置-CSS-类"><a href="#获取并设置-CSS-类" class="headerlink" title="获取并设置 CSS 类"></a>获取并设置 CSS 类</h4><ol><li><p>addClass() - 向被选元素添加一个或多个类</p></li><li><p>removeClass() - 从被选元素删除一个或多个类</p></li><li><p>toggleClass() - 对被选元素进行添加/删除类的切换操作</p></li><li><p>css() - 设置或返回被选元素的一个或多个样式属性。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).addClass(<span class="string">"div1 div2"</span>) <span class="comment">// 添加div1 div2 类给所有div元素</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">'div'</span>).removeClass(<span class="string">"div1 div2"</span>) <span class="comment">// 删除div1 div2 类给所有div元素</span></span><br></pre></td></tr></table></figure><p>上面代码等效于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).toggleClass(<span class="string">"div1 div2"</span>);</span><br></pre></td></tr></table></figure><p>css()语法：</p><p>css(“propertyname”); 只会返回首个匹配元素的css样式属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).css(<span class="string">"background-color"</span>);  <span class="comment">//返回首个匹配元素的div的背景颜色</span></span><br></pre></td></tr></table></figure><p>若需要修改css样式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).css(<span class="string">'background-color'</span>,<span class="string">'yellow'</span>); <span class="comment">//单个</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">"div"</span>).css(&#123;   <span class="comment">//修改多个</span></span><br><span class="line">    <span class="string">"background-color"</span>:<span class="string">"yellow"</span>,</span><br><span class="line">    <span class="string">"font-size"</span>:<span class="string">"2em"</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h4 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h4><ol><li><p>width():设置或返回元素的宽度（不包括内边距、边框或外边距）</p></li><li><p>height():设置或返回元素的高度（不包括内边距、边框或外边距）</p></li><li><p>innerWidth():返回元素的宽度（包括内边距）</p></li><li><p>innerHeight():返回元素的高度（包括内边距）</p></li><li><p>outerWidth():返回元素的宽度（包括内边距和边框）</p></li><li><p>outerHeight():返回元素的高度（包括内边距和边框）</p></li></ol><p><img src="/../img/9th.gif" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).width(<span class="string">'100px'</span>)   <span class="comment">//修改宽度为100px;</span></span><br></pre></td></tr></table></figure><p><strong>我明白你会来，所以我等。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery(part1)</title>
      <link href="/2018/07/21/eighthDay/"/>
      <url>/2018/07/21/eighthDay/</url>
      
        <content type="html"><![CDATA[<h2 id="jQuery效果"><a href="#jQuery效果" class="headerlink" title="jQuery效果"></a>jQuery效果</h2><a id="more"></a><h4 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h4><p>jQuery 入口函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 执行代码</span></span><br><span class="line">&#125;);</span><br><span class="line">或者</span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 执行代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>javscript入口函数:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两者区别：<br>jQuery 的入口函数是在 html 所有标签(DOM)都加载之后，就会去执行。<br>JavaScript 的 window.onload 事件是等到所有内容，包括外部图片之类的文件加载完后，才会执行。</p><h4 id="jQuery选择器-杂记"><a href="#jQuery选择器-杂记" class="headerlink" title="jQuery选择器(杂记)"></a>jQuery选择器(杂记)</h4><p>1.通过<figure class="highlight javascript"><figcaption><span>$(":button")``` 可以选取所有 type</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2.</span>关于 **:** 和 [ ] 这两个符号的理解</span><br><span class="line">**:** 可以理解为种类的意思，如：p:first，p 的种类为第一个。</span><br><span class="line">[ ] 很自然的可以理解为属性的意思，如：[href] 选取带有 href 属性的元素。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>**:** 即为 jQuery 的过滤选择器，语法类似于 css 中的伪类选择器；其过滤选择器大概可以分为基本过滤（p:first 之类）、内容过滤（:empty）、子元素过滤(:first-child)和属性过滤 [href] 选择器。</span><br><span class="line"></span><br><span class="line">#### 隐藏和显示</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">$(selector).hide(speed,callback);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$(selector).show(speed,callback);</span></span><br></pre></td></tr></table></figure></p><p>可选的 speed 参数规定隐藏/显示的速度，可以取以下值：”slow”、”fast” 或毫秒。<br>可选的 callback 参数是隐藏或显示完成后所执行的函数名称。</p><p>上面代码等效于toggle() 方法</p><p>示被隐藏的元素，并隐藏已显示的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).toggle(speed,callback);</span><br></pre></td></tr></table></figure><p>对于可选的 callback 参数，有以下两点说明：<br>1.$(selector)选中的元素的个数为n个，则callback函数会执行n次；<br>2.callback函数名后加括号，会立刻执行函数体,且只会执行一次，而不是等到显示/隐藏完成后才执行；<br>3.callback既可以是函数名，也可以是匿名函数</p><h4 id="淡入淡出"><a href="#淡入淡出" class="headerlink" title="淡入淡出"></a>淡入淡出</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(selector).fadeIn(speed,callback);</span><br><span class="line"></span><br><span class="line">$(selector).fadeOut(speed,callback);</span><br></pre></td></tr></table></figure><p>等效于fadeToggle()方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).fadeToggle(speed,callback);</span><br></pre></td></tr></table></figure><p>fadeTo() 方法允许渐变为给定的不透明度（值介于 0 与 1 之间）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).fadeTo(speed,opacity,callback);</span><br></pre></td></tr></table></figure><h4 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$(selector).slideDown(speed,callback);</span><br><span class="line"></span><br><span class="line">$(selector).slideUp(speed,callback);</span><br></pre></td></tr></table></figure><p>等效于slideToogle()方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$(selector).slideToggle(speed,callback);</span><br></pre></td></tr></table></figure><h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).animate(&#123;params&#125;,speed,callback);</span><br></pre></td></tr></table></figure><p>必需的 params 参数定义形成动画的 CSS 属性。<br>可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。<br>可选的 callback 参数是动画完成后所执行的函数名称。</p><p>{params}参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).animate(&#123;</span><br><span class="line">     left:<span class="string">'250px'</span>,     <span class="comment">// 向右移动250px</span></span><br><span class="line">     top:<span class="string">'250px'</span>,      <span class="comment">// 向下移动250px</span></span><br><span class="line">     paddingLeft:<span class="string">'50px'</span>,</span><br><span class="line">     marginRight:<span class="string">'50px'</span>,      </span><br><span class="line">     opacity:<span class="string">'0.5'</span>,    <span class="comment">// 透明度变为0.5</span></span><br><span class="line">     height:<span class="string">'150px'</span>,   <span class="comment">// 高度变为150px</span></span><br><span class="line">     width:<span class="string">'150px'</span>     <span class="comment">// 宽度变为150px</span></span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>也可以定义相对值（该值相对于元素的当前值）。需要在值的前面加上 += 或 -=：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).animate(&#123;</span><br><span class="line">    left:<span class="string">'+=250px'</span>,</span><br><span class="line">    height:<span class="string">'+=150px'</span>,</span><br><span class="line">    width:<span class="string">'+=150px'</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>还可以把属性的动画值设置为 “show”、”hide” 或 “toggle”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).animate(&#123;</span><br><span class="line">    height:<span class="string">'toggle'</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>编写多个 animate() 调用，jQuery 会创建包含这些方法调用的”内部”队列。然后逐一运行这些 animate 调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div=$(<span class="string">"div"</span>);</span><br><span class="line">div.animate(&#123;<span class="attr">height</span>:<span class="string">'300px'</span>,<span class="attr">opacity</span>:<span class="string">'0.4'</span>,<span class="attr">fontSize</span>:<span class="string">'1em'</span>&#125;,<span class="string">"slow"</span>);</span><br><span class="line">div.animate(&#123;<span class="attr">width</span>:<span class="string">'300px'</span>,<span class="attr">opacity</span>:<span class="string">'0.8,'</span>fontSize:<span class="string">'2em'</span>&#125;,<span class="string">"slow"</span>);</span><br><span class="line">div.animate(&#123;<span class="attr">height</span>:<span class="string">'100px'</span>,<span class="attr">opacity</span>:<span class="string">'0.4'</span>,<span class="attr">fontSize</span>:<span class="string">'1em'</span>&#125;,<span class="string">"slow"</span>);</span><br><span class="line">div.animate(&#123;<span class="attr">width</span>:<span class="string">'100px'</span>,<span class="attr">opacity</span>:<span class="string">'0.8'</span>,<span class="attr">fontSize</span>:<span class="string">'2em'</span>&#125;,<span class="string">"slow"</span>);</span><br></pre></td></tr></table></figure><h4 id="停止动画"><a href="#停止动画" class="headerlink" title="停止动画"></a>停止动画</h4><p>jQuery stop() 方法用于停止动画或效果，在它们完成之前。<br>stop() 方法适用于所有 jQuery 效果函数，包括滑动、淡入淡出和自定义动画。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).stop(stopAll,goToEnd);</span><br></pre></td></tr></table></figure><p>可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。<br>可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。<br>因此，默认地，stop() 会清除在被选元素上指定的当前动画。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#start"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   $(<span class="string">"div"</span>).animate(&#123;<span class="attr">left</span>:<span class="string">'100px'</span>&#125;,<span class="number">5000</span>);</span><br><span class="line">   $(<span class="string">"div"</span>).animate(&#123;<span class="attr">fontSize</span>:<span class="string">'3em'</span>&#125;,<span class="number">5000</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> $(<span class="string">"#stop"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   $(<span class="string">"div"</span>).stop();</span><br><span class="line"> &#125;);<span class="comment">//停止当前激活的动画，但之后能在动画队列中激活下一个动画。</span></span><br><span class="line"></span><br><span class="line"> $(<span class="string">"#stop2"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   $(<span class="string">"div"</span>).stop(<span class="literal">true</span>);</span><br><span class="line"> &#125;);<span class="comment">//停止当前动画，并清除动画队列，所以元素的所有动画都会停止。</span></span><br><span class="line"></span><br><span class="line"> $(<span class="string">"#stop3"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   $(<span class="string">"div"</span>).stop(<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line"> &#125;);<span class="comment">//快速完成当前动作，并停止所有动画。</span></span><br></pre></td></tr></table></figure><h4 id="链-Chaining"><a href="#链-Chaining" class="headerlink" title="链(Chaining)"></a>链(Chaining)</h4><p>链允许我们在一条语句中运行多个 jQuery 方法（在相同的元素上）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#p1"</span>).css(<span class="string">"color"</span>,<span class="string">"red"</span>).slideUp(<span class="number">2000</span>).slideDown(<span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>“p1” 元素首先会变为红色，然后向上滑动，再然后向下滑动</p><p><strong>你不愿意种花。你说，你不愿意看到它一点点凋落。是的，为了避免失败，你避免了一切开始。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax</title>
      <link href="/2018/07/20/ajax/"/>
      <url>/2018/07/20/ajax/</url>
      
        <content type="html"><![CDATA[<p>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p><a id="more"></a><p>Ajax技术用到了：</p><ol><li><p>XMLHttpRequest 对象 (异步的与服务器交换数据)</p></li><li><p>JavaScript/DOM (信息显示/交互)</p></li><li><p>CSS (给数据定义样式)</p></li><li><p>XML (作为转换数据的格式)</p></li></ol><p>Ajax四部曲：</p><ol><li>创建 XMLHttpRequest 对象</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlHttp ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">    <span class="comment">// IE 7+ 及主流浏览器</span></span><br><span class="line">    xmlHttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// IE 6</span></span><br><span class="line">    xmlHttp = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>向服务器发送请求</li></ol><p><strong>open(method,url,async):规定请求的类型</strong></p><p>method：请求的类型；GET 或 POST</p><p>url：文件在服务器上的位置</p><p>async：true（异步）或 false（同步）</p><p><strong>send():将请求发送到服务器</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"ajax_info.txt"</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure><p><strong>GET与POST</strong></p><p>GET：简单也更快</p><p>这些情况下是使用POST：</p><ol><li>无法使用缓存文件（更新服务器上的文件或数据库）</li><li>向服务器发送大量数据（POST 没有数据量限制）</li><li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li></ol><p>解决缓存问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"ajax_info.txt?t="</span> + <span class="built_in">Math</span>.random(),<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>获得服务器响应</li></ol><p>responseTest属性：返回字符串形式的响应</p><p>responseXML属性：获得 XML 形式的响应数据</p><p>响应服务器的响应</p><p>onreadystatechange 事件</p><p>XMLHttpRequest 对象的三个重要的属性</p><ol><li><p>onreadystatechange：存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数</p></li><li><p>readyState：    存有 XMLHttpRequest 的状态。从 0 到 4 发生变化</p><p> 0: 请求未初始化<br> 1: 服务器连接已建立<br> 2: 请求已接收<br> 3: 请求处理中<br> 4: 请求已完成，且响应已就绪</p></li><li><p>status：</p><p> 200：服务器响应正常。<br> 304：该资源在上次请求之后没有任何修改（这通常用于浏览器的缓存机制，使用GET请求时尤其需要注意）。<br> 400：无法找到请求的资源。<br> 401：访问资源的权限不够。<br> 403：没有权限访问资源。<br> 404：需要访问的资源不存在。<br> 405：需要访问的资源被禁止。<br> 407：访问的资源需要代理身份验证。<br> 500：服务器内部错误<br> 502：服务器暂时不可用，有时是为了防止发生系统过载</p></li></ol><p>判断是否成功</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AJAx实例：</p><p><a href="http://www.runoob.com/ajax/ajax-examples.html" target="_blank" rel="noopener">http://www.runoob.com/ajax/ajax-examples.html</a></p><p><strong>生如夏花般绚烂，死如秋叶般静美</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this</title>
      <link href="/2018/07/19/seventhDay/"/>
      <url>/2018/07/19/seventhDay/</url>
      
        <content type="html"><![CDATA[<p>写this前，先用new操作符，call，apply，bind方法做铺垫</p><a id="more"></a><h2 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h2><p>当代码 new Fn(…) 执行时，会发生以下事情：</p><ol><li><p>一个继承自 Fn.prototype 的新对象被创建。</p></li><li><p>使用指定的参数调用构造函数 Fn ，并将 this 绑定到新创建的对象。</p></li><li><p>由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回(return)一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）</p></li></ol><p>new的操作<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Fn();</span><br></pre></td></tr></table></figure></p><p>一条代码等价于以下四步</p><ol><li>创建空对象</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　  <span class="keyword">var</span> obj = &#123;&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>设置新对象的constructor属性为构造函数的名称，设置新对象的<strong>proto</strong>属性指向构造函数的prototype对象</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　 obj.__proto__ = Fn.prototype;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>使用新对象调用函数，函数中的this被指向新实例对象。{}.构造函数(); Fn对象调用了含this的构造函数，故函数this指向Fn对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fn.call(obj);</span><br></pre></td></tr></table></figure></li><li><p>将初始化完毕的新对象地址，保存到等号左边的变量中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = Fn;</span><br></pre></td></tr></table></figure></li></ol><p>综合四步得出过程代码为<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.b = <span class="number">1</span> ;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> obj = &#123;&#125; ;</span><br><span class="line"> obj.__proto__ = Fn.prototype ;</span><br><span class="line"> Fn.call(obj);</span><br><span class="line"> <span class="keyword">var</span> a = obj ;</span><br><span class="line"> <span class="built_in">console</span>.log(a.b);   <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><p>构造函数如存在返回值，要分三种情况 </p><ol><li>如果返回值是一个对象，那么this指向的就是那个返回的对象。如return {} 或 return function(){} 则this指向返回值</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Fn();  </span><br><span class="line"><span class="built_in">console</span>.log(f.a); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><ol start="2"><li>如果返回值不是一个对象那么this还是指向函数的实例。如 return undefined 或者return 1 ,return ‘string’</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Fn();  </span><br><span class="line"><span class="built_in">console</span>.log(f.a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><ol start="3"><li>null是对象，但this还是指向那个函数的实例。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Fn();  </span><br><span class="line"><span class="built_in">console</span>.log(f.a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>ps： 箭头函数不能进行new操作</p><h2 id="call-apply和bind"><a href="#call-apply和bind" class="headerlink" title="call,apply和bind"></a>call,apply和bind</h2><p>call()方法和apply()方法相似，第一个参数都是this值，区别在于第二个参数，call()为指定的参数列表,而apply()为参数的数组。</p><p>call()和apply()能够扩充函数赖以运行的作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Window.num = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    num : <span class="number">2</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.num);   </span><br><span class="line">&#125;</span><br><span class="line">Fn();                         <span class="comment">// 1   默认Window</span></span><br><span class="line">Fn.call(obj) ;                <span class="comment">// 2</span></span><br><span class="line">Fn.call(Window);              <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>bind()方法会创建一个函数的实例，其this值会被绑定传给bind()的第一个参数，且该参数不能被重写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Window.num = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    num : <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> oFn = Fn.bind(obj);</span><br><span class="line">oFn();    <span class="comment">//  2</span></span><br></pre></td></tr></table></figure><p>用bind()方法，不管oFn函数在哪个环境下执行，其this都被绑定到obj上。</p><h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><p>this指的是函数运行时所在的环境，而非函数定义时的环境，其this值在函数运行的时候才确定，并且可以更据运行环境的改变而改变。</p><p><a href="https://www.cnblogs.com/pssp/p/5216085.html" target="_blank" rel="noopener">https://www.cnblogs.com/pssp/p/5216085.html</a></p><h4 id="几个this指向的实例-以下代码都在非严格模式下运行"><a href="#几个this指向的实例-以下代码都在非严格模式下运行" class="headerlink" title="几个this指向的实例(以下代码都在非严格模式下运行)"></a>几个this指向的实例(以下代码都在非严格模式下运行)</h4><ol><li>this最终指向的是调用它的对象，这里的函数Fn实际是被Window对象所点出来的</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Window.a = <span class="number">2</span> ;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">//2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//Window</span></span><br><span class="line">&#125;</span><br><span class="line">Fn();  <span class="comment">// 全等于 Window.Fn(); </span></span><br><span class="line"><span class="built_in">console</span>.log(Fn === Window.Fn);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>在全局定义的变量和函数其实都是给Window对象创建属性。</p><ol start="2"><li>这里的函数Fn实际上是被obj对象所调用的，this在函数运行的时候才确定，而非定义的时候。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Window.a = <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a : <span class="number">1</span> ,</span><br><span class="line">    Fn : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">obj.Fn();   <span class="comment">//    1   等效于Window.obj.Fn()   </span></span><br><span class="line"><span class="built_in">console</span>.log(obj.Fn === Window.obj.Fn) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Window对象通过调用obj对象来调用Fn函数，但Fn()里面的this不指向Window，原因请看第三个实例。</p><p>3.多重调用的情况</p><ol><li><p>如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是Window。如实例1.</p></li><li><p>如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。如实例2.</p></li><li><p>果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a : <span class="number">1</span>,</span><br><span class="line">    b : &#123;</span><br><span class="line">        <span class="comment">// a : 2,</span></span><br><span class="line">        Fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    obj.b.Fn();   <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>不管上一级对象(b对象)中有没有a属性，this指向的也是对象b，因为this只会指向它的上一级对象，不管这个对象中有没有this要的东西。</p><p>4.在下面这个特殊情况下，Fn并没有被b调用，只是把obj.b.Fn的地址赋值给了f，而f()才是调用了该函数，此时相当于Window.f(),故this为Window。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    Window.a = <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a : <span class="number">1</span>,</span><br><span class="line">    b : &#123;</span><br><span class="line">        a : <span class="number">2</span>,</span><br><span class="line">        Fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">var</span> f = obj.b.Fn;</span><br><span class="line">    f();    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="this存在的原因"><a href="#this存在的原因" class="headerlink" title="this存在的原因"></a>this存在的原因</h3><p><a href="http://www.ruanyifeng.com/blog/2018/06/javascript-this.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/06/javascript-this.html</a></p><h4 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h4><p>对象是属性的集合，而属性又拥有特性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span> : <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure><p>实际上是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj =&#123;</span><br><span class="line">        a: &#123;    </span><br><span class="line">            [[value]]: <span class="number">1</span></span><br><span class="line">            [[writable]]: <span class="literal">true</span></span><br><span class="line">            [[enumerable]]: <span class="literal">true</span></span><br><span class="line">            [[configurable]]: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若一个属性存着一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    Fn :&#123;  </span><br><span class="line">        [[value]]: 函数的地址</span><br><span class="line">        [[writable]]: <span class="literal">true</span></span><br><span class="line">        [[enumerable]]: <span class="literal">true</span></span><br><span class="line">        [[configurable]]: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为函数是单独的值可以在不同(上下文)环境运行(变量有作用域)</p><p>而javaScript允许在函数体内部，引用当前环境的其他变量,而函数又可以在不同环境下运行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);  <span class="comment">//若不加this 默认为Window.a</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj =&#123;</span><br><span class="line">    a : <span class="number">1</span> ,</span><br><span class="line">    Fn : Fn</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">Fn();        <span class="comment">// 2   在Window环境下</span></span><br><span class="line">obj.Fn();    <span class="comment">// 1   在obj环境下</span></span><br></pre></td></tr></table></figure><p>为了确定函数所调用的变量是在哪个环境下的，就需要有一种机制，能够在函数体内部获得当前的运行环境。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。</p><p><strong>因为无能为力,所以顺其自然。</strong><br><strong>因为心无所恃,所以随遇而安。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> new </tag>
            
            <tag> call(),apply(),bind() </tag>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIFE 箭头函数</title>
      <link href="/2018/07/19/sixthDay/"/>
      <url>/2018/07/19/sixthDay/</url>
      
        <content type="html"><![CDATA[<h2 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h2><a id="more"></a><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F</a></p><p>IIFE(立即调用函数表达式)是一个在定义时就会立即执行的JavaScript函数。</p><p>第一部分是包围在圆括号运算符() 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。</p><p>第二部分再一次使用 () 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">console</span>.log(a) ; <span class="comment">// 1</span></span><br><span class="line">&#125;)() ;</span><br><span class="line"><span class="built_in">console</span>.log(a) ;  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>若是想要创建一个独立的块级作用域，可以用let，不必用IIFE<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将 IIFE 分配给一个变量，不是存储 IIFE 本身，而是存储 IIFE 执行后返回的结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">var</span> b = <span class="number">1</span> ;</span><br><span class="line"> <span class="built_in">console</span>.log(b);   <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> b +<span class="number">1</span> ;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a></p><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><ol><li><p>(参数1, 参数2, …, 参数N) =&gt; { 函数声明 }</p></li><li><p>(参数1, 参数2, …, 参数N) =&gt; 表达式（单一）<br>//相当于：(参数1, 参数2, …, 参数N) =&gt;{ return 表达式; }</p></li><li><p>// 当只有一个参数时，圆括号是可选的：<br>(单一参数) =&gt; {函数声明}<br>单一参数 =&gt; {函数声明}</p></li><li><p>// 没有参数的函数应该写成一对圆括号。<br>() =&gt; {函数声明}</p></li></ol><h4 id="不绑定this"><a href="#不绑定this" class="headerlink" title="不绑定this"></a>不绑定this</h4><p>一般函数的this指向该函数内部<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">growUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age++;    <span class="comment">// growUp()函数内部的this.age未定义</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)   <span class="comment">// NaN</span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">2</span>;  <span class="comment">// 定义growUp()函数内部的this.age</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);  <span class="comment">// 2</span></span><br><span class="line">  &#125;, <span class="number">1000</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure></p><p><strong>箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.age++;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age) <span class="comment">// 1</span></span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>因为箭头函数没有自己的this指针，通过call()或apply()方法调用一个函数时，只能传递参数(不能绑定this),他们的第一个参数会被忽略。</p><h4 id="不绑定arguments"><a href="#不绑定arguments" class="headerlink" title="不绑定arguments"></a>不绑定arguments</h4><p><strong>一般函数绑定arguments</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">arguments</span>=[<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]) ;   <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]) ;   <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">a(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><p><strong>箭头函数没有内置arguments</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">arguments</span>=[<span class="number">3</span>,<span class="number">4</span>];<span class="comment">//如取消定义arguments，则会报错arguments is not defined</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">x,y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]) ;   <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]) ;   <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p><strong>使用剩余参数是相较使用arguments对象的更好选择。 (…arr)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr =[<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">...arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[<span class="number">0</span>]);          <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr[<span class="number">1</span>]);          <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>剩余参数和 arguments对象之间的区别主要有三个：</p><ol><li>剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。</li><li>arguments对象不是一个真正的数组，而剩余参数是真正的 Array实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach或pop。</li><li>arguments对象还有一些附加的属性 （如callee属性）。</li></ol><h4 id="不能使用new操作符"><a href="#不能使用new操作符" class="headerlink" title="不能使用new操作符"></a>不能使用new操作符</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(); <span class="comment">// TypeError: Foo is not a constructor</span></span><br></pre></td></tr></table></figure><h4 id="没有prototype属性"><a href="#没有prototype属性" class="headerlink" title="没有prototype属性"></a>没有prototype属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h4 id="箭头函数注意点"><a href="#箭头函数注意点" class="headerlink" title="箭头函数注意点"></a>箭头函数注意点</h4><p><strong>返回对象字面量</strong></p><p>花括号会被解析为函数执行体，而不是return { foo: 1}，故需要将对象用括号括起来<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;;</span><br><span class="line">func()   <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;);</span><br><span class="line">func()   <span class="comment">//&#123;foo: 1&#125;</span></span><br></pre></td></tr></table></figure><p><strong>不能换行写箭头函数</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f= ()</span><br><span class="line">           =&gt; <span class="number">1</span>;   <span class="comment">//报错</span></span><br></pre></td></tr></table></figure></p><p><strong>解析顺序</strong></p><p>虽然箭头函数中的箭头不是运算符，但箭头函数具有与常规函数不同的特殊运算符优先级解析规则。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> callback;</span><br><span class="line"></span><br><span class="line">callback = callback || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">callback = callback || <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;      </span><br><span class="line"><span class="comment">// SyntaxError: invalid arrow-function arguments</span></span><br><span class="line"></span><br><span class="line">callback = callback || <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;&#125;);    <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><h4 id="箭头函数一些实例"><a href="#箭头函数一些实例" class="headerlink" title="箭头函数一些实例"></a>箭头函数一些实例</h4><p>与数组迭代方法的结合<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">18</span>, <span class="number">23</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);  </span><br><span class="line"><span class="comment">// 66</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> even = arr.filter(<span class="function"><span class="params">v</span> =&gt;</span> v % <span class="number">2</span> == <span class="number">0</span>); </span><br><span class="line"><span class="comment">// [6, 0, 18]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> double = arr.map(<span class="function"><span class="params">v</span> =&gt;</span> v * <span class="number">2</span>);       </span><br><span class="line"><span class="comment">// [10, 12, 26, 0, 2, 36, 46]</span></span><br></pre></td></tr></table></figure></p><p>箭头函数内定义的变量及其作用域</p><p>箭头函数内部var一个变量，外界用不到，因为箭头函数有独立块级作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a =<span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">//  a is not defined</span></span><br></pre></td></tr></table></figure><p>箭头函数内部不用var，为全局变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    a =<span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">//  1</span></span><br></pre></td></tr></table></figure></p><p>箭头函数参数直接声明一个变量，仍为局部变量(实际上即使不用箭头函数，参数直接声明的变量都是局部变量)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);    <span class="comment">//1</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">a = <span class="number">1</span></span>) =&gt;</span> &#123; </span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//a is not defined</span></span><br></pre></td></tr></table></figure></p><p><strong>天下只有两种人。譬如一串葡萄到手，一种人挑最好的先吃，另一种人把最好的留在最后吃。照例第一种人应该乐观，因为他每吃一颗都是吃剩的葡萄里面最好的;第二种人应该悲观，因为他每吃一颗都是吃剩葡萄里最坏的。不过事实上适得其反，缘故是第二种人还有希望，第一种人只有回忆。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> IIFE </tag>
            
            <tag> 箭头函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型</title>
      <link href="/2018/07/18/fifthDay/"/>
      <url>/2018/07/18/fifthDay/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/wangfupeng1988/p/3977987.html" target="_blank" rel="noopener">http://www.cnblogs.com/wangfupeng1988/p/3977987.html</a></p><h3 id="对象-属性-函数的关系"><a href="#对象-属性-函数的关系" class="headerlink" title="对象 属性 函数的关系"></a>对象 属性 函数的关系</h3><h6 id="一切（引用类型）都是对象，对象是属性的集合"><a href="#一切（引用类型）都是对象，对象是属性的集合" class="headerlink" title="一切（引用类型）都是对象，对象是属性的集合"></a>一切（引用类型）都是对象，对象是属性的集合</h6><p>基础类型的类型判断用typeof，引用类型的类型判断用instanceof。而基础包装类型也是对象。</p><a id="more"></a><p>对象里面只有属性，没有方法。在对象里面的方法，实际上会和属性配对。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a : <span class="number">10</span> ;</span><br><span class="line">    b : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="对象都是通过函数创建的"><a href="#对象都是通过函数创建的" class="headerlink" title="对象都是通过函数创建的"></a>对象都是通过函数创建的</h6><p>通过语法糖创建的对象或数组等，实际上都是通过Object(),Array()等函数创建的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var obj = &#123; a: 1, b: 2 &#125;;  和下面代码等效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.a = <span class="number">1</span>;</span><br><span class="line">obj.b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//var arr = [1, '1', true];  和下面代码等效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">'1'</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>函数是对象，但是函数不能算是对象的子集，因为对象是由函数创建的。</p><h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><h5 id="每个函数都有一个属性叫做prototype"><a href="#每个函数都有一个属性叫做prototype" class="headerlink" title="每个函数都有一个属性叫做prototype"></a>每个函数都有一个属性叫做prototype</h5><p>这个prototype的属性值是一个对象(属性的集合),而这个对象里面有constructor的属性，指向这个函数本身。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            a: xxx</span><br><span class="line">            b: xxx</span><br><span class="line">    prototype:&#123;</span><br><span class="line">                <span class="keyword">constructor</span>: Fn()</span><br><span class="line">                a : xxx</span><br><span class="line">                b : xxx</span><br><span class="line">              &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="每个对象都有一个proto属性"><a href="#每个对象都有一个proto属性" class="headerlink" title="每个对象都有一个proto属性"></a>每个对象都有一个<strong>proto</strong>属性</h5><ol><li><p>每个对象都有一个<strong>proto</strong>属性，指向创建该对象的函数的prototype。</p></li><li><p>obj.<strong>proto</strong> === Object.prototype</p></li><li><p>Object.prototype是一个特例，它的<strong>proto</strong>指向的是null。</p></li><li><p>A Instanceof B .Instanceof的判断规则：</p></li></ol><p>沿着A的<strong>proto</strong>这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。</p><p><img src="/../img/proto.png" alt=""></p><p><strong>instanceof表示的就是一种继承关系，或者原型链的结构</strong></p><h2 id="原型链-继承"><a href="#原型链-继承" class="headerlink" title="原型链(继承)"></a>原型链(继承)</h2><p>访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着<strong>proto</strong>这条链向上找，这就是原型链。</p><h5 id="javascript中的继承是通过原型链来体现的"><a href="#javascript中的继承是通过原型链来体现的" class="headerlink" title="javascript中的继承是通过原型链来体现的"></a>javascript中的继承是通过原型链来体现的</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="keyword">new</span> Fn();</span><br><span class="line">    f.a = <span class="number">1</span>;    <span class="comment">//  继承等级为1</span></span><br><span class="line"></span><br><span class="line">    Fn.prototype.a = <span class="number">2</span>;   <span class="comment">//继承等级为2</span></span><br><span class="line">    Fn.prototype.b = <span class="number">1</span>;   <span class="comment">//继承等级为2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个是Function.prototype  不能通过原型链到达f </span></span><br><span class="line">    Fn.__proto__.b = <span class="number">2</span> ;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个是给Object.prototype添加属性C f可通过原形链访问 继承等级为3</span></span><br><span class="line">    Fn.__proto__.__proto__.b = <span class="number">2</span> ;  </span><br><span class="line">    <span class="comment">// 这个是给Object.prototype添加属性C f可通过原形链访问 继承等级为3</span></span><br><span class="line">    Fn.__proto__.__proto__.c = <span class="number">1</span> ;  </span><br><span class="line">    <span class="comment">//  这个是给Object.prototype添加属性C f可通过原形链访问 继承等级为3</span></span><br><span class="line">    Fn.prototype.__proto__.d = <span class="number">1</span>;   </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(f.a);   <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(f.b);   <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(f.c);   <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(f.d);   <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(Fn.__proto__ === <span class="built_in">Function</span>.prototype);  <span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(Fn.__proto__.__proto__ === <span class="built_in">Object</span>.prototype);  <span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(Fn.prototype.__proto__ === <span class="built_in">Object</span>.prototype);  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>继承等级 1&gt;2&gt;3 </p><h4 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a>hasOwnProperty()</h4><p>hasOwnProperty()来自Object.prototype，是区分一个属性到底是基本的还是从原型中找到的方法<br>在for…in…循环中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="keyword">var</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i <span class="keyword">in</span> f)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f.hasOwnProperty(i))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);  <span class="comment">// 这里的属性都是f自己的，而不是继承来的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>叶子的离开，</strong></p><p><strong>是风的多情，</strong></p><p><strong>还是树的不挽留。</strong></p><p><strong>你我的离别，</strong></p><p><strong>是人生的催促，</strong></p><p><strong>还是青春的不停留。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript原型及原型链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组迭代与归并</title>
      <link href="/2018/07/17/4thDay/"/>
      <url>/2018/07/17/4thDay/</url>
      
        <content type="html"><![CDATA[<h2 id="数组迭代方法"><a href="#数组迭代方法" class="headerlink" title="数组迭代方法"></a>数组迭代方法</h2><a id="more"></a><h5 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h5><p>对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。 </p><h5 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h5><p>对数组中的每一项运行给定函数，返回该函数会返回true 的项组成的数组。</p><h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h5><p>对数组中的每一项运行给定函数。这个方法没有返回值。 </p><h5 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h5><p>对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 </p><h5 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h5><p>对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true. </p><h4 id="对数组迭代方法的几点说明"><a href="#对数组迭代方法的几点说明" class="headerlink" title="对数组迭代方法的几点说明"></a>对数组迭代方法的几点说明</h4><ol><li>every()，与some()的关系就像和与或的关系，every()一假全假，some()一真全真。</li><li>filter()返回的是一个符合某种条件的数组。 </li><li>forEach()没有返回值，可代替for循环。</li><li>map()返回的是经过某种处理的数组。</li></ol><h2 id="数组归并方法"><a href="#数组归并方法" class="headerlink" title="数组归并方法"></a>数组归并方法</h2><p><a href="https://www.jianshu.com/p/2d396b10afe0" target="_blank" rel="noopener">https://www.jianshu.com/p/2d396b10afe0</a></p><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h5><p>迭代数组中的所有值，返回一个按条件计算的最终值。reduce是从数组的开始逐个遍历到最后。</p><p>reduce()方法接受两个参数:一个在每一项上调用的函数和（可选的）作为归并基础的初始值。</p><ol><li>调用的函数有四个参数：前一个值，当前值，项的索引和数组对象。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 reduce() 方法可以执行求数组里所有值之和的操作</span></span><br><span class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = nums.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(prev);  <span class="comment">// 依次输出 1， 3， 6</span></span><br><span class="line">  <span class="built_in">console</span>.log(cur);   <span class="comment">// 依次输出 2， 3， 4</span></span><br><span class="line">  <span class="built_in">console</span>.log(index); <span class="comment">// 依次输出 1, 2, 3</span></span><br><span class="line">  <span class="built_in">console</span>.log(array); <span class="comment">// 每次都输出原数组 [1,2,3,4]</span></span><br><span class="line">  <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><ol start="2"><li>归并基础的初始值也规定了归并的数据类型，数组可以用{}，数字可以用0。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> a= <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> sum = nums.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(prev);  <span class="comment">// 依次输出 5， 6， 8， 11</span></span><br><span class="line">  <span class="built_in">console</span>.log(cur);   <span class="comment">// 依次输出 1， 2， 3， 4</span></span><br><span class="line">  <span class="built_in">console</span>.log(index); <span class="comment">// 依次输出 0,  1,  2,  3</span></span><br><span class="line">  <span class="built_in">console</span>.log(array); <span class="comment">// 每次都输出原数组 [1,2,3,4]</span></span><br><span class="line">  <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;, a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p><strong>天空没有翅膀的痕迹，而我已飞过</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数组迭代与归并 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>let,const</title>
      <link href="/2018/07/16/let,const/"/>
      <url>/2018/07/16/let,const/</url>
      
        <content type="html"><![CDATA[<h2 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h2><p><a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/let</a></p><a id="more"></a><h4 id="let基本用法"><a href="#let基本用法" class="headerlink" title="let基本用法"></a>let基本用法</h4><p>用let声明的变量，只会在其所在代码块内有效，例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i =<span class="number">1</span> ;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> i =<span class="number">2</span> ;</span><br><span class="line">    <span class="built_in">console</span>.log(i);    <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i)         <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>var声明的i和let声明的i实际上的储存地址是不一样的，两者为独立变量。<br>在let命令的代码块外是取不到let声明的变量的，而var可以。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);         <span class="comment">//  a is no defined</span></span><br><span class="line"><span class="built_in">console</span>.log(b);         <span class="comment">//  1</span></span><br></pre></td></tr></table></figure><p>另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="string">"1 bin"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将打印三次 1 bin</span></span><br></pre></td></tr></table></figure><p>let的作用相当于限定了变量的执行环境在其代码块内，用let命令声明变量之前，该变量都是不可用的</p><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  a = <span class="number">1</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> a; <span class="comment">// 在此之上全为暂时性死区</span></span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不存在变量提升也不能重复声明"><a href="#不存在变量提升也不能重复声明" class="headerlink" title="不存在变量提升也不能重复声明"></a>不存在变量提升也不能重复声明</h4><p>因为暂时性死去的存在，let和const都是没有变量提升的，而var存在变量提升，即变量可以在声明之前使用，值为undefined。</p><p>不能重复声明是指不能在同一个块级作用域内对同一个变量声明两次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2</span> ; <span class="comment">// ReferenceError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">2</span>;</span><br><span class="line">a  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span> ;</span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>而ES6规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span> ;</span><br><span class="line">widndow.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h4 id="let的主要应用"><a href="#let的主要应用" class="headerlink" title="let的主要应用"></a>let的主要应用</h4><h5 id="应用1"><a href="#应用1" class="headerlink" title="应用1"></a>应用1</h5><p>let声明的变量具有不可被外界所干扰的特点，故适合用于循环变量,这样将不会造成变量泄露<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; <span class="number">6</span> ; i++)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);    <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure></p><h5 id="应用2"><a href="#应用2" class="headerlink" title="应用2"></a>应用2</h5><p>let造成的块级作用域取代了立即执行函数表达式（IIFE）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE 写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a= <span class="number">1</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h2><h4 id="const实质"><a href="#const实质" class="headerlink" title="const实质"></a>const实质</h4><p>const实质是指变量指向的那个内存地址不得改动。对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。</p><p>不过可以通过调用Object.freeze方法来冻结对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">a.num = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><h4 id="const性质"><a href="#const性质" class="headerlink" title="const性质"></a>const性质</h4><p>const具有以下性质</p><ol><li>存在暂时性死区</li><li>不能重复声明（同一个块级作用域内）</li><li>不存在变量提升</li><li>声明后必须赋初值（与let的不同点）   </li></ol><p><strong>别人稍一注意你，你就敞开心扉。你以为这是坦率，其实这是孤独。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> let </tag>
            
            <tag> const </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>canvas 2d</title>
      <link href="/2018/07/15/thirdDay/"/>
      <url>/2018/07/15/thirdDay/</url>
      
        <content type="html"><![CDATA[<p>canvas参考手册 <a href="http://www.runoob.com/tags/ref-canvas.html" target="_blank" rel="noopener">http://www.runoob.com/tags/ref-canvas.html</a></p><h3 id="canvas钟的制作"><a href="#canvas钟的制作" class="headerlink" title="canvas钟的制作"></a>canvas钟的制作</h3><a id="more"></a><h4 id="钟的静态样式"><a href="#钟的静态样式" class="headerlink" title="钟的静态样式"></a>钟的静态样式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawBackground</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    context.save();  <span class="comment">//保存初始状态的幕布环境</span></span><br><span class="line">    context.beginPath();  <span class="comment">//重新开始一条路径</span></span><br><span class="line">    context.arc(<span class="number">200</span>,<span class="number">200</span>,r,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,<span class="literal">true</span>); <span class="comment">//画大圆 圆心(200,200)，半径为r，从0到2pi，true表示逆时针 </span></span><br><span class="line">    context.moveTo(<span class="number">295</span>,<span class="number">200</span>);</span><br><span class="line">    context.arc(<span class="number">200</span>,<span class="number">200</span>,r<span class="number">-5</span>,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,<span class="literal">false</span>);<span class="comment">//画小圆 圆心(200,200)，半径为r-5，从0到2pi，false表示顺时针 </span></span><br><span class="line">    context.translate(<span class="number">200</span>,<span class="number">200</span>); <span class="comment">//重新定义画布原点为（200，200）</span></span><br><span class="line">    context.stroke();           <span class="comment">//画路径（路径为非填充）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> aNumbers = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">2</span>]; <span class="comment">//以x正半轴为起点，顺时针旋转</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//文本字体信息 居中</span></span><br><span class="line">    context.font = <span class="string">'18px Arial'</span>;   </span><br><span class="line">    context.textAlign = <span class="string">'center'</span>;   </span><br><span class="line">    context.textBaseline = <span class="string">'middle'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画12个数字</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;aNumbers.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> rad = <span class="number">2</span>*<span class="built_in">Math</span>.PI /<span class="number">12</span> *( aNumbers[i]<span class="number">-3</span>);</span><br><span class="line">        <span class="keyword">var</span> x = <span class="built_in">Math</span>.cos(rad) * (r<span class="number">-20</span>);</span><br><span class="line">        <span class="keyword">var</span> y = <span class="built_in">Math</span>.sin(rad) * (r<span class="number">-20</span>);</span><br><span class="line"></span><br><span class="line">        context.fillText(aNumbers[i],x,y);<span class="comment">//给坐标（x,y）添加文本aNumbers[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="钟的秒针"><a href="#钟的秒针" class="headerlink" title="钟的秒针"></a>钟的秒针</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawSecond</span>(<span class="params">second</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> rad = <span class="number">2</span>*<span class="built_in">Math</span>.PI / <span class="number">60</span> *second ;</span><br><span class="line"></span><br><span class="line">    context.save();</span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.rotate(rad);</span><br><span class="line">    context.moveTo(<span class="number">2</span>,<span class="number">20</span>);</span><br><span class="line">    context.lineTo(<span class="number">-2</span>,<span class="number">20</span>);</span><br><span class="line">    context.lineTo(<span class="number">-1</span>,-r+<span class="number">18</span>)</span><br><span class="line">    context.lineTo(<span class="number">1</span>,-r+<span class="number">18</span>);</span><br><span class="line">    context.fillStyle=<span class="string">"red"</span>;</span><br><span class="line">    context.fill();</span><br><span class="line">    context.restore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="秒针转动"><a href="#秒针转动" class="headerlink" title="秒针转动"></a>秒针转动</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> width = context.canvas.width;</span><br><span class="line">    <span class="keyword">var</span> height = context.canvas.height;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">var</span> hour = now.getHours();</span><br><span class="line">    <span class="keyword">var</span> minute = now.getMinutes();</span><br><span class="line">    <span class="keyword">var</span> second = now.getSeconds();</span><br><span class="line"></span><br><span class="line">    context.clearRect(<span class="number">0</span>,<span class="number">0</span>,width,height); <span class="comment">//清除画布 从（0，0）开始的矩形</span></span><br><span class="line">    drawBackground();                <span class="comment">//画静态钟</span></span><br><span class="line">    drawSecond(second);               <span class="comment">//画秒针</span></span><br><span class="line">    context.restore();                </span><br><span class="line">&#125;</span><br><span class="line">    draw();</span><br><span class="line">    <span class="keyword">var</span> timer = setInterval(draw,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h2 id="canvas的一些方法"><a href="#canvas的一些方法" class="headerlink" title="canvas的一些方法"></a>canvas的一些方法</h2><h5 id="save-和restore"><a href="#save-和restore" class="headerlink" title="save()和restore()"></a>save()和restore()</h5><p>save():    保存当前环境的状态。<br>restore():    返回之前保存过的路径状态和属性。<br>这两个经常搭配起来用，适合只想对画布某些方面做出修改的情况。</p><h5 id="clearRect"><a href="#clearRect" class="headerlink" title="clearRect()"></a>clearRect()</h5><p>给定矩形清除像素，通常用于图形变换（删了重画）</p><h5 id="drawImage-和createPattern"><a href="#drawImage-和createPattern" class="headerlink" title="drawImage()和createPattern()"></a>drawImage()和createPattern()</h5><p>html为canvas内嵌img标签<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> image = <span class="built_in">document</span>.images[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>); </span><br><span class="line"></span><br><span class="line">ctx.drawImage(image,<span class="number">0</span>,<span class="number">10</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">40</span>,<span class="number">40</span>);</span><br></pre></td></tr></table></figure></p><p>模式，即所谓图片的重复<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = ctx.createPattern(image,<span class="string">"repeat"</span>);</span><br><span class="line"></span><br><span class="line">ctx.fillStyle = pattern ;</span><br><span class="line">ctx.fillRect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">500</span>,<span class="number">500</span>);</span><br></pre></td></tr></table></figure></p><h5 id="shadow"><a href="#shadow" class="headerlink" title="shadow"></a>shadow</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置阴影</span></span><br><span class="line">ctx.shadowOffsetX = <span class="number">5</span>;</span><br><span class="line">ctx.shadowOffsetY = <span class="number">5</span>;</span><br><span class="line">ctx.shadowBlur = <span class="number">4</span>;   <span class="comment">//模糊度,0为不模糊</span></span><br><span class="line">ctx.shadowColor = <span class="string">'rgba(0,0,0,0.5)'</span></span><br><span class="line"></span><br><span class="line">ctx.fillStyle =<span class="string">'red'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">ctx.fillStyle = <span class="string">'blue'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">200</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">300</span>);</span><br></pre></td></tr></table></figure><h5 id="gradient"><a href="#gradient" class="headerlink" title="gradient"></a>gradient</h5><p>水平渐变<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用函数来确保起点到终点的渐变</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRectLinearGradient</span>(<span class="params">ctx,x,y,width,height</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ctx.createLinearGradient(x,y,x+width,y+height);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>).getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> grd = createRectLinearGradient(ctx,<span class="number">100</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">200</span>);  <span class="comment">// (100,100)到（300，300）的渐变</span></span><br><span class="line">grd.addColorStop(<span class="number">0</span>,<span class="string">'blue'</span>);  <span class="comment">//起点</span></span><br><span class="line">grd.addColorStop(<span class="number">0.5</span>,<span class="string">'green'</span>);</span><br><span class="line">grd.addColorStop(<span class="number">1</span>,<span class="string">'red'</span>);  <span class="comment">//终点</span></span><br><span class="line"></span><br><span class="line">ctx.fillStyle = grd;</span><br><span class="line">ctx.fillRect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">200</span>)   <span class="comment">//起点（100，100） 长宽 50px</span></span><br></pre></td></tr></table></figure></p><p>径向渐变<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同心圆</span></span><br><span class="line"><span class="keyword">var</span> grd = ctx.createRadialGradient(<span class="number">150</span>,<span class="number">150</span>,<span class="number">100</span>,<span class="number">150</span>,<span class="number">150</span>,<span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">grd.addColorStop(<span class="number">0</span>,<span class="string">'blue'</span>);  <span class="comment">//起点</span></span><br><span class="line">grd.addColorStop(<span class="number">0.5</span>,<span class="string">'green'</span>);</span><br><span class="line">grd.addColorStop(<span class="number">1</span>,<span class="string">'red'</span>);  <span class="comment">//终点</span></span><br><span class="line"></span><br><span class="line">ctx.fillStyle = grd ;</span><br><span class="line">ctx.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">300</span>,<span class="number">300</span>);</span><br></pre></td></tr></table></figure></p><p><strong>如果事与愿违，请相信另有安排。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> canvas 2d </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件冒泡，捕获，委托</title>
      <link href="/2018/07/14/3th/"/>
      <url>/2018/07/14/3th/</url>
      
        <content type="html"><![CDATA[<h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>事件冒泡：事件到达事件目标之后不会结束，会逐层向上冒泡，直至<code>document</code>对象。<br>简单来说就是给子级的一个事件触发后，该事件也会先后作用于其父级。</p><a id="more"></a><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"grandfather"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"son"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> grandfather = <span class="built_in">document</span>.getElementById(<span class="string">'grandfather'</span>);</span><br><span class="line">        <span class="keyword">var</span> father = <span class="built_in">document</span>.getElementById(<span class="string">'father'</span>);</span><br><span class="line">        <span class="keyword">var</span> son = <span class="built_in">document</span>.getElementById(<span class="string">'son'</span>);</span><br><span class="line">        </span><br><span class="line">        grandfather.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">'this is grandfather!'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        father.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">'this is father!'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        son.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">'this is son!'</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这个例子中，点击son，将依次弹出son father grandfather。<br>事件冒泡有时候很麻烦，需要阻止。</p><h4 id="事件冒泡的阻止"><a href="#事件冒泡的阻止" class="headerlink" title="事件冒泡的阻止"></a>事件冒泡的阻止</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>事件冒泡，重写onlick会覆盖之前属性(只能将冒泡事件一个一个处理)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grandfather.onclik = <span class="literal">null</span> ;</span><br></pre></td></tr></table></figure></p><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>addEventListener(event.type, function, boolean)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">son.addEventListener(<span class="string">'click'</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         grandfather.onclick = <span class="literal">null</span>；</span><br><span class="line">         father.onclick = <span class="literal">null</span>;</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p><p>click表示事件，要去掉on ，function里面可以写多个要求（同时处理多个冒泡事件），false表示在冒泡阶段作用。<br>整体表示 在冒泡阶段，给son的点击事件添加一个效果函数。</p><h5 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h5><p> event.stopPropagation()和 event.cancelBubble = true<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">son.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">'this is son!'</span>);</span><br><span class="line">            event.stopPropagation();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">son.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">'this is son!'</span>);</span><br><span class="line">            event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><p>事件捕获就是事件发生时首先发生在document（html）上，然后依次传递给body、grandfather,father,最后到达目的节点son（即事件目标）。事件捕获的过程和事件冒泡刚好相反。</p><h4 id="事件捕获的阻止"><a href="#事件捕获的阻止" class="headerlink" title="事件捕获的阻止"></a>事件捕获的阻止</h4><h5 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h5><p>addEventListener(event.type, function, true);</p><h5 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h5><p>event.stopPropagation();</p><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p><a href="https://www.cnblogs.com/liugang-vip/p/5616484.html" target="_blank" rel="noopener">https://www.cnblogs.com/liugang-vip/p/5616484.html</a></p><p>事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。（例如指定grandfather处理程序，则father和son的事件都可以通过冒泡传递到grandfather，让grandfather统一处理，即子元素可能有很多，很难区分，那我可以通过管理他们的父元素来处理程序，而父元素只有一个）。<br>核心代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> oBtn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">            <span class="keyword">var</span> oUl = <span class="built_in">document</span>.getElementById(<span class="string">"ul1"</span>);</span><br><span class="line">            <span class="keyword">var</span> aLi = oUl.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//事件委托，添加的子元素也有事件</span></span><br><span class="line">            oUl.onmouseover = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> ev = ev || <span class="built_in">window</span>.event;  <span class="comment">//考虑兼容性</span></span><br><span class="line">                <span class="keyword">var</span> target = ev.target || ev.srcElement;   <span class="comment">//target返回目标的dom节点</span></span><br><span class="line">                <span class="keyword">if</span>(target.nodeName.toLowerCase() == <span class="string">'li'</span>)&#123;  <span class="comment">//nodeName返回目标节点的大写字母名称，故用tolowerElement将其变小写。</span></span><br><span class="line">                    target.style.background = <span class="string">"red"</span>;        </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;;</span><br><span class="line">            oUl.onmouseout = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> ev = ev || <span class="built_in">window</span>.event;</span><br><span class="line">                <span class="keyword">var</span> target = ev.target || ev.srcElement;</span><br><span class="line">                <span class="keyword">if</span>(target.nodeName.toLowerCase() == <span class="string">'li'</span>)&#123;</span><br><span class="line">                    target.style.background = <span class="string">"#fff"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//添加新节点</span></span><br><span class="line">            oBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                num++;</span><br><span class="line">                <span class="keyword">var</span> oLi = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);   <span class="comment">//创建新元素</span></span><br><span class="line">                oLi.innerHTML = <span class="number">111</span>*aLi.length;                 </span><br><span class="line">                oUl.appendChild(oLi);         </span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>哪里会有人喜欢孤独，不过是不喜欢失望罢了。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 事件冒泡，捕获，委托 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bootstrap栅栏系统  flex布局</title>
      <link href="/2018/07/13/secondDay/"/>
      <url>/2018/07/13/secondDay/</url>
      
        <content type="html"><![CDATA[<h2 id="bootstrap栅栏系统"><a href="#bootstrap栅栏系统" class="headerlink" title="bootstrap栅栏系统"></a>bootstrap栅栏系统</h2><a id="more"></a><p><a href="https://v3.bootcss.com/css/" target="_blank" rel="noopener">https://v3.bootcss.com/css/</a></p><p>栅栏系统主要是将网页宽度分为12份，由开发人员通过class分配元素宽度占比，根据用户不同的屏幕分辨率，从而自行调节元素排版达到响应式布局的效果。</p><h4 id="基本实现前提"><a href="#基本实现前提" class="headerlink" title="基本实现前提"></a>基本实现前提</h4><p>Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"container"</span>&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></p><p>或者占据全部视口（viewport）的容器(宽度百分百)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"container-fluid"</span>&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>其中，最重要的一条原则是<strong>行（row）必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）</strong></p><h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><p>栅栏系统利用媒体查询，来创建关键的分界点阈值。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 超小屏幕（手机，小于 768px） */</span></span><br><span class="line"><span class="comment">/* 没有任何媒体查询相关的代码，因为这在 Bootstrap 中是默认的（还记得 Bootstrap 是移动设备优先的吗？） */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 小屏幕（平板，大于等于 768px） */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">@screen-sm-min</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中等屏幕（桌面显示器，大于等于 992px） */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">@screen-md-min</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 大屏幕（大桌面显示器，大于等于 1200px） */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">@screen-lg-min</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>bootstrap栅栏系统用在相同或者相似元素有规律的并排放置时候很好用，其他情况为实现响应式可以另寻他法。</p><h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><p>语法篇：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p><p>实例篇：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a></p><h4 id="实现水平垂直居中"><a href="#实现水平垂直居中" class="headerlink" title="实现水平垂直居中"></a>实现水平垂直居中</h4><p>父级<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span> : <span class="selector-tag">flex</span> ;</span><br><span class="line">justify-content : center ; //水平居中</span><br><span class="line">align-items: center ; //垂直居中</span><br></pre></td></tr></table></figure></p><p>子级align-self可以覆盖父级align-items的效果</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>flex适合比较简单的布局，在水平垂直居中上很方便，主要用来水平垂直居中。flex最重要的两个属性是justify-content（主轴排列方式）和align-items（交叉轴排列方式），学好这两个，基本的flex布局都没有问题。</p><p><strong>有时你会不自觉的在想，如果能回到过去，如果没有遇到她，如果没有跟她经历那一段路，如果是另外一个人，会不会更好一些。可是即便再给你一次机会，哪怕遇见一个非常完美的人，如果你不知道怎样去爱，依然不会有好的结局，正是因为这些遗憾，所以你明白了，这世界上，最难走的路，是回头路。所以你明白了，没有任何一次遇见，是可以重新开始的。所以你明白了，遇见的，其实就是最好的。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> bootstrap栅栏系统 </tag>
            
            <tag> flex布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git操作</title>
      <link href="/2018/07/12/firstDay/"/>
      <url>/2018/07/12/firstDay/</url>
      
        <content type="html"><![CDATA[<h2 id="git四个区域"><a href="#git四个区域" class="headerlink" title="git四个区域"></a>git四个区域</h2><a id="more"></a><h4 id="Workspace：工作区"><a href="#Workspace：工作区" class="headerlink" title="Workspace：工作区"></a>Workspace：工作区</h4><h5 id="平时我们进行增删除改的地方就是工作区，在我们自己建立的文件夹里面进行操作，（可以-git-cd-XX-进入XX文件，也可以右键文件夹选择-git-bash-here-，然后-git-clone-URL-仓库地址-，之后再-git-init-初始化-）"><a href="#平时我们进行增删除改的地方就是工作区，在我们自己建立的文件夹里面进行操作，（可以-git-cd-XX-进入XX文件，也可以右键文件夹选择-git-bash-here-，然后-git-clone-URL-仓库地址-，之后再-git-init-初始化-）" class="headerlink" title="平时我们进行增删除改的地方就是工作区，在我们自己建立的文件夹里面进行操作，（可以 $ git cd XX 进入XX文件，也可以右键文件夹选择 git bash here ，然后 $ git clone URL(仓库地址) ，之后再 $ git init (初始化)）"></a>平时我们进行增删除改的地方就是工作区，在我们自己建立的文件夹里面进行操作，（可以 <code>$ git cd XX</code> 进入XX文件，也可以右键文件夹选择 <code>git bash here</code> ，然后 <code>$ git clone URL(仓库地址)</code> ，之后再 <code>$ git init</code> (初始化)）</h5><h4 id="Index-Stage：暂存区"><a href="#Index-Stage：暂存区" class="headerlink" title="Index / Stage：暂存区"></a>Index / Stage：暂存区</h4><h5 id="git目录下的index文件（要用-git-ls-查看隐藏的暂存区文件）在暂存区的文件表示在git的管理下。"><a href="#git目录下的index文件（要用-git-ls-查看隐藏的暂存区文件）在暂存区的文件表示在git的管理下。" class="headerlink" title=".git目录下的index文件（要用 $ git -ls 查看隐藏的暂存区文件）在暂存区的文件表示在git的管理下。"></a>.git目录下的index文件（要用 <code>$ git -ls</code> 查看隐藏的暂存区文件）在暂存区的文件表示在git的管理下。</h5><h4 id="Repository：仓库区（或本地仓库）"><a href="#Repository：仓库区（或本地仓库）" class="headerlink" title="Repository：仓库区（或本地仓库）"></a>Repository：仓库区（或本地仓库）</h4><p>保存了被提交过的旧版本</p><h4 id="Remote：远程仓库"><a href="#Remote：远程仓库" class="headerlink" title="Remote：远程仓库"></a>Remote：远程仓库</h4><p>远程仓库的内容被多个协作关系的本地仓库所修改，所共用，是本地仓库的交集处，是团队合作的地方。</p><h3 id="下面是几个区的联系"><a href="#下面是几个区的联系" class="headerlink" title="下面是几个区的联系"></a>下面是几个区的联系</h3><p><strong>工作区</strong>通过 <code>$ git add</code> 操作将修改提交到,<strong>暂存区</strong> 通过 <code>$ git commit</code> 操作将修改提交到<strong>本地仓库</strong>， <strong>本地仓库</strong>通过 <code>$ git push</code> 将修改同步到<strong>远程仓库</strong> ，而<strong>远程仓库</strong>可以通过 <code>$ git pull</code> 把内容拖到<strong>工作区</strong>，也可以通过 <code>$ git fetch</code> 将<strong>远程仓库</strong>内容拖到<strong>本地仓库</strong>（想得到别人代码的时候常常这样做）</p><h4 id="下面再说说我们工作时候的最基础操作（以Crazy为工作分支为例）"><a href="#下面再说说我们工作时候的最基础操作（以Crazy为工作分支为例）" class="headerlink" title="下面再说说我们工作时候的最基础操作（以Crazy为工作分支为例）"></a>下面再说说我们工作时候的最基础操作（以Crazy为工作分支为例）</h4><h5 id="git-clone-仓库地址"><a href="#git-clone-仓库地址" class="headerlink" title="$ git clone 仓库地址"></a><code>$ git clone</code> 仓库地址<url></url></h5><h5 id="git-init-初始化本地仓库"><a href="#git-init-初始化本地仓库" class="headerlink" title="$ git init 初始化本地仓库"></a><code>$ git init</code> 初始化本地仓库</h5><h5 id="git-remote-v-查看远程仓库信息，也可以用来检查本地仓库是否连接上远程仓库"><a href="#git-remote-v-查看远程仓库信息，也可以用来检查本地仓库是否连接上远程仓库" class="headerlink" title="$ git remote -v (查看远程仓库信息，也可以用来检查本地仓库是否连接上远程仓库)"></a><code>$ git remote -v</code> (查看远程仓库信息，也可以用来检查本地仓库是否连接上远程仓库)</h5><h5 id="git-checkout-b-Crazy-创建分支Crazy-并且切换到新建分支Crazy"><a href="#git-checkout-b-Crazy-创建分支Crazy-并且切换到新建分支Crazy" class="headerlink" title="$ git checkout -b Crazy (创建分支Crazy 并且切换到新建分支Crazy)"></a><code>$ git checkout -b Crazy</code> (创建分支Crazy 并且切换到新建分支Crazy)</h5><h5 id="git-branch-（查看所有本地分支，现在的分支为绿色）"><a href="#git-branch-（查看所有本地分支，现在的分支为绿色）" class="headerlink" title="$ git branch （查看所有本地分支，现在的分支为绿色）"></a><code>$ git branch</code> （查看所有本地分支，现在的分支为绿色）</h5><h5 id="git-status-察看暂存区文件是否修改（若修改了为红色）"><a href="#git-status-察看暂存区文件是否修改（若修改了为红色）" class="headerlink" title="$ git status (察看暂存区文件是否修改（若修改了为红色）"></a><code>$ git status</code> (察看暂存区文件是否修改（若修改了为红色）</h5><h5 id="git-add-abc-txt-添加文件-git-add-是指全部添加文件"><a href="#git-add-abc-txt-添加文件-git-add-是指全部添加文件" class="headerlink" title="$ git add abc.txt (添加文件)  ($ git add . 是指全部添加文件)"></a><code>$ git add abc.txt</code> (添加文件)  ($ git add . 是指全部添加文件)</h5><h5 id="git-status-添加成功则变绿色"><a href="#git-status-添加成功则变绿色" class="headerlink" title="$ git status (添加成功则变绿色)"></a><code>$ git status</code> (添加成功则变绿色)</h5><h5 id="git-commit-m-“注释”（提交修改-到自己的本地仓库）"><a href="#git-commit-m-“注释”（提交修改-到自己的本地仓库）" class="headerlink" title="$ git commit -m “注释”（提交修改 到自己的本地仓库）"></a><code>$ git commit -m</code> “注释”（提交修改 到自己的本地仓库）</h5><h5 id="git-push-origin-Crazy-把本地仓库内容提交到Crazy分支"><a href="#git-push-origin-Crazy-把本地仓库内容提交到Crazy分支" class="headerlink" title="$ git push origin Crazy (把本地仓库内容提交到Crazy分支)"></a><code>$ git push origin Crazy</code> (把本地仓库内容提交到Crazy分支)</h5><h5 id="git-checkout-master-切换到分支master"><a href="#git-checkout-master-切换到分支master" class="headerlink" title="$ git checkout master  (切换到分支master)"></a><code>$ git checkout master</code>  (切换到分支master)</h5><h5 id="git-merge-Crazy-把Crazy分支内容搬到master分支，但Crazy分支内容不变"><a href="#git-merge-Crazy-把Crazy分支内容搬到master分支，但Crazy分支内容不变" class="headerlink" title="$ git merge Crazy (把Crazy分支内容搬到master分支，但Crazy分支内容不变)"></a><code>$ git merge Crazy</code> (把Crazy分支内容搬到master分支，但Crazy分支内容不变)</h5><h5 id="git-pull-origin-master-把master分支内容克隆到本地仓库"><a href="#git-pull-origin-master-把master分支内容克隆到本地仓库" class="headerlink" title="$ git pull origin master (把master分支内容克隆到本地仓库)"></a><code>$ git pull origin master</code> (把master分支内容克隆到本地仓库)</h5><h5 id="git-checkout-Crazy-切换分支"><a href="#git-checkout-Crazy-切换分支" class="headerlink" title="$ git checkout Crazy  (切换分支)"></a><code>$ git checkout Crazy</code>  (切换分支)</h5><h5 id="git-merge-master-把master内容搬到Crazy分支上"><a href="#git-merge-master-把master内容搬到Crazy分支上" class="headerlink" title="$ git merge master (把master内容搬到Crazy分支上)"></a><code>$ git merge master</code> (把master内容搬到Crazy分支上)</h5><p><strong>时间并不会真的帮我们解决什么问题，它只是把原来怎么也想不通的问题，变得不再重要了。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> git操作 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
